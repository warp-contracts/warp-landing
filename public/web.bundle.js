var rsdk = (() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __defProps = Object.defineProperties;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getOwnPropSymbols = Object.getOwnPropertySymbols;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __propIsEnum = Object.prototype.propertyIsEnumerable;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(b)) {
        if (__propIsEnum.call(b, prop))
          __defNormalProp(a, prop, b[prop]);
      }
    return a;
  };
  var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
  var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    __markAsModule(target);
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __reExport = (target, module2, desc2) => {
    if (module2 && typeof module2 === "object" || typeof module2 === "function") {
      for (let key of __getOwnPropNames(module2))
        if (!__hasOwnProp.call(target, key) && key !== "default")
          __defProp(target, key, { get: () => module2[key], enumerable: !(desc2 = __getOwnPropDesc(module2, key)) || desc2.enumerable });
    }
    return target;
  };
  var __toModule = (module2) => {
    return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
  };

  // node_modules/base64-js/index.js
  var require_base64_js = __commonJS({
    "node_modules/base64-js/index.js"(exports) {
      "use strict";
      exports.byteLength = byteLength;
      exports.toByteArray = toByteArray;
      exports.fromByteArray = fromByteArray;
      var lookup = [];
      var revLookup = [];
      var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
      var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      for (i = 0, len = code.length; i < len; ++i) {
        lookup[i] = code[i];
        revLookup[code.charCodeAt(i)] = i;
      }
      var i;
      var len;
      revLookup["-".charCodeAt(0)] = 62;
      revLookup["_".charCodeAt(0)] = 63;
      function getLens(b64) {
        var len2 = b64.length;
        if (len2 % 4 > 0) {
          throw new Error("Invalid string. Length must be a multiple of 4");
        }
        var validLen = b64.indexOf("=");
        if (validLen === -1)
          validLen = len2;
        var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
        return [validLen, placeHoldersLen];
      }
      function byteLength(b64) {
        var lens = getLens(b64);
        var validLen = lens[0];
        var placeHoldersLen = lens[1];
        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
      }
      function _byteLength(b64, validLen, placeHoldersLen) {
        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
      }
      function toByteArray(b64) {
        var tmp;
        var lens = getLens(b64);
        var validLen = lens[0];
        var placeHoldersLen = lens[1];
        var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
        var curByte = 0;
        var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
        var i2;
        for (i2 = 0; i2 < len2; i2 += 4) {
          tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
          arr[curByte++] = tmp >> 16 & 255;
          arr[curByte++] = tmp >> 8 & 255;
          arr[curByte++] = tmp & 255;
        }
        if (placeHoldersLen === 2) {
          tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
          arr[curByte++] = tmp & 255;
        }
        if (placeHoldersLen === 1) {
          tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
          arr[curByte++] = tmp >> 8 & 255;
          arr[curByte++] = tmp & 255;
        }
        return arr;
      }
      function tripletToBase64(num) {
        return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
      }
      function encodeChunk(uint8, start, end) {
        var tmp;
        var output = [];
        for (var i2 = start; i2 < end; i2 += 3) {
          tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
          output.push(tripletToBase64(tmp));
        }
        return output.join("");
      }
      function fromByteArray(uint8) {
        var tmp;
        var len2 = uint8.length;
        var extraBytes = len2 % 3;
        var parts = [];
        var maxChunkLength = 16383;
        for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
          parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
        }
        if (extraBytes === 1) {
          tmp = uint8[len2 - 1];
          parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "==");
        } else if (extraBytes === 2) {
          tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
          parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "=");
        }
        return parts.join("");
      }
    }
  });

  // node_modules/ieee754/index.js
  var require_ieee754 = __commonJS({
    "node_modules/ieee754/index.js"(exports) {
      exports.read = function(buffer, offset, isLE, mLen, nBytes) {
        var e, m;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var nBits = -7;
        var i = isLE ? nBytes - 1 : 0;
        var d = isLE ? -1 : 1;
        var s = buffer[offset + i];
        i += d;
        e = s & (1 << -nBits) - 1;
        s >>= -nBits;
        nBits += eLen;
        for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
        }
        m = e & (1 << -nBits) - 1;
        e >>= -nBits;
        nBits += mLen;
        for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
        }
        if (e === 0) {
          e = 1 - eBias;
        } else if (e === eMax) {
          return m ? NaN : (s ? -1 : 1) * Infinity;
        } else {
          m = m + Math.pow(2, mLen);
          e = e - eBias;
        }
        return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
      };
      exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
        var e, m, c;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
        var i = isLE ? 0 : nBytes - 1;
        var d = isLE ? 1 : -1;
        var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
        value = Math.abs(value);
        if (isNaN(value) || value === Infinity) {
          m = isNaN(value) ? 1 : 0;
          e = eMax;
        } else {
          e = Math.floor(Math.log(value) / Math.LN2);
          if (value * (c = Math.pow(2, -e)) < 1) {
            e--;
            c *= 2;
          }
          if (e + eBias >= 1) {
            value += rt / c;
          } else {
            value += rt * Math.pow(2, 1 - eBias);
          }
          if (value * c >= 2) {
            e++;
            c /= 2;
          }
          if (e + eBias >= eMax) {
            m = 0;
            e = eMax;
          } else if (e + eBias >= 1) {
            m = (value * c - 1) * Math.pow(2, mLen);
            e = e + eBias;
          } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e = 0;
          }
        }
        for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
        }
        e = e << mLen | m;
        eLen += mLen;
        for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
        }
        buffer[offset + i - d] |= s * 128;
      };
    }
  });

  // node_modules/buffer/index.js
  var require_buffer = __commonJS({
    "node_modules/buffer/index.js"(exports) {
      "use strict";
      var base64 = require_base64_js();
      var ieee754 = require_ieee754();
      var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
      exports.Buffer = Buffer3;
      exports.SlowBuffer = SlowBuffer;
      exports.INSPECT_MAX_BYTES = 50;
      var K_MAX_LENGTH = 2147483647;
      exports.kMaxLength = K_MAX_LENGTH;
      Buffer3.TYPED_ARRAY_SUPPORT = typedArraySupport();
      if (!Buffer3.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
        console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
      }
      function typedArraySupport() {
        try {
          const arr = new Uint8Array(1);
          const proto = { foo: function() {
            return 42;
          } };
          Object.setPrototypeOf(proto, Uint8Array.prototype);
          Object.setPrototypeOf(arr, proto);
          return arr.foo() === 42;
        } catch (e) {
          return false;
        }
      }
      Object.defineProperty(Buffer3.prototype, "parent", {
        enumerable: true,
        get: function() {
          if (!Buffer3.isBuffer(this))
            return void 0;
          return this.buffer;
        }
      });
      Object.defineProperty(Buffer3.prototype, "offset", {
        enumerable: true,
        get: function() {
          if (!Buffer3.isBuffer(this))
            return void 0;
          return this.byteOffset;
        }
      });
      function createBuffer(length) {
        if (length > K_MAX_LENGTH) {
          throw new RangeError('The value "' + length + '" is invalid for option "size"');
        }
        const buf = new Uint8Array(length);
        Object.setPrototypeOf(buf, Buffer3.prototype);
        return buf;
      }
      function Buffer3(arg, encodingOrOffset, length) {
        if (typeof arg === "number") {
          if (typeof encodingOrOffset === "string") {
            throw new TypeError('The "string" argument must be of type string. Received type number');
          }
          return allocUnsafe(arg);
        }
        return from(arg, encodingOrOffset, length);
      }
      Buffer3.poolSize = 8192;
      function from(value, encodingOrOffset, length) {
        if (typeof value === "string") {
          return fromString(value, encodingOrOffset);
        }
        if (ArrayBuffer.isView(value)) {
          return fromArrayView(value);
        }
        if (value == null) {
          throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
        }
        if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
          return fromArrayBuffer(value, encodingOrOffset, length);
        }
        if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
          return fromArrayBuffer(value, encodingOrOffset, length);
        }
        if (typeof value === "number") {
          throw new TypeError('The "value" argument must not be of type number. Received type number');
        }
        const valueOf = value.valueOf && value.valueOf();
        if (valueOf != null && valueOf !== value) {
          return Buffer3.from(valueOf, encodingOrOffset, length);
        }
        const b = fromObject(value);
        if (b)
          return b;
        if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
          return Buffer3.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
        }
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
      }
      Buffer3.from = function(value, encodingOrOffset, length) {
        return from(value, encodingOrOffset, length);
      };
      Object.setPrototypeOf(Buffer3.prototype, Uint8Array.prototype);
      Object.setPrototypeOf(Buffer3, Uint8Array);
      function assertSize(size) {
        if (typeof size !== "number") {
          throw new TypeError('"size" argument must be of type number');
        } else if (size < 0) {
          throw new RangeError('The value "' + size + '" is invalid for option "size"');
        }
      }
      function alloc(size, fill, encoding) {
        assertSize(size);
        if (size <= 0) {
          return createBuffer(size);
        }
        if (fill !== void 0) {
          return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
        }
        return createBuffer(size);
      }
      Buffer3.alloc = function(size, fill, encoding) {
        return alloc(size, fill, encoding);
      };
      function allocUnsafe(size) {
        assertSize(size);
        return createBuffer(size < 0 ? 0 : checked(size) | 0);
      }
      Buffer3.allocUnsafe = function(size) {
        return allocUnsafe(size);
      };
      Buffer3.allocUnsafeSlow = function(size) {
        return allocUnsafe(size);
      };
      function fromString(string, encoding) {
        if (typeof encoding !== "string" || encoding === "") {
          encoding = "utf8";
        }
        if (!Buffer3.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        const length = byteLength(string, encoding) | 0;
        let buf = createBuffer(length);
        const actual = buf.write(string, encoding);
        if (actual !== length) {
          buf = buf.slice(0, actual);
        }
        return buf;
      }
      function fromArrayLike(array) {
        const length = array.length < 0 ? 0 : checked(array.length) | 0;
        const buf = createBuffer(length);
        for (let i = 0; i < length; i += 1) {
          buf[i] = array[i] & 255;
        }
        return buf;
      }
      function fromArrayView(arrayView) {
        if (isInstance(arrayView, Uint8Array)) {
          const copy2 = new Uint8Array(arrayView);
          return fromArrayBuffer(copy2.buffer, copy2.byteOffset, copy2.byteLength);
        }
        return fromArrayLike(arrayView);
      }
      function fromArrayBuffer(array, byteOffset, length) {
        if (byteOffset < 0 || array.byteLength < byteOffset) {
          throw new RangeError('"offset" is outside of buffer bounds');
        }
        if (array.byteLength < byteOffset + (length || 0)) {
          throw new RangeError('"length" is outside of buffer bounds');
        }
        let buf;
        if (byteOffset === void 0 && length === void 0) {
          buf = new Uint8Array(array);
        } else if (length === void 0) {
          buf = new Uint8Array(array, byteOffset);
        } else {
          buf = new Uint8Array(array, byteOffset, length);
        }
        Object.setPrototypeOf(buf, Buffer3.prototype);
        return buf;
      }
      function fromObject(obj) {
        if (Buffer3.isBuffer(obj)) {
          const len = checked(obj.length) | 0;
          const buf = createBuffer(len);
          if (buf.length === 0) {
            return buf;
          }
          obj.copy(buf, 0, 0, len);
          return buf;
        }
        if (obj.length !== void 0) {
          if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
            return createBuffer(0);
          }
          return fromArrayLike(obj);
        }
        if (obj.type === "Buffer" && Array.isArray(obj.data)) {
          return fromArrayLike(obj.data);
        }
      }
      function checked(length) {
        if (length >= K_MAX_LENGTH) {
          throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
        }
        return length | 0;
      }
      function SlowBuffer(length) {
        if (+length != length) {
          length = 0;
        }
        return Buffer3.alloc(+length);
      }
      Buffer3.isBuffer = function isBuffer(b) {
        return b != null && b._isBuffer === true && b !== Buffer3.prototype;
      };
      Buffer3.compare = function compare(a, b) {
        if (isInstance(a, Uint8Array))
          a = Buffer3.from(a, a.offset, a.byteLength);
        if (isInstance(b, Uint8Array))
          b = Buffer3.from(b, b.offset, b.byteLength);
        if (!Buffer3.isBuffer(a) || !Buffer3.isBuffer(b)) {
          throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
        }
        if (a === b)
          return 0;
        let x = a.length;
        let y = b.length;
        for (let i = 0, len = Math.min(x, y); i < len; ++i) {
          if (a[i] !== b[i]) {
            x = a[i];
            y = b[i];
            break;
          }
        }
        if (x < y)
          return -1;
        if (y < x)
          return 1;
        return 0;
      };
      Buffer3.isEncoding = function isEncoding(encoding) {
        switch (String(encoding).toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "latin1":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return true;
          default:
            return false;
        }
      };
      Buffer3.concat = function concat(list, length) {
        if (!Array.isArray(list)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        }
        if (list.length === 0) {
          return Buffer3.alloc(0);
        }
        let i;
        if (length === void 0) {
          length = 0;
          for (i = 0; i < list.length; ++i) {
            length += list[i].length;
          }
        }
        const buffer = Buffer3.allocUnsafe(length);
        let pos = 0;
        for (i = 0; i < list.length; ++i) {
          let buf = list[i];
          if (isInstance(buf, Uint8Array)) {
            if (pos + buf.length > buffer.length) {
              if (!Buffer3.isBuffer(buf))
                buf = Buffer3.from(buf);
              buf.copy(buffer, pos);
            } else {
              Uint8Array.prototype.set.call(buffer, buf, pos);
            }
          } else if (!Buffer3.isBuffer(buf)) {
            throw new TypeError('"list" argument must be an Array of Buffers');
          } else {
            buf.copy(buffer, pos);
          }
          pos += buf.length;
        }
        return buffer;
      };
      function byteLength(string, encoding) {
        if (Buffer3.isBuffer(string)) {
          return string.length;
        }
        if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
          return string.byteLength;
        }
        if (typeof string !== "string") {
          throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string);
        }
        const len = string.length;
        const mustMatch = arguments.length > 2 && arguments[2] === true;
        if (!mustMatch && len === 0)
          return 0;
        let loweredCase = false;
        for (; ; ) {
          switch (encoding) {
            case "ascii":
            case "latin1":
            case "binary":
              return len;
            case "utf8":
            case "utf-8":
              return utf8ToBytes(string).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return len * 2;
            case "hex":
              return len >>> 1;
            case "base64":
              return base64ToBytes(string).length;
            default:
              if (loweredCase) {
                return mustMatch ? -1 : utf8ToBytes(string).length;
              }
              encoding = ("" + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      }
      Buffer3.byteLength = byteLength;
      function slowToString(encoding, start, end) {
        let loweredCase = false;
        if (start === void 0 || start < 0) {
          start = 0;
        }
        if (start > this.length) {
          return "";
        }
        if (end === void 0 || end > this.length) {
          end = this.length;
        }
        if (end <= 0) {
          return "";
        }
        end >>>= 0;
        start >>>= 0;
        if (end <= start) {
          return "";
        }
        if (!encoding)
          encoding = "utf8";
        while (true) {
          switch (encoding) {
            case "hex":
              return hexSlice(this, start, end);
            case "utf8":
            case "utf-8":
              return utf8Slice(this, start, end);
            case "ascii":
              return asciiSlice(this, start, end);
            case "latin1":
            case "binary":
              return latin1Slice(this, start, end);
            case "base64":
              return base64Slice(this, start, end);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return utf16leSlice(this, start, end);
            default:
              if (loweredCase)
                throw new TypeError("Unknown encoding: " + encoding);
              encoding = (encoding + "").toLowerCase();
              loweredCase = true;
          }
        }
      }
      Buffer3.prototype._isBuffer = true;
      function swap(b, n, m) {
        const i = b[n];
        b[n] = b[m];
        b[m] = i;
      }
      Buffer3.prototype.swap16 = function swap16() {
        const len = this.length;
        if (len % 2 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 16-bits");
        }
        for (let i = 0; i < len; i += 2) {
          swap(this, i, i + 1);
        }
        return this;
      };
      Buffer3.prototype.swap32 = function swap32() {
        const len = this.length;
        if (len % 4 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 32-bits");
        }
        for (let i = 0; i < len; i += 4) {
          swap(this, i, i + 3);
          swap(this, i + 1, i + 2);
        }
        return this;
      };
      Buffer3.prototype.swap64 = function swap64() {
        const len = this.length;
        if (len % 8 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 64-bits");
        }
        for (let i = 0; i < len; i += 8) {
          swap(this, i, i + 7);
          swap(this, i + 1, i + 6);
          swap(this, i + 2, i + 5);
          swap(this, i + 3, i + 4);
        }
        return this;
      };
      Buffer3.prototype.toString = function toString2() {
        const length = this.length;
        if (length === 0)
          return "";
        if (arguments.length === 0)
          return utf8Slice(this, 0, length);
        return slowToString.apply(this, arguments);
      };
      Buffer3.prototype.toLocaleString = Buffer3.prototype.toString;
      Buffer3.prototype.equals = function equals(b) {
        if (!Buffer3.isBuffer(b))
          throw new TypeError("Argument must be a Buffer");
        if (this === b)
          return true;
        return Buffer3.compare(this, b) === 0;
      };
      Buffer3.prototype.inspect = function inspect() {
        let str = "";
        const max = exports.INSPECT_MAX_BYTES;
        str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
        if (this.length > max)
          str += " ... ";
        return "<Buffer " + str + ">";
      };
      if (customInspectSymbol) {
        Buffer3.prototype[customInspectSymbol] = Buffer3.prototype.inspect;
      }
      Buffer3.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
        if (isInstance(target, Uint8Array)) {
          target = Buffer3.from(target, target.offset, target.byteLength);
        }
        if (!Buffer3.isBuffer(target)) {
          throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);
        }
        if (start === void 0) {
          start = 0;
        }
        if (end === void 0) {
          end = target ? target.length : 0;
        }
        if (thisStart === void 0) {
          thisStart = 0;
        }
        if (thisEnd === void 0) {
          thisEnd = this.length;
        }
        if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
          throw new RangeError("out of range index");
        }
        if (thisStart >= thisEnd && start >= end) {
          return 0;
        }
        if (thisStart >= thisEnd) {
          return -1;
        }
        if (start >= end) {
          return 1;
        }
        start >>>= 0;
        end >>>= 0;
        thisStart >>>= 0;
        thisEnd >>>= 0;
        if (this === target)
          return 0;
        let x = thisEnd - thisStart;
        let y = end - start;
        const len = Math.min(x, y);
        const thisCopy = this.slice(thisStart, thisEnd);
        const targetCopy = target.slice(start, end);
        for (let i = 0; i < len; ++i) {
          if (thisCopy[i] !== targetCopy[i]) {
            x = thisCopy[i];
            y = targetCopy[i];
            break;
          }
        }
        if (x < y)
          return -1;
        if (y < x)
          return 1;
        return 0;
      };
      function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
        if (buffer.length === 0)
          return -1;
        if (typeof byteOffset === "string") {
          encoding = byteOffset;
          byteOffset = 0;
        } else if (byteOffset > 2147483647) {
          byteOffset = 2147483647;
        } else if (byteOffset < -2147483648) {
          byteOffset = -2147483648;
        }
        byteOffset = +byteOffset;
        if (numberIsNaN(byteOffset)) {
          byteOffset = dir ? 0 : buffer.length - 1;
        }
        if (byteOffset < 0)
          byteOffset = buffer.length + byteOffset;
        if (byteOffset >= buffer.length) {
          if (dir)
            return -1;
          else
            byteOffset = buffer.length - 1;
        } else if (byteOffset < 0) {
          if (dir)
            byteOffset = 0;
          else
            return -1;
        }
        if (typeof val === "string") {
          val = Buffer3.from(val, encoding);
        }
        if (Buffer3.isBuffer(val)) {
          if (val.length === 0) {
            return -1;
          }
          return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
        } else if (typeof val === "number") {
          val = val & 255;
          if (typeof Uint8Array.prototype.indexOf === "function") {
            if (dir) {
              return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
            } else {
              return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
            }
          }
          return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
        }
        throw new TypeError("val must be string, number or Buffer");
      }
      function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
        let indexSize = 1;
        let arrLength = arr.length;
        let valLength = val.length;
        if (encoding !== void 0) {
          encoding = String(encoding).toLowerCase();
          if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
            if (arr.length < 2 || val.length < 2) {
              return -1;
            }
            indexSize = 2;
            arrLength /= 2;
            valLength /= 2;
            byteOffset /= 2;
          }
        }
        function read(buf, i2) {
          if (indexSize === 1) {
            return buf[i2];
          } else {
            return buf.readUInt16BE(i2 * indexSize);
          }
        }
        let i;
        if (dir) {
          let foundIndex = -1;
          for (i = byteOffset; i < arrLength; i++) {
            if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
              if (foundIndex === -1)
                foundIndex = i;
              if (i - foundIndex + 1 === valLength)
                return foundIndex * indexSize;
            } else {
              if (foundIndex !== -1)
                i -= i - foundIndex;
              foundIndex = -1;
            }
          }
        } else {
          if (byteOffset + valLength > arrLength)
            byteOffset = arrLength - valLength;
          for (i = byteOffset; i >= 0; i--) {
            let found = true;
            for (let j = 0; j < valLength; j++) {
              if (read(arr, i + j) !== read(val, j)) {
                found = false;
                break;
              }
            }
            if (found)
              return i;
          }
        }
        return -1;
      }
      Buffer3.prototype.includes = function includes(val, byteOffset, encoding) {
        return this.indexOf(val, byteOffset, encoding) !== -1;
      };
      Buffer3.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
      };
      Buffer3.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
      };
      function hexWrite(buf, string, offset, length) {
        offset = Number(offset) || 0;
        const remaining = buf.length - offset;
        if (!length) {
          length = remaining;
        } else {
          length = Number(length);
          if (length > remaining) {
            length = remaining;
          }
        }
        const strLen = string.length;
        if (length > strLen / 2) {
          length = strLen / 2;
        }
        let i;
        for (i = 0; i < length; ++i) {
          const parsed = parseInt(string.substr(i * 2, 2), 16);
          if (numberIsNaN(parsed))
            return i;
          buf[offset + i] = parsed;
        }
        return i;
      }
      function utf8Write(buf, string, offset, length) {
        return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
      }
      function asciiWrite(buf, string, offset, length) {
        return blitBuffer(asciiToBytes(string), buf, offset, length);
      }
      function base64Write(buf, string, offset, length) {
        return blitBuffer(base64ToBytes(string), buf, offset, length);
      }
      function ucs2Write(buf, string, offset, length) {
        return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
      }
      Buffer3.prototype.write = function write(string, offset, length, encoding) {
        if (offset === void 0) {
          encoding = "utf8";
          length = this.length;
          offset = 0;
        } else if (length === void 0 && typeof offset === "string") {
          encoding = offset;
          length = this.length;
          offset = 0;
        } else if (isFinite(offset)) {
          offset = offset >>> 0;
          if (isFinite(length)) {
            length = length >>> 0;
            if (encoding === void 0)
              encoding = "utf8";
          } else {
            encoding = length;
            length = void 0;
          }
        } else {
          throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
        }
        const remaining = this.length - offset;
        if (length === void 0 || length > remaining)
          length = remaining;
        if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
          throw new RangeError("Attempt to write outside buffer bounds");
        }
        if (!encoding)
          encoding = "utf8";
        let loweredCase = false;
        for (; ; ) {
          switch (encoding) {
            case "hex":
              return hexWrite(this, string, offset, length);
            case "utf8":
            case "utf-8":
              return utf8Write(this, string, offset, length);
            case "ascii":
            case "latin1":
            case "binary":
              return asciiWrite(this, string, offset, length);
            case "base64":
              return base64Write(this, string, offset, length);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return ucs2Write(this, string, offset, length);
            default:
              if (loweredCase)
                throw new TypeError("Unknown encoding: " + encoding);
              encoding = ("" + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      };
      Buffer3.prototype.toJSON = function toJSON() {
        return {
          type: "Buffer",
          data: Array.prototype.slice.call(this._arr || this, 0)
        };
      };
      function base64Slice(buf, start, end) {
        if (start === 0 && end === buf.length) {
          return base64.fromByteArray(buf);
        } else {
          return base64.fromByteArray(buf.slice(start, end));
        }
      }
      function utf8Slice(buf, start, end) {
        end = Math.min(buf.length, end);
        const res = [];
        let i = start;
        while (i < end) {
          const firstByte = buf[i];
          let codePoint = null;
          let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
          if (i + bytesPerSequence <= end) {
            let secondByte, thirdByte, fourthByte, tempCodePoint;
            switch (bytesPerSequence) {
              case 1:
                if (firstByte < 128) {
                  codePoint = firstByte;
                }
                break;
              case 2:
                secondByte = buf[i + 1];
                if ((secondByte & 192) === 128) {
                  tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                  if (tempCodePoint > 127) {
                    codePoint = tempCodePoint;
                  }
                }
                break;
              case 3:
                secondByte = buf[i + 1];
                thirdByte = buf[i + 2];
                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                  tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                  if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                    codePoint = tempCodePoint;
                  }
                }
                break;
              case 4:
                secondByte = buf[i + 1];
                thirdByte = buf[i + 2];
                fourthByte = buf[i + 3];
                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                  tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                  if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                    codePoint = tempCodePoint;
                  }
                }
            }
          }
          if (codePoint === null) {
            codePoint = 65533;
            bytesPerSequence = 1;
          } else if (codePoint > 65535) {
            codePoint -= 65536;
            res.push(codePoint >>> 10 & 1023 | 55296);
            codePoint = 56320 | codePoint & 1023;
          }
          res.push(codePoint);
          i += bytesPerSequence;
        }
        return decodeCodePointsArray(res);
      }
      var MAX_ARGUMENTS_LENGTH = 4096;
      function decodeCodePointsArray(codePoints) {
        const len = codePoints.length;
        if (len <= MAX_ARGUMENTS_LENGTH) {
          return String.fromCharCode.apply(String, codePoints);
        }
        let res = "";
        let i = 0;
        while (i < len) {
          res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
        }
        return res;
      }
      function asciiSlice(buf, start, end) {
        let ret = "";
        end = Math.min(buf.length, end);
        for (let i = start; i < end; ++i) {
          ret += String.fromCharCode(buf[i] & 127);
        }
        return ret;
      }
      function latin1Slice(buf, start, end) {
        let ret = "";
        end = Math.min(buf.length, end);
        for (let i = start; i < end; ++i) {
          ret += String.fromCharCode(buf[i]);
        }
        return ret;
      }
      function hexSlice(buf, start, end) {
        const len = buf.length;
        if (!start || start < 0)
          start = 0;
        if (!end || end < 0 || end > len)
          end = len;
        let out = "";
        for (let i = start; i < end; ++i) {
          out += hexSliceLookupTable[buf[i]];
        }
        return out;
      }
      function utf16leSlice(buf, start, end) {
        const bytes = buf.slice(start, end);
        let res = "";
        for (let i = 0; i < bytes.length - 1; i += 2) {
          res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
        }
        return res;
      }
      Buffer3.prototype.slice = function slice(start, end) {
        const len = this.length;
        start = ~~start;
        end = end === void 0 ? len : ~~end;
        if (start < 0) {
          start += len;
          if (start < 0)
            start = 0;
        } else if (start > len) {
          start = len;
        }
        if (end < 0) {
          end += len;
          if (end < 0)
            end = 0;
        } else if (end > len) {
          end = len;
        }
        if (end < start)
          end = start;
        const newBuf = this.subarray(start, end);
        Object.setPrototypeOf(newBuf, Buffer3.prototype);
        return newBuf;
      };
      function checkOffset(offset, ext, length) {
        if (offset % 1 !== 0 || offset < 0)
          throw new RangeError("offset is not uint");
        if (offset + ext > length)
          throw new RangeError("Trying to access beyond buffer length");
      }
      Buffer3.prototype.readUintLE = Buffer3.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert)
          checkOffset(offset, byteLength2, this.length);
        let val = this[offset];
        let mul = 1;
        let i = 0;
        while (++i < byteLength2 && (mul *= 256)) {
          val += this[offset + i] * mul;
        }
        return val;
      };
      Buffer3.prototype.readUintBE = Buffer3.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) {
          checkOffset(offset, byteLength2, this.length);
        }
        let val = this[offset + --byteLength2];
        let mul = 1;
        while (byteLength2 > 0 && (mul *= 256)) {
          val += this[offset + --byteLength2] * mul;
        }
        return val;
      };
      Buffer3.prototype.readUint8 = Buffer3.prototype.readUInt8 = function readUInt8(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 1, this.length);
        return this[offset];
      };
      Buffer3.prototype.readUint16LE = Buffer3.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        return this[offset] | this[offset + 1] << 8;
      };
      Buffer3.prototype.readUint16BE = Buffer3.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        return this[offset] << 8 | this[offset + 1];
      };
      Buffer3.prototype.readUint32LE = Buffer3.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
      };
      Buffer3.prototype.readUint32BE = Buffer3.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
      };
      Buffer3.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
        const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
        return BigInt(lo) + (BigInt(hi) << BigInt(32));
      });
      Buffer3.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
        const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
        return (BigInt(hi) << BigInt(32)) + BigInt(lo);
      });
      Buffer3.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert)
          checkOffset(offset, byteLength2, this.length);
        let val = this[offset];
        let mul = 1;
        let i = 0;
        while (++i < byteLength2 && (mul *= 256)) {
          val += this[offset + i] * mul;
        }
        mul *= 128;
        if (val >= mul)
          val -= Math.pow(2, 8 * byteLength2);
        return val;
      };
      Buffer3.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert)
          checkOffset(offset, byteLength2, this.length);
        let i = byteLength2;
        let mul = 1;
        let val = this[offset + --i];
        while (i > 0 && (mul *= 256)) {
          val += this[offset + --i] * mul;
        }
        mul *= 128;
        if (val >= mul)
          val -= Math.pow(2, 8 * byteLength2);
        return val;
      };
      Buffer3.prototype.readInt8 = function readInt8(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 1, this.length);
        if (!(this[offset] & 128))
          return this[offset];
        return (255 - this[offset] + 1) * -1;
      };
      Buffer3.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        const val = this[offset] | this[offset + 1] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };
      Buffer3.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        const val = this[offset + 1] | this[offset] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };
      Buffer3.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
      };
      Buffer3.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
      };
      Buffer3.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
        return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
      });
      Buffer3.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const val = (first << 24) + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
        return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
      });
      Buffer3.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return ieee754.read(this, offset, true, 23, 4);
      };
      Buffer3.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return ieee754.read(this, offset, false, 23, 4);
      };
      Buffer3.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 8, this.length);
        return ieee754.read(this, offset, true, 52, 8);
      };
      Buffer3.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 8, this.length);
        return ieee754.read(this, offset, false, 52, 8);
      };
      function checkInt(buf, value, offset, ext, max, min) {
        if (!Buffer3.isBuffer(buf))
          throw new TypeError('"buffer" argument must be a Buffer instance');
        if (value > max || value < min)
          throw new RangeError('"value" argument is out of bounds');
        if (offset + ext > buf.length)
          throw new RangeError("Index out of range");
      }
      Buffer3.prototype.writeUintLE = Buffer3.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) {
          const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
          checkInt(this, value, offset, byteLength2, maxBytes, 0);
        }
        let mul = 1;
        let i = 0;
        this[offset] = value & 255;
        while (++i < byteLength2 && (mul *= 256)) {
          this[offset + i] = value / mul & 255;
        }
        return offset + byteLength2;
      };
      Buffer3.prototype.writeUintBE = Buffer3.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) {
          const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
          checkInt(this, value, offset, byteLength2, maxBytes, 0);
        }
        let i = byteLength2 - 1;
        let mul = 1;
        this[offset + i] = value & 255;
        while (--i >= 0 && (mul *= 256)) {
          this[offset + i] = value / mul & 255;
        }
        return offset + byteLength2;
      };
      Buffer3.prototype.writeUint8 = Buffer3.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 1, 255, 0);
        this[offset] = value & 255;
        return offset + 1;
      };
      Buffer3.prototype.writeUint16LE = Buffer3.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 65535, 0);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        return offset + 2;
      };
      Buffer3.prototype.writeUint16BE = Buffer3.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 65535, 0);
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
        return offset + 2;
      };
      Buffer3.prototype.writeUint32LE = Buffer3.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 4294967295, 0);
        this[offset + 3] = value >>> 24;
        this[offset + 2] = value >>> 16;
        this[offset + 1] = value >>> 8;
        this[offset] = value & 255;
        return offset + 4;
      };
      Buffer3.prototype.writeUint32BE = Buffer3.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 4294967295, 0);
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
        return offset + 4;
      };
      function wrtBigUInt64LE(buf, value, offset, min, max) {
        checkIntBI(value, min, max, buf, offset, 7);
        let lo = Number(value & BigInt(4294967295));
        buf[offset++] = lo;
        lo = lo >> 8;
        buf[offset++] = lo;
        lo = lo >> 8;
        buf[offset++] = lo;
        lo = lo >> 8;
        buf[offset++] = lo;
        let hi = Number(value >> BigInt(32) & BigInt(4294967295));
        buf[offset++] = hi;
        hi = hi >> 8;
        buf[offset++] = hi;
        hi = hi >> 8;
        buf[offset++] = hi;
        hi = hi >> 8;
        buf[offset++] = hi;
        return offset;
      }
      function wrtBigUInt64BE(buf, value, offset, min, max) {
        checkIntBI(value, min, max, buf, offset, 7);
        let lo = Number(value & BigInt(4294967295));
        buf[offset + 7] = lo;
        lo = lo >> 8;
        buf[offset + 6] = lo;
        lo = lo >> 8;
        buf[offset + 5] = lo;
        lo = lo >> 8;
        buf[offset + 4] = lo;
        let hi = Number(value >> BigInt(32) & BigInt(4294967295));
        buf[offset + 3] = hi;
        hi = hi >> 8;
        buf[offset + 2] = hi;
        hi = hi >> 8;
        buf[offset + 1] = hi;
        hi = hi >> 8;
        buf[offset] = hi;
        return offset + 8;
      }
      Buffer3.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
        return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
      });
      Buffer3.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
        return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
      });
      Buffer3.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          const limit = Math.pow(2, 8 * byteLength2 - 1);
          checkInt(this, value, offset, byteLength2, limit - 1, -limit);
        }
        let i = 0;
        let mul = 1;
        let sub = 0;
        this[offset] = value & 255;
        while (++i < byteLength2 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
            sub = 1;
          }
          this[offset + i] = (value / mul >> 0) - sub & 255;
        }
        return offset + byteLength2;
      };
      Buffer3.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          const limit = Math.pow(2, 8 * byteLength2 - 1);
          checkInt(this, value, offset, byteLength2, limit - 1, -limit);
        }
        let i = byteLength2 - 1;
        let mul = 1;
        let sub = 0;
        this[offset + i] = value & 255;
        while (--i >= 0 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
            sub = 1;
          }
          this[offset + i] = (value / mul >> 0) - sub & 255;
        }
        return offset + byteLength2;
      };
      Buffer3.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 1, 127, -128);
        if (value < 0)
          value = 255 + value + 1;
        this[offset] = value & 255;
        return offset + 1;
      };
      Buffer3.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 32767, -32768);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        return offset + 2;
      };
      Buffer3.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 32767, -32768);
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
        return offset + 2;
      };
      Buffer3.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 2147483647, -2147483648);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        this[offset + 2] = value >>> 16;
        this[offset + 3] = value >>> 24;
        return offset + 4;
      };
      Buffer3.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 2147483647, -2147483648);
        if (value < 0)
          value = 4294967295 + value + 1;
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
        return offset + 4;
      };
      Buffer3.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
        return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
      });
      Buffer3.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
        return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
      });
      function checkIEEE754(buf, value, offset, ext, max, min) {
        if (offset + ext > buf.length)
          throw new RangeError("Index out of range");
        if (offset < 0)
          throw new RangeError("Index out of range");
      }
      function writeFloat(buf, value, offset, littleEndian, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
        }
        ieee754.write(buf, value, offset, littleEndian, 23, 4);
        return offset + 4;
      }
      Buffer3.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
        return writeFloat(this, value, offset, true, noAssert);
      };
      Buffer3.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
        return writeFloat(this, value, offset, false, noAssert);
      };
      function writeDouble(buf, value, offset, littleEndian, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
        }
        ieee754.write(buf, value, offset, littleEndian, 52, 8);
        return offset + 8;
      }
      Buffer3.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
        return writeDouble(this, value, offset, true, noAssert);
      };
      Buffer3.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
        return writeDouble(this, value, offset, false, noAssert);
      };
      Buffer3.prototype.copy = function copy2(target, targetStart, start, end) {
        if (!Buffer3.isBuffer(target))
          throw new TypeError("argument should be a Buffer");
        if (!start)
          start = 0;
        if (!end && end !== 0)
          end = this.length;
        if (targetStart >= target.length)
          targetStart = target.length;
        if (!targetStart)
          targetStart = 0;
        if (end > 0 && end < start)
          end = start;
        if (end === start)
          return 0;
        if (target.length === 0 || this.length === 0)
          return 0;
        if (targetStart < 0) {
          throw new RangeError("targetStart out of bounds");
        }
        if (start < 0 || start >= this.length)
          throw new RangeError("Index out of range");
        if (end < 0)
          throw new RangeError("sourceEnd out of bounds");
        if (end > this.length)
          end = this.length;
        if (target.length - targetStart < end - start) {
          end = target.length - targetStart + start;
        }
        const len = end - start;
        if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
          this.copyWithin(targetStart, start, end);
        } else {
          Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
        }
        return len;
      };
      Buffer3.prototype.fill = function fill(val, start, end, encoding) {
        if (typeof val === "string") {
          if (typeof start === "string") {
            encoding = start;
            start = 0;
            end = this.length;
          } else if (typeof end === "string") {
            encoding = end;
            end = this.length;
          }
          if (encoding !== void 0 && typeof encoding !== "string") {
            throw new TypeError("encoding must be a string");
          }
          if (typeof encoding === "string" && !Buffer3.isEncoding(encoding)) {
            throw new TypeError("Unknown encoding: " + encoding);
          }
          if (val.length === 1) {
            const code = val.charCodeAt(0);
            if (encoding === "utf8" && code < 128 || encoding === "latin1") {
              val = code;
            }
          }
        } else if (typeof val === "number") {
          val = val & 255;
        } else if (typeof val === "boolean") {
          val = Number(val);
        }
        if (start < 0 || this.length < start || this.length < end) {
          throw new RangeError("Out of range index");
        }
        if (end <= start) {
          return this;
        }
        start = start >>> 0;
        end = end === void 0 ? this.length : end >>> 0;
        if (!val)
          val = 0;
        let i;
        if (typeof val === "number") {
          for (i = start; i < end; ++i) {
            this[i] = val;
          }
        } else {
          const bytes = Buffer3.isBuffer(val) ? val : Buffer3.from(val, encoding);
          const len = bytes.length;
          if (len === 0) {
            throw new TypeError('The value "' + val + '" is invalid for argument "value"');
          }
          for (i = 0; i < end - start; ++i) {
            this[i + start] = bytes[i % len];
          }
        }
        return this;
      };
      var errors = {};
      function E(sym, getMessage, Base) {
        errors[sym] = class NodeError extends Base {
          constructor() {
            super();
            Object.defineProperty(this, "message", {
              value: getMessage.apply(this, arguments),
              writable: true,
              configurable: true
            });
            this.name = `${this.name} [${sym}]`;
            this.stack;
            delete this.name;
          }
          get code() {
            return sym;
          }
          set code(value) {
            Object.defineProperty(this, "code", {
              configurable: true,
              enumerable: true,
              value,
              writable: true
            });
          }
          toString() {
            return `${this.name} [${sym}]: ${this.message}`;
          }
        };
      }
      E("ERR_BUFFER_OUT_OF_BOUNDS", function(name) {
        if (name) {
          return `${name} is outside of buffer bounds`;
        }
        return "Attempt to access memory outside buffer bounds";
      }, RangeError);
      E("ERR_INVALID_ARG_TYPE", function(name, actual) {
        return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
      }, TypeError);
      E("ERR_OUT_OF_RANGE", function(str, range, input) {
        let msg = `The value of "${str}" is out of range.`;
        let received = input;
        if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
          received = addNumericalSeparator(String(input));
        } else if (typeof input === "bigint") {
          received = String(input);
          if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
            received = addNumericalSeparator(received);
          }
          received += "n";
        }
        msg += ` It must be ${range}. Received ${received}`;
        return msg;
      }, RangeError);
      function addNumericalSeparator(val) {
        let res = "";
        let i = val.length;
        const start = val[0] === "-" ? 1 : 0;
        for (; i >= start + 4; i -= 3) {
          res = `_${val.slice(i - 3, i)}${res}`;
        }
        return `${val.slice(0, i)}${res}`;
      }
      function checkBounds(buf, offset, byteLength2) {
        validateNumber(offset, "offset");
        if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
          boundsError(offset, buf.length - (byteLength2 + 1));
        }
      }
      function checkIntBI(value, min, max, buf, offset, byteLength2) {
        if (value > max || value < min) {
          const n = typeof min === "bigint" ? "n" : "";
          let range;
          if (byteLength2 > 3) {
            if (min === 0 || min === BigInt(0)) {
              range = `>= 0${n} and < 2${n} ** ${(byteLength2 + 1) * 8}${n}`;
            } else {
              range = `>= -(2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n}`;
            }
          } else {
            range = `>= ${min}${n} and <= ${max}${n}`;
          }
          throw new errors.ERR_OUT_OF_RANGE("value", range, value);
        }
        checkBounds(buf, offset, byteLength2);
      }
      function validateNumber(value, name) {
        if (typeof value !== "number") {
          throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
        }
      }
      function boundsError(value, length, type) {
        if (Math.floor(value) !== value) {
          validateNumber(value, type);
          throw new errors.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
        }
        if (length < 0) {
          throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
        }
        throw new errors.ERR_OUT_OF_RANGE(type || "offset", `>= ${type ? 1 : 0} and <= ${length}`, value);
      }
      var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
      function base64clean(str) {
        str = str.split("=")[0];
        str = str.trim().replace(INVALID_BASE64_RE, "");
        if (str.length < 2)
          return "";
        while (str.length % 4 !== 0) {
          str = str + "=";
        }
        return str;
      }
      function utf8ToBytes(string, units) {
        units = units || Infinity;
        let codePoint;
        const length = string.length;
        let leadSurrogate = null;
        const bytes = [];
        for (let i = 0; i < length; ++i) {
          codePoint = string.charCodeAt(i);
          if (codePoint > 55295 && codePoint < 57344) {
            if (!leadSurrogate) {
              if (codePoint > 56319) {
                if ((units -= 3) > -1)
                  bytes.push(239, 191, 189);
                continue;
              } else if (i + 1 === length) {
                if ((units -= 3) > -1)
                  bytes.push(239, 191, 189);
                continue;
              }
              leadSurrogate = codePoint;
              continue;
            }
            if (codePoint < 56320) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              leadSurrogate = codePoint;
              continue;
            }
            codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
          } else if (leadSurrogate) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
          }
          leadSurrogate = null;
          if (codePoint < 128) {
            if ((units -= 1) < 0)
              break;
            bytes.push(codePoint);
          } else if (codePoint < 2048) {
            if ((units -= 2) < 0)
              break;
            bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
          } else if (codePoint < 65536) {
            if ((units -= 3) < 0)
              break;
            bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
          } else if (codePoint < 1114112) {
            if ((units -= 4) < 0)
              break;
            bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
          } else {
            throw new Error("Invalid code point");
          }
        }
        return bytes;
      }
      function asciiToBytes(str) {
        const byteArray = [];
        for (let i = 0; i < str.length; ++i) {
          byteArray.push(str.charCodeAt(i) & 255);
        }
        return byteArray;
      }
      function utf16leToBytes(str, units) {
        let c, hi, lo;
        const byteArray = [];
        for (let i = 0; i < str.length; ++i) {
          if ((units -= 2) < 0)
            break;
          c = str.charCodeAt(i);
          hi = c >> 8;
          lo = c % 256;
          byteArray.push(lo);
          byteArray.push(hi);
        }
        return byteArray;
      }
      function base64ToBytes(str) {
        return base64.toByteArray(base64clean(str));
      }
      function blitBuffer(src, dst, offset, length) {
        let i;
        for (i = 0; i < length; ++i) {
          if (i + offset >= dst.length || i >= src.length)
            break;
          dst[i + offset] = src[i];
        }
        return i;
      }
      function isInstance(obj, type) {
        return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
      }
      function numberIsNaN(obj) {
        return obj !== obj;
      }
      var hexSliceLookupTable = function() {
        const alphabet = "0123456789abcdef";
        const table = new Array(256);
        for (let i = 0; i < 16; ++i) {
          const i16 = i * 16;
          for (let j = 0; j < 16; ++j) {
            table[i16 + j] = alphabet[i] + alphabet[j];
          }
        }
        return table;
      }();
      function defineBigIntMethod(fn) {
        return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
      }
      function BufferBigIntNotDefined() {
        throw new Error("BigInt not supported");
      }
    }
  });

  // node_modules/redstone-isomorphic/npm-browser.js
  var require_npm_browser = __commonJS({
    "node_modules/redstone-isomorphic/npm-browser.js"(exports, module2) {
      window.global = window;
      global.fetch = window.fetch;
      module2.exports.Buffer = require_buffer().Buffer;
    }
  });

  // node_modules/has-symbols/shams.js
  var require_shams = __commonJS({
    "node_modules/has-symbols/shams.js"(exports, module2) {
      "use strict";
      module2.exports = function hasSymbols() {
        if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
          return false;
        }
        if (typeof Symbol.iterator === "symbol") {
          return true;
        }
        var obj = {};
        var sym = Symbol("test");
        var symObj = Object(sym);
        if (typeof sym === "string") {
          return false;
        }
        if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
          return false;
        }
        if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
          return false;
        }
        var symVal = 42;
        obj[sym] = symVal;
        for (sym in obj) {
          return false;
        }
        if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
          return false;
        }
        if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
          return false;
        }
        var syms = Object.getOwnPropertySymbols(obj);
        if (syms.length !== 1 || syms[0] !== sym) {
          return false;
        }
        if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
          return false;
        }
        if (typeof Object.getOwnPropertyDescriptor === "function") {
          var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
          if (descriptor.value !== symVal || descriptor.enumerable !== true) {
            return false;
          }
        }
        return true;
      };
    }
  });

  // node_modules/has-tostringtag/shams.js
  var require_shams2 = __commonJS({
    "node_modules/has-tostringtag/shams.js"(exports, module2) {
      "use strict";
      var hasSymbols = require_shams();
      module2.exports = function hasToStringTagShams() {
        return hasSymbols() && !!Symbol.toStringTag;
      };
    }
  });

  // node_modules/has-symbols/index.js
  var require_has_symbols = __commonJS({
    "node_modules/has-symbols/index.js"(exports, module2) {
      "use strict";
      var origSymbol = typeof Symbol !== "undefined" && Symbol;
      var hasSymbolSham = require_shams();
      module2.exports = function hasNativeSymbols() {
        if (typeof origSymbol !== "function") {
          return false;
        }
        if (typeof Symbol !== "function") {
          return false;
        }
        if (typeof origSymbol("foo") !== "symbol") {
          return false;
        }
        if (typeof Symbol("bar") !== "symbol") {
          return false;
        }
        return hasSymbolSham();
      };
    }
  });

  // node_modules/function-bind/implementation.js
  var require_implementation = __commonJS({
    "node_modules/function-bind/implementation.js"(exports, module2) {
      "use strict";
      var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
      var slice = Array.prototype.slice;
      var toStr = Object.prototype.toString;
      var funcType = "[object Function]";
      module2.exports = function bind(that) {
        var target = this;
        if (typeof target !== "function" || toStr.call(target) !== funcType) {
          throw new TypeError(ERROR_MESSAGE + target);
        }
        var args = slice.call(arguments, 1);
        var bound;
        var binder = function() {
          if (this instanceof bound) {
            var result = target.apply(this, args.concat(slice.call(arguments)));
            if (Object(result) === result) {
              return result;
            }
            return this;
          } else {
            return target.apply(that, args.concat(slice.call(arguments)));
          }
        };
        var boundLength = Math.max(0, target.length - args.length);
        var boundArgs = [];
        for (var i = 0; i < boundLength; i++) {
          boundArgs.push("$" + i);
        }
        bound = Function("binder", "return function (" + boundArgs.join(",") + "){ return binder.apply(this,arguments); }")(binder);
        if (target.prototype) {
          var Empty = function Empty2() {
          };
          Empty.prototype = target.prototype;
          bound.prototype = new Empty();
          Empty.prototype = null;
        }
        return bound;
      };
    }
  });

  // node_modules/function-bind/index.js
  var require_function_bind = __commonJS({
    "node_modules/function-bind/index.js"(exports, module2) {
      "use strict";
      var implementation = require_implementation();
      module2.exports = Function.prototype.bind || implementation;
    }
  });

  // node_modules/has/src/index.js
  var require_src = __commonJS({
    "node_modules/has/src/index.js"(exports, module2) {
      "use strict";
      var bind = require_function_bind();
      module2.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);
    }
  });

  // node_modules/get-intrinsic/index.js
  var require_get_intrinsic = __commonJS({
    "node_modules/get-intrinsic/index.js"(exports, module2) {
      "use strict";
      var undefined2;
      var $SyntaxError = SyntaxError;
      var $Function = Function;
      var $TypeError = TypeError;
      var getEvalledConstructor = function(expressionSyntax) {
        try {
          return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
        } catch (e) {
        }
      };
      var $gOPD = Object.getOwnPropertyDescriptor;
      if ($gOPD) {
        try {
          $gOPD({}, "");
        } catch (e) {
          $gOPD = null;
        }
      }
      var throwTypeError = function() {
        throw new $TypeError();
      };
      var ThrowTypeError = $gOPD ? function() {
        try {
          arguments.callee;
          return throwTypeError;
        } catch (calleeThrows) {
          try {
            return $gOPD(arguments, "callee").get;
          } catch (gOPDthrows) {
            return throwTypeError;
          }
        }
      }() : throwTypeError;
      var hasSymbols = require_has_symbols()();
      var getProto = Object.getPrototypeOf || function(x) {
        return x.__proto__;
      };
      var needsEval = {};
      var TypedArray = typeof Uint8Array === "undefined" ? undefined2 : getProto(Uint8Array);
      var INTRINSICS = {
        "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
        "%Array%": Array,
        "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
        "%ArrayIteratorPrototype%": hasSymbols ? getProto([][Symbol.iterator]()) : undefined2,
        "%AsyncFromSyncIteratorPrototype%": undefined2,
        "%AsyncFunction%": needsEval,
        "%AsyncGenerator%": needsEval,
        "%AsyncGeneratorFunction%": needsEval,
        "%AsyncIteratorPrototype%": needsEval,
        "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
        "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
        "%Boolean%": Boolean,
        "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
        "%Date%": Date,
        "%decodeURI%": decodeURI,
        "%decodeURIComponent%": decodeURIComponent,
        "%encodeURI%": encodeURI,
        "%encodeURIComponent%": encodeURIComponent,
        "%Error%": Error,
        "%eval%": eval,
        "%EvalError%": EvalError,
        "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
        "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
        "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
        "%Function%": $Function,
        "%GeneratorFunction%": needsEval,
        "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
        "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
        "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
        "%isFinite%": isFinite,
        "%isNaN%": isNaN,
        "%IteratorPrototype%": hasSymbols ? getProto(getProto([][Symbol.iterator]())) : undefined2,
        "%JSON%": typeof JSON === "object" ? JSON : undefined2,
        "%Map%": typeof Map === "undefined" ? undefined2 : Map,
        "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols ? undefined2 : getProto(new Map()[Symbol.iterator]()),
        "%Math%": Math,
        "%Number%": Number,
        "%Object%": Object,
        "%parseFloat%": parseFloat,
        "%parseInt%": parseInt,
        "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
        "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
        "%RangeError%": RangeError,
        "%ReferenceError%": ReferenceError,
        "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
        "%RegExp%": RegExp,
        "%Set%": typeof Set === "undefined" ? undefined2 : Set,
        "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols ? undefined2 : getProto(new Set()[Symbol.iterator]()),
        "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
        "%String%": String,
        "%StringIteratorPrototype%": hasSymbols ? getProto(""[Symbol.iterator]()) : undefined2,
        "%Symbol%": hasSymbols ? Symbol : undefined2,
        "%SyntaxError%": $SyntaxError,
        "%ThrowTypeError%": ThrowTypeError,
        "%TypedArray%": TypedArray,
        "%TypeError%": $TypeError,
        "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
        "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
        "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
        "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
        "%URIError%": URIError,
        "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
        "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
        "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet
      };
      var doEval = function doEval2(name) {
        var value;
        if (name === "%AsyncFunction%") {
          value = getEvalledConstructor("async function () {}");
        } else if (name === "%GeneratorFunction%") {
          value = getEvalledConstructor("function* () {}");
        } else if (name === "%AsyncGeneratorFunction%") {
          value = getEvalledConstructor("async function* () {}");
        } else if (name === "%AsyncGenerator%") {
          var fn = doEval2("%AsyncGeneratorFunction%");
          if (fn) {
            value = fn.prototype;
          }
        } else if (name === "%AsyncIteratorPrototype%") {
          var gen = doEval2("%AsyncGenerator%");
          if (gen) {
            value = getProto(gen.prototype);
          }
        }
        INTRINSICS[name] = value;
        return value;
      };
      var LEGACY_ALIASES = {
        "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
        "%ArrayPrototype%": ["Array", "prototype"],
        "%ArrayProto_entries%": ["Array", "prototype", "entries"],
        "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
        "%ArrayProto_keys%": ["Array", "prototype", "keys"],
        "%ArrayProto_values%": ["Array", "prototype", "values"],
        "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
        "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
        "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
        "%BooleanPrototype%": ["Boolean", "prototype"],
        "%DataViewPrototype%": ["DataView", "prototype"],
        "%DatePrototype%": ["Date", "prototype"],
        "%ErrorPrototype%": ["Error", "prototype"],
        "%EvalErrorPrototype%": ["EvalError", "prototype"],
        "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
        "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
        "%FunctionPrototype%": ["Function", "prototype"],
        "%Generator%": ["GeneratorFunction", "prototype"],
        "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
        "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
        "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
        "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
        "%JSONParse%": ["JSON", "parse"],
        "%JSONStringify%": ["JSON", "stringify"],
        "%MapPrototype%": ["Map", "prototype"],
        "%NumberPrototype%": ["Number", "prototype"],
        "%ObjectPrototype%": ["Object", "prototype"],
        "%ObjProto_toString%": ["Object", "prototype", "toString"],
        "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
        "%PromisePrototype%": ["Promise", "prototype"],
        "%PromiseProto_then%": ["Promise", "prototype", "then"],
        "%Promise_all%": ["Promise", "all"],
        "%Promise_reject%": ["Promise", "reject"],
        "%Promise_resolve%": ["Promise", "resolve"],
        "%RangeErrorPrototype%": ["RangeError", "prototype"],
        "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
        "%RegExpPrototype%": ["RegExp", "prototype"],
        "%SetPrototype%": ["Set", "prototype"],
        "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
        "%StringPrototype%": ["String", "prototype"],
        "%SymbolPrototype%": ["Symbol", "prototype"],
        "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
        "%TypedArrayPrototype%": ["TypedArray", "prototype"],
        "%TypeErrorPrototype%": ["TypeError", "prototype"],
        "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
        "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
        "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
        "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
        "%URIErrorPrototype%": ["URIError", "prototype"],
        "%WeakMapPrototype%": ["WeakMap", "prototype"],
        "%WeakSetPrototype%": ["WeakSet", "prototype"]
      };
      var bind = require_function_bind();
      var hasOwn = require_src();
      var $concat = bind.call(Function.call, Array.prototype.concat);
      var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
      var $replace = bind.call(Function.call, String.prototype.replace);
      var $strSlice = bind.call(Function.call, String.prototype.slice);
      var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
      var reEscapeChar = /\\(\\)?/g;
      var stringToPath = function stringToPath2(string) {
        var first = $strSlice(string, 0, 1);
        var last = $strSlice(string, -1);
        if (first === "%" && last !== "%") {
          throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
        } else if (last === "%" && first !== "%") {
          throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
        }
        var result = [];
        $replace(string, rePropName, function(match, number, quote, subString) {
          result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
        });
        return result;
      };
      var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
        var intrinsicName = name;
        var alias;
        if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
          alias = LEGACY_ALIASES[intrinsicName];
          intrinsicName = "%" + alias[0] + "%";
        }
        if (hasOwn(INTRINSICS, intrinsicName)) {
          var value = INTRINSICS[intrinsicName];
          if (value === needsEval) {
            value = doEval(intrinsicName);
          }
          if (typeof value === "undefined" && !allowMissing) {
            throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
          }
          return {
            alias,
            name: intrinsicName,
            value
          };
        }
        throw new $SyntaxError("intrinsic " + name + " does not exist!");
      };
      module2.exports = function GetIntrinsic(name, allowMissing) {
        if (typeof name !== "string" || name.length === 0) {
          throw new $TypeError("intrinsic name must be a non-empty string");
        }
        if (arguments.length > 1 && typeof allowMissing !== "boolean") {
          throw new $TypeError('"allowMissing" argument must be a boolean');
        }
        var parts = stringToPath(name);
        var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
        var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
        var intrinsicRealName = intrinsic.name;
        var value = intrinsic.value;
        var skipFurtherCaching = false;
        var alias = intrinsic.alias;
        if (alias) {
          intrinsicBaseName = alias[0];
          $spliceApply(parts, $concat([0, 1], alias));
        }
        for (var i = 1, isOwn = true; i < parts.length; i += 1) {
          var part = parts[i];
          var first = $strSlice(part, 0, 1);
          var last = $strSlice(part, -1);
          if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
            throw new $SyntaxError("property names with quotes must have matching quotes");
          }
          if (part === "constructor" || !isOwn) {
            skipFurtherCaching = true;
          }
          intrinsicBaseName += "." + part;
          intrinsicRealName = "%" + intrinsicBaseName + "%";
          if (hasOwn(INTRINSICS, intrinsicRealName)) {
            value = INTRINSICS[intrinsicRealName];
          } else if (value != null) {
            if (!(part in value)) {
              if (!allowMissing) {
                throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
              }
              return void 0;
            }
            if ($gOPD && i + 1 >= parts.length) {
              var desc2 = $gOPD(value, part);
              isOwn = !!desc2;
              if (isOwn && "get" in desc2 && !("originalValue" in desc2.get)) {
                value = desc2.get;
              } else {
                value = value[part];
              }
            } else {
              isOwn = hasOwn(value, part);
              value = value[part];
            }
            if (isOwn && !skipFurtherCaching) {
              INTRINSICS[intrinsicRealName] = value;
            }
          }
        }
        return value;
      };
    }
  });

  // node_modules/call-bind/index.js
  var require_call_bind = __commonJS({
    "node_modules/call-bind/index.js"(exports, module2) {
      "use strict";
      var bind = require_function_bind();
      var GetIntrinsic = require_get_intrinsic();
      var $apply = GetIntrinsic("%Function.prototype.apply%");
      var $call = GetIntrinsic("%Function.prototype.call%");
      var $reflectApply = GetIntrinsic("%Reflect.apply%", true) || bind.call($call, $apply);
      var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
      var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
      var $max = GetIntrinsic("%Math.max%");
      if ($defineProperty) {
        try {
          $defineProperty({}, "a", { value: 1 });
        } catch (e) {
          $defineProperty = null;
        }
      }
      module2.exports = function callBind(originalFunction) {
        var func = $reflectApply(bind, $call, arguments);
        if ($gOPD && $defineProperty) {
          var desc2 = $gOPD(func, "length");
          if (desc2.configurable) {
            $defineProperty(func, "length", { value: 1 + $max(0, originalFunction.length - (arguments.length - 1)) });
          }
        }
        return func;
      };
      var applyBind = function applyBind2() {
        return $reflectApply(bind, $apply, arguments);
      };
      if ($defineProperty) {
        $defineProperty(module2.exports, "apply", { value: applyBind });
      } else {
        module2.exports.apply = applyBind;
      }
    }
  });

  // node_modules/call-bind/callBound.js
  var require_callBound = __commonJS({
    "node_modules/call-bind/callBound.js"(exports, module2) {
      "use strict";
      var GetIntrinsic = require_get_intrinsic();
      var callBind = require_call_bind();
      var $indexOf = callBind(GetIntrinsic("String.prototype.indexOf"));
      module2.exports = function callBoundIntrinsic(name, allowMissing) {
        var intrinsic = GetIntrinsic(name, !!allowMissing);
        if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
          return callBind(intrinsic);
        }
        return intrinsic;
      };
    }
  });

  // node_modules/is-arguments/index.js
  var require_is_arguments = __commonJS({
    "node_modules/is-arguments/index.js"(exports, module2) {
      "use strict";
      var hasToStringTag = require_shams2()();
      var callBound = require_callBound();
      var $toString = callBound("Object.prototype.toString");
      var isStandardArguments = function isArguments(value) {
        if (hasToStringTag && value && typeof value === "object" && Symbol.toStringTag in value) {
          return false;
        }
        return $toString(value) === "[object Arguments]";
      };
      var isLegacyArguments = function isArguments(value) {
        if (isStandardArguments(value)) {
          return true;
        }
        return value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && $toString(value) !== "[object Array]" && $toString(value.callee) === "[object Function]";
      };
      var supportsStandardArguments = function() {
        return isStandardArguments(arguments);
      }();
      isStandardArguments.isLegacyArguments = isLegacyArguments;
      module2.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;
    }
  });

  // node_modules/is-generator-function/index.js
  var require_is_generator_function = __commonJS({
    "node_modules/is-generator-function/index.js"(exports, module2) {
      "use strict";
      var toStr = Object.prototype.toString;
      var fnToStr = Function.prototype.toString;
      var isFnRegex = /^\s*(?:function)?\*/;
      var hasToStringTag = require_shams2()();
      var getProto = Object.getPrototypeOf;
      var getGeneratorFunc = function() {
        if (!hasToStringTag) {
          return false;
        }
        try {
          return Function("return function*() {}")();
        } catch (e) {
        }
      };
      var GeneratorFunction;
      module2.exports = function isGeneratorFunction(fn) {
        if (typeof fn !== "function") {
          return false;
        }
        if (isFnRegex.test(fnToStr.call(fn))) {
          return true;
        }
        if (!hasToStringTag) {
          var str = toStr.call(fn);
          return str === "[object GeneratorFunction]";
        }
        if (!getProto) {
          return false;
        }
        if (typeof GeneratorFunction === "undefined") {
          var generatorFunc = getGeneratorFunc();
          GeneratorFunction = generatorFunc ? getProto(generatorFunc) : false;
        }
        return getProto(fn) === GeneratorFunction;
      };
    }
  });

  // node_modules/foreach/index.js
  var require_foreach = __commonJS({
    "node_modules/foreach/index.js"(exports, module2) {
      var hasOwn = Object.prototype.hasOwnProperty;
      var toString2 = Object.prototype.toString;
      module2.exports = function forEach(obj, fn, ctx) {
        if (toString2.call(fn) !== "[object Function]") {
          throw new TypeError("iterator must be a function");
        }
        var l = obj.length;
        if (l === +l) {
          for (var i = 0; i < l; i++) {
            fn.call(ctx, obj[i], i, obj);
          }
        } else {
          for (var k in obj) {
            if (hasOwn.call(obj, k)) {
              fn.call(ctx, obj[k], k, obj);
            }
          }
        }
      };
    }
  });

  // node_modules/available-typed-arrays/index.js
  var require_available_typed_arrays = __commonJS({
    "node_modules/available-typed-arrays/index.js"(exports, module2) {
      "use strict";
      var possibleNames = [
        "BigInt64Array",
        "BigUint64Array",
        "Float32Array",
        "Float64Array",
        "Int16Array",
        "Int32Array",
        "Int8Array",
        "Uint16Array",
        "Uint32Array",
        "Uint8Array",
        "Uint8ClampedArray"
      ];
      var g = typeof globalThis === "undefined" ? global : globalThis;
      module2.exports = function availableTypedArrays() {
        var out = [];
        for (var i = 0; i < possibleNames.length; i++) {
          if (typeof g[possibleNames[i]] === "function") {
            out[out.length] = possibleNames[i];
          }
        }
        return out;
      };
    }
  });

  // node_modules/es-abstract/helpers/getOwnPropertyDescriptor.js
  var require_getOwnPropertyDescriptor = __commonJS({
    "node_modules/es-abstract/helpers/getOwnPropertyDescriptor.js"(exports, module2) {
      "use strict";
      var GetIntrinsic = require_get_intrinsic();
      var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
      if ($gOPD) {
        try {
          $gOPD([], "length");
        } catch (e) {
          $gOPD = null;
        }
      }
      module2.exports = $gOPD;
    }
  });

  // node_modules/is-typed-array/index.js
  var require_is_typed_array = __commonJS({
    "node_modules/is-typed-array/index.js"(exports, module2) {
      "use strict";
      var forEach = require_foreach();
      var availableTypedArrays = require_available_typed_arrays();
      var callBound = require_callBound();
      var $toString = callBound("Object.prototype.toString");
      var hasToStringTag = require_shams2()();
      var g = typeof globalThis === "undefined" ? global : globalThis;
      var typedArrays = availableTypedArrays();
      var $indexOf = callBound("Array.prototype.indexOf", true) || function indexOf(array, value) {
        for (var i = 0; i < array.length; i += 1) {
          if (array[i] === value) {
            return i;
          }
        }
        return -1;
      };
      var $slice = callBound("String.prototype.slice");
      var toStrTags = {};
      var gOPD = require_getOwnPropertyDescriptor();
      var getPrototypeOf = Object.getPrototypeOf;
      if (hasToStringTag && gOPD && getPrototypeOf) {
        forEach(typedArrays, function(typedArray) {
          var arr = new g[typedArray]();
          if (Symbol.toStringTag in arr) {
            var proto = getPrototypeOf(arr);
            var descriptor = gOPD(proto, Symbol.toStringTag);
            if (!descriptor) {
              var superProto = getPrototypeOf(proto);
              descriptor = gOPD(superProto, Symbol.toStringTag);
            }
            toStrTags[typedArray] = descriptor.get;
          }
        });
      }
      var tryTypedArrays = function tryAllTypedArrays(value) {
        var anyTrue = false;
        forEach(toStrTags, function(getter, typedArray) {
          if (!anyTrue) {
            try {
              anyTrue = getter.call(value) === typedArray;
            } catch (e) {
            }
          }
        });
        return anyTrue;
      };
      module2.exports = function isTypedArray(value) {
        if (!value || typeof value !== "object") {
          return false;
        }
        if (!hasToStringTag || !(Symbol.toStringTag in value)) {
          var tag = $slice($toString(value), 8, -1);
          return $indexOf(typedArrays, tag) > -1;
        }
        if (!gOPD) {
          return false;
        }
        return tryTypedArrays(value);
      };
    }
  });

  // node_modules/which-typed-array/index.js
  var require_which_typed_array = __commonJS({
    "node_modules/which-typed-array/index.js"(exports, module2) {
      "use strict";
      var forEach = require_foreach();
      var availableTypedArrays = require_available_typed_arrays();
      var callBound = require_callBound();
      var $toString = callBound("Object.prototype.toString");
      var hasToStringTag = require_shams2()();
      var g = typeof globalThis === "undefined" ? global : globalThis;
      var typedArrays = availableTypedArrays();
      var $slice = callBound("String.prototype.slice");
      var toStrTags = {};
      var gOPD = require_getOwnPropertyDescriptor();
      var getPrototypeOf = Object.getPrototypeOf;
      if (hasToStringTag && gOPD && getPrototypeOf) {
        forEach(typedArrays, function(typedArray) {
          if (typeof g[typedArray] === "function") {
            var arr = new g[typedArray]();
            if (Symbol.toStringTag in arr) {
              var proto = getPrototypeOf(arr);
              var descriptor = gOPD(proto, Symbol.toStringTag);
              if (!descriptor) {
                var superProto = getPrototypeOf(proto);
                descriptor = gOPD(superProto, Symbol.toStringTag);
              }
              toStrTags[typedArray] = descriptor.get;
            }
          }
        });
      }
      var tryTypedArrays = function tryAllTypedArrays(value) {
        var foundName = false;
        forEach(toStrTags, function(getter, typedArray) {
          if (!foundName) {
            try {
              var name = getter.call(value);
              if (name === typedArray) {
                foundName = name;
              }
            } catch (e) {
            }
          }
        });
        return foundName;
      };
      var isTypedArray = require_is_typed_array();
      module2.exports = function whichTypedArray(value) {
        if (!isTypedArray(value)) {
          return false;
        }
        if (!hasToStringTag || !(Symbol.toStringTag in value)) {
          return $slice($toString(value), 8, -1);
        }
        return tryTypedArrays(value);
      };
    }
  });

  // node_modules/util/support/types.js
  var require_types = __commonJS({
    "node_modules/util/support/types.js"(exports) {
      "use strict";
      var isArgumentsObject = require_is_arguments();
      var isGeneratorFunction = require_is_generator_function();
      var whichTypedArray = require_which_typed_array();
      var isTypedArray = require_is_typed_array();
      function uncurryThis(f) {
        return f.call.bind(f);
      }
      var BigIntSupported = typeof BigInt !== "undefined";
      var SymbolSupported = typeof Symbol !== "undefined";
      var ObjectToString = uncurryThis(Object.prototype.toString);
      var numberValue = uncurryThis(Number.prototype.valueOf);
      var stringValue = uncurryThis(String.prototype.valueOf);
      var booleanValue = uncurryThis(Boolean.prototype.valueOf);
      if (BigIntSupported) {
        bigIntValue = uncurryThis(BigInt.prototype.valueOf);
      }
      var bigIntValue;
      if (SymbolSupported) {
        symbolValue = uncurryThis(Symbol.prototype.valueOf);
      }
      var symbolValue;
      function checkBoxedPrimitive(value, prototypeValueOf) {
        if (typeof value !== "object") {
          return false;
        }
        try {
          prototypeValueOf(value);
          return true;
        } catch (e) {
          return false;
        }
      }
      exports.isArgumentsObject = isArgumentsObject;
      exports.isGeneratorFunction = isGeneratorFunction;
      exports.isTypedArray = isTypedArray;
      function isPromise(input) {
        return typeof Promise !== "undefined" && input instanceof Promise || input !== null && typeof input === "object" && typeof input.then === "function" && typeof input.catch === "function";
      }
      exports.isPromise = isPromise;
      function isArrayBufferView(value) {
        if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
          return ArrayBuffer.isView(value);
        }
        return isTypedArray(value) || isDataView(value);
      }
      exports.isArrayBufferView = isArrayBufferView;
      function isUint8Array(value) {
        return whichTypedArray(value) === "Uint8Array";
      }
      exports.isUint8Array = isUint8Array;
      function isUint8ClampedArray(value) {
        return whichTypedArray(value) === "Uint8ClampedArray";
      }
      exports.isUint8ClampedArray = isUint8ClampedArray;
      function isUint16Array(value) {
        return whichTypedArray(value) === "Uint16Array";
      }
      exports.isUint16Array = isUint16Array;
      function isUint32Array(value) {
        return whichTypedArray(value) === "Uint32Array";
      }
      exports.isUint32Array = isUint32Array;
      function isInt8Array(value) {
        return whichTypedArray(value) === "Int8Array";
      }
      exports.isInt8Array = isInt8Array;
      function isInt16Array(value) {
        return whichTypedArray(value) === "Int16Array";
      }
      exports.isInt16Array = isInt16Array;
      function isInt32Array(value) {
        return whichTypedArray(value) === "Int32Array";
      }
      exports.isInt32Array = isInt32Array;
      function isFloat32Array(value) {
        return whichTypedArray(value) === "Float32Array";
      }
      exports.isFloat32Array = isFloat32Array;
      function isFloat64Array(value) {
        return whichTypedArray(value) === "Float64Array";
      }
      exports.isFloat64Array = isFloat64Array;
      function isBigInt64Array(value) {
        return whichTypedArray(value) === "BigInt64Array";
      }
      exports.isBigInt64Array = isBigInt64Array;
      function isBigUint64Array(value) {
        return whichTypedArray(value) === "BigUint64Array";
      }
      exports.isBigUint64Array = isBigUint64Array;
      function isMapToString(value) {
        return ObjectToString(value) === "[object Map]";
      }
      isMapToString.working = typeof Map !== "undefined" && isMapToString(new Map());
      function isMap(value) {
        if (typeof Map === "undefined") {
          return false;
        }
        return isMapToString.working ? isMapToString(value) : value instanceof Map;
      }
      exports.isMap = isMap;
      function isSetToString(value) {
        return ObjectToString(value) === "[object Set]";
      }
      isSetToString.working = typeof Set !== "undefined" && isSetToString(new Set());
      function isSet(value) {
        if (typeof Set === "undefined") {
          return false;
        }
        return isSetToString.working ? isSetToString(value) : value instanceof Set;
      }
      exports.isSet = isSet;
      function isWeakMapToString(value) {
        return ObjectToString(value) === "[object WeakMap]";
      }
      isWeakMapToString.working = typeof WeakMap !== "undefined" && isWeakMapToString(new WeakMap());
      function isWeakMap(value) {
        if (typeof WeakMap === "undefined") {
          return false;
        }
        return isWeakMapToString.working ? isWeakMapToString(value) : value instanceof WeakMap;
      }
      exports.isWeakMap = isWeakMap;
      function isWeakSetToString(value) {
        return ObjectToString(value) === "[object WeakSet]";
      }
      isWeakSetToString.working = typeof WeakSet !== "undefined" && isWeakSetToString(new WeakSet());
      function isWeakSet(value) {
        return isWeakSetToString(value);
      }
      exports.isWeakSet = isWeakSet;
      function isArrayBufferToString(value) {
        return ObjectToString(value) === "[object ArrayBuffer]";
      }
      isArrayBufferToString.working = typeof ArrayBuffer !== "undefined" && isArrayBufferToString(new ArrayBuffer());
      function isArrayBuffer(value) {
        if (typeof ArrayBuffer === "undefined") {
          return false;
        }
        return isArrayBufferToString.working ? isArrayBufferToString(value) : value instanceof ArrayBuffer;
      }
      exports.isArrayBuffer = isArrayBuffer;
      function isDataViewToString(value) {
        return ObjectToString(value) === "[object DataView]";
      }
      isDataViewToString.working = typeof ArrayBuffer !== "undefined" && typeof DataView !== "undefined" && isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1));
      function isDataView(value) {
        if (typeof DataView === "undefined") {
          return false;
        }
        return isDataViewToString.working ? isDataViewToString(value) : value instanceof DataView;
      }
      exports.isDataView = isDataView;
      var SharedArrayBufferCopy = typeof SharedArrayBuffer !== "undefined" ? SharedArrayBuffer : void 0;
      function isSharedArrayBufferToString(value) {
        return ObjectToString(value) === "[object SharedArrayBuffer]";
      }
      function isSharedArrayBuffer2(value) {
        if (typeof SharedArrayBufferCopy === "undefined") {
          return false;
        }
        if (typeof isSharedArrayBufferToString.working === "undefined") {
          isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());
        }
        return isSharedArrayBufferToString.working ? isSharedArrayBufferToString(value) : value instanceof SharedArrayBufferCopy;
      }
      exports.isSharedArrayBuffer = isSharedArrayBuffer2;
      function isAsyncFunction(value) {
        return ObjectToString(value) === "[object AsyncFunction]";
      }
      exports.isAsyncFunction = isAsyncFunction;
      function isMapIterator(value) {
        return ObjectToString(value) === "[object Map Iterator]";
      }
      exports.isMapIterator = isMapIterator;
      function isSetIterator(value) {
        return ObjectToString(value) === "[object Set Iterator]";
      }
      exports.isSetIterator = isSetIterator;
      function isGeneratorObject(value) {
        return ObjectToString(value) === "[object Generator]";
      }
      exports.isGeneratorObject = isGeneratorObject;
      function isWebAssemblyCompiledModule(value) {
        return ObjectToString(value) === "[object WebAssembly.Module]";
      }
      exports.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;
      function isNumberObject(value) {
        return checkBoxedPrimitive(value, numberValue);
      }
      exports.isNumberObject = isNumberObject;
      function isStringObject(value) {
        return checkBoxedPrimitive(value, stringValue);
      }
      exports.isStringObject = isStringObject;
      function isBooleanObject(value) {
        return checkBoxedPrimitive(value, booleanValue);
      }
      exports.isBooleanObject = isBooleanObject;
      function isBigIntObject(value) {
        return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
      }
      exports.isBigIntObject = isBigIntObject;
      function isSymbolObject(value) {
        return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
      }
      exports.isSymbolObject = isSymbolObject;
      function isBoxedPrimitive(value) {
        return isNumberObject(value) || isStringObject(value) || isBooleanObject(value) || isBigIntObject(value) || isSymbolObject(value);
      }
      exports.isBoxedPrimitive = isBoxedPrimitive;
      function isAnyArrayBuffer(value) {
        return typeof Uint8Array !== "undefined" && (isArrayBuffer(value) || isSharedArrayBuffer2(value));
      }
      exports.isAnyArrayBuffer = isAnyArrayBuffer;
      ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(method) {
        Object.defineProperty(exports, method, {
          enumerable: false,
          value: function() {
            throw new Error(method + " is not supported in userland");
          }
        });
      });
    }
  });

  // node_modules/util/support/isBufferBrowser.js
  var require_isBufferBrowser = __commonJS({
    "node_modules/util/support/isBufferBrowser.js"(exports, module2) {
      module2.exports = function isBuffer(arg) {
        return arg && typeof arg === "object" && typeof arg.copy === "function" && typeof arg.fill === "function" && typeof arg.readUInt8 === "function";
      };
    }
  });

  // node_modules/inherits/inherits_browser.js
  var require_inherits_browser = __commonJS({
    "node_modules/inherits/inherits_browser.js"(exports, module2) {
      if (typeof Object.create === "function") {
        module2.exports = function inherits(ctor, superCtor) {
          if (superCtor) {
            ctor.super_ = superCtor;
            ctor.prototype = Object.create(superCtor.prototype, {
              constructor: {
                value: ctor,
                enumerable: false,
                writable: true,
                configurable: true
              }
            });
          }
        };
      } else {
        module2.exports = function inherits(ctor, superCtor) {
          if (superCtor) {
            ctor.super_ = superCtor;
            var TempCtor = function() {
            };
            TempCtor.prototype = superCtor.prototype;
            ctor.prototype = new TempCtor();
            ctor.prototype.constructor = ctor;
          }
        };
      }
    }
  });

  // node_modules/util/util.js
  var require_util = __commonJS({
    "node_modules/util/util.js"(exports) {
      var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors2(obj) {
        var keys = Object.keys(obj);
        var descriptors = {};
        for (var i = 0; i < keys.length; i++) {
          descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
        }
        return descriptors;
      };
      var formatRegExp = /%[sdj%]/g;
      exports.format = function(f) {
        if (!isString(f)) {
          var objects = [];
          for (var i = 0; i < arguments.length; i++) {
            objects.push(inspect(arguments[i]));
          }
          return objects.join(" ");
        }
        var i = 1;
        var args = arguments;
        var len = args.length;
        var str = String(f).replace(formatRegExp, function(x2) {
          if (x2 === "%%")
            return "%";
          if (i >= len)
            return x2;
          switch (x2) {
            case "%s":
              return String(args[i++]);
            case "%d":
              return Number(args[i++]);
            case "%j":
              try {
                return JSON.stringify(args[i++]);
              } catch (_) {
                return "[Circular]";
              }
            default:
              return x2;
          }
        });
        for (var x = args[i]; i < len; x = args[++i]) {
          if (isNull(x) || !isObject2(x)) {
            str += " " + x;
          } else {
            str += " " + inspect(x);
          }
        }
        return str;
      };
      exports.deprecate = function(fn, msg) {
        if (typeof process !== "undefined" && process.noDeprecation === true) {
          return fn;
        }
        if (typeof process === "undefined") {
          return function() {
            return exports.deprecate(fn, msg).apply(this, arguments);
          };
        }
        var warned = false;
        function deprecated() {
          if (!warned) {
            if (process.throwDeprecation) {
              throw new Error(msg);
            } else if (process.traceDeprecation) {
              console.trace(msg);
            } else {
              console.error(msg);
            }
            warned = true;
          }
          return fn.apply(this, arguments);
        }
        return deprecated;
      };
      var debugs = {};
      var debugEnvRegex = /^$/;
      if (process.env.NODE_DEBUG) {
        debugEnv = process.env.NODE_DEBUG;
        debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase();
        debugEnvRegex = new RegExp("^" + debugEnv + "$", "i");
      }
      var debugEnv;
      exports.debuglog = function(set) {
        set = set.toUpperCase();
        if (!debugs[set]) {
          if (debugEnvRegex.test(set)) {
            var pid = process.pid;
            debugs[set] = function() {
              var msg = exports.format.apply(exports, arguments);
              console.error("%s %d: %s", set, pid, msg);
            };
          } else {
            debugs[set] = function() {
            };
          }
        }
        return debugs[set];
      };
      function inspect(obj, opts) {
        var ctx = {
          seen: [],
          stylize: stylizeNoColor
        };
        if (arguments.length >= 3)
          ctx.depth = arguments[2];
        if (arguments.length >= 4)
          ctx.colors = arguments[3];
        if (isBoolean(opts)) {
          ctx.showHidden = opts;
        } else if (opts) {
          exports._extend(ctx, opts);
        }
        if (isUndefined(ctx.showHidden))
          ctx.showHidden = false;
        if (isUndefined(ctx.depth))
          ctx.depth = 2;
        if (isUndefined(ctx.colors))
          ctx.colors = false;
        if (isUndefined(ctx.customInspect))
          ctx.customInspect = true;
        if (ctx.colors)
          ctx.stylize = stylizeWithColor;
        return formatValue(ctx, obj, ctx.depth);
      }
      exports.inspect = inspect;
      inspect.colors = {
        "bold": [1, 22],
        "italic": [3, 23],
        "underline": [4, 24],
        "inverse": [7, 27],
        "white": [37, 39],
        "grey": [90, 39],
        "black": [30, 39],
        "blue": [34, 39],
        "cyan": [36, 39],
        "green": [32, 39],
        "magenta": [35, 39],
        "red": [31, 39],
        "yellow": [33, 39]
      };
      inspect.styles = {
        "special": "cyan",
        "number": "yellow",
        "boolean": "yellow",
        "undefined": "grey",
        "null": "bold",
        "string": "green",
        "date": "magenta",
        "regexp": "red"
      };
      function stylizeWithColor(str, styleType) {
        var style = inspect.styles[styleType];
        if (style) {
          return "[" + inspect.colors[style][0] + "m" + str + "[" + inspect.colors[style][1] + "m";
        } else {
          return str;
        }
      }
      function stylizeNoColor(str, styleType) {
        return str;
      }
      function arrayToHash(array) {
        var hash = {};
        array.forEach(function(val, idx) {
          hash[val] = true;
        });
        return hash;
      }
      function formatValue(ctx, value, recurseTimes) {
        if (ctx.customInspect && value && isFunction(value.inspect) && value.inspect !== exports.inspect && !(value.constructor && value.constructor.prototype === value)) {
          var ret = value.inspect(recurseTimes, ctx);
          if (!isString(ret)) {
            ret = formatValue(ctx, ret, recurseTimes);
          }
          return ret;
        }
        var primitive = formatPrimitive(ctx, value);
        if (primitive) {
          return primitive;
        }
        var keys = Object.keys(value);
        var visibleKeys = arrayToHash(keys);
        if (ctx.showHidden) {
          keys = Object.getOwnPropertyNames(value);
        }
        if (isError(value) && (keys.indexOf("message") >= 0 || keys.indexOf("description") >= 0)) {
          return formatError(value);
        }
        if (keys.length === 0) {
          if (isFunction(value)) {
            var name = value.name ? ": " + value.name : "";
            return ctx.stylize("[Function" + name + "]", "special");
          }
          if (isRegExp(value)) {
            return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
          }
          if (isDate(value)) {
            return ctx.stylize(Date.prototype.toString.call(value), "date");
          }
          if (isError(value)) {
            return formatError(value);
          }
        }
        var base = "", array = false, braces = ["{", "}"];
        if (isArray(value)) {
          array = true;
          braces = ["[", "]"];
        }
        if (isFunction(value)) {
          var n = value.name ? ": " + value.name : "";
          base = " [Function" + n + "]";
        }
        if (isRegExp(value)) {
          base = " " + RegExp.prototype.toString.call(value);
        }
        if (isDate(value)) {
          base = " " + Date.prototype.toUTCString.call(value);
        }
        if (isError(value)) {
          base = " " + formatError(value);
        }
        if (keys.length === 0 && (!array || value.length == 0)) {
          return braces[0] + base + braces[1];
        }
        if (recurseTimes < 0) {
          if (isRegExp(value)) {
            return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
          } else {
            return ctx.stylize("[Object]", "special");
          }
        }
        ctx.seen.push(value);
        var output;
        if (array) {
          output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
        } else {
          output = keys.map(function(key) {
            return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
          });
        }
        ctx.seen.pop();
        return reduceToSingleString(output, base, braces);
      }
      function formatPrimitive(ctx, value) {
        if (isUndefined(value))
          return ctx.stylize("undefined", "undefined");
        if (isString(value)) {
          var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
          return ctx.stylize(simple, "string");
        }
        if (isNumber(value))
          return ctx.stylize("" + value, "number");
        if (isBoolean(value))
          return ctx.stylize("" + value, "boolean");
        if (isNull(value))
          return ctx.stylize("null", "null");
      }
      function formatError(value) {
        return "[" + Error.prototype.toString.call(value) + "]";
      }
      function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
        var output = [];
        for (var i = 0, l = value.length; i < l; ++i) {
          if (hasOwnProperty(value, String(i))) {
            output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
          } else {
            output.push("");
          }
        }
        keys.forEach(function(key) {
          if (!key.match(/^\d+$/)) {
            output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
          }
        });
        return output;
      }
      function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
        var name, str, desc2;
        desc2 = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
        if (desc2.get) {
          if (desc2.set) {
            str = ctx.stylize("[Getter/Setter]", "special");
          } else {
            str = ctx.stylize("[Getter]", "special");
          }
        } else {
          if (desc2.set) {
            str = ctx.stylize("[Setter]", "special");
          }
        }
        if (!hasOwnProperty(visibleKeys, key)) {
          name = "[" + key + "]";
        }
        if (!str) {
          if (ctx.seen.indexOf(desc2.value) < 0) {
            if (isNull(recurseTimes)) {
              str = formatValue(ctx, desc2.value, null);
            } else {
              str = formatValue(ctx, desc2.value, recurseTimes - 1);
            }
            if (str.indexOf("\n") > -1) {
              if (array) {
                str = str.split("\n").map(function(line) {
                  return "  " + line;
                }).join("\n").substr(2);
              } else {
                str = "\n" + str.split("\n").map(function(line) {
                  return "   " + line;
                }).join("\n");
              }
            }
          } else {
            str = ctx.stylize("[Circular]", "special");
          }
        }
        if (isUndefined(name)) {
          if (array && key.match(/^\d+$/)) {
            return str;
          }
          name = JSON.stringify("" + key);
          if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
            name = name.substr(1, name.length - 2);
            name = ctx.stylize(name, "name");
          } else {
            name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
            name = ctx.stylize(name, "string");
          }
        }
        return name + ": " + str;
      }
      function reduceToSingleString(output, base, braces) {
        var numLinesEst = 0;
        var length = output.reduce(function(prev, cur) {
          numLinesEst++;
          if (cur.indexOf("\n") >= 0)
            numLinesEst++;
          return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
        }, 0);
        if (length > 60) {
          return braces[0] + (base === "" ? "" : base + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
        }
        return braces[0] + base + " " + output.join(", ") + " " + braces[1];
      }
      exports.types = require_types();
      function isArray(ar) {
        return Array.isArray(ar);
      }
      exports.isArray = isArray;
      function isBoolean(arg) {
        return typeof arg === "boolean";
      }
      exports.isBoolean = isBoolean;
      function isNull(arg) {
        return arg === null;
      }
      exports.isNull = isNull;
      function isNullOrUndefined(arg) {
        return arg == null;
      }
      exports.isNullOrUndefined = isNullOrUndefined;
      function isNumber(arg) {
        return typeof arg === "number";
      }
      exports.isNumber = isNumber;
      function isString(arg) {
        return typeof arg === "string";
      }
      exports.isString = isString;
      function isSymbol(arg) {
        return typeof arg === "symbol";
      }
      exports.isSymbol = isSymbol;
      function isUndefined(arg) {
        return arg === void 0;
      }
      exports.isUndefined = isUndefined;
      function isRegExp(re) {
        return isObject2(re) && objectToString(re) === "[object RegExp]";
      }
      exports.isRegExp = isRegExp;
      exports.types.isRegExp = isRegExp;
      function isObject2(arg) {
        return typeof arg === "object" && arg !== null;
      }
      exports.isObject = isObject2;
      function isDate(d) {
        return isObject2(d) && objectToString(d) === "[object Date]";
      }
      exports.isDate = isDate;
      exports.types.isDate = isDate;
      function isError(e) {
        return isObject2(e) && (objectToString(e) === "[object Error]" || e instanceof Error);
      }
      exports.isError = isError;
      exports.types.isNativeError = isError;
      function isFunction(arg) {
        return typeof arg === "function";
      }
      exports.isFunction = isFunction;
      function isPrimitive(arg) {
        return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || typeof arg === "undefined";
      }
      exports.isPrimitive = isPrimitive;
      exports.isBuffer = require_isBufferBrowser();
      function objectToString(o) {
        return Object.prototype.toString.call(o);
      }
      function pad(n) {
        return n < 10 ? "0" + n.toString(10) : n.toString(10);
      }
      var months = [
        "Jan",
        "Feb",
        "Mar",
        "Apr",
        "May",
        "Jun",
        "Jul",
        "Aug",
        "Sep",
        "Oct",
        "Nov",
        "Dec"
      ];
      function timestamp() {
        var d = new Date();
        var time = [
          pad(d.getHours()),
          pad(d.getMinutes()),
          pad(d.getSeconds())
        ].join(":");
        return [d.getDate(), months[d.getMonth()], time].join(" ");
      }
      exports.log = function() {
        console.log("%s - %s", timestamp(), exports.format.apply(exports, arguments));
      };
      exports.inherits = require_inherits_browser();
      exports._extend = function(origin, add) {
        if (!add || !isObject2(add))
          return origin;
        var keys = Object.keys(add);
        var i = keys.length;
        while (i--) {
          origin[keys[i]] = add[keys[i]];
        }
        return origin;
      };
      function hasOwnProperty(obj, prop) {
        return Object.prototype.hasOwnProperty.call(obj, prop);
      }
      var kCustomPromisifiedSymbol = typeof Symbol !== "undefined" ? Symbol("util.promisify.custom") : void 0;
      exports.promisify = function promisify(original) {
        if (typeof original !== "function")
          throw new TypeError('The "original" argument must be of type Function');
        if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
          var fn = original[kCustomPromisifiedSymbol];
          if (typeof fn !== "function") {
            throw new TypeError('The "util.promisify.custom" argument must be of type Function');
          }
          Object.defineProperty(fn, kCustomPromisifiedSymbol, {
            value: fn,
            enumerable: false,
            writable: false,
            configurable: true
          });
          return fn;
        }
        function fn() {
          var promiseResolve, promiseReject;
          var promise = new Promise(function(resolve, reject) {
            promiseResolve = resolve;
            promiseReject = reject;
          });
          var args = [];
          for (var i = 0; i < arguments.length; i++) {
            args.push(arguments[i]);
          }
          args.push(function(err, value) {
            if (err) {
              promiseReject(err);
            } else {
              promiseResolve(value);
            }
          });
          try {
            original.apply(this, args);
          } catch (err) {
            promiseReject(err);
          }
          return promise;
        }
        Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
        if (kCustomPromisifiedSymbol)
          Object.defineProperty(fn, kCustomPromisifiedSymbol, {
            value: fn,
            enumerable: false,
            writable: false,
            configurable: true
          });
        return Object.defineProperties(fn, getOwnPropertyDescriptors(original));
      };
      exports.promisify.custom = kCustomPromisifiedSymbol;
      function callbackifyOnRejected(reason, cb) {
        if (!reason) {
          var newReason = new Error("Promise was rejected with a falsy value");
          newReason.reason = reason;
          reason = newReason;
        }
        return cb(reason);
      }
      function callbackify(original) {
        if (typeof original !== "function") {
          throw new TypeError('The "original" argument must be of type Function');
        }
        function callbackified() {
          var args = [];
          for (var i = 0; i < arguments.length; i++) {
            args.push(arguments[i]);
          }
          var maybeCb = args.pop();
          if (typeof maybeCb !== "function") {
            throw new TypeError("The last argument must be of type Function");
          }
          var self2 = this;
          var cb = function() {
            return maybeCb.apply(self2, arguments);
          };
          original.apply(this, args).then(function(ret) {
            process.nextTick(cb.bind(null, null, ret));
          }, function(rej) {
            process.nextTick(callbackifyOnRejected.bind(null, rej, cb));
          });
        }
        Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
        Object.defineProperties(callbackified, getOwnPropertyDescriptors(original));
        return callbackified;
      }
      exports.callbackify = callbackify;
    }
  });

  // node_modules/arweave/node/lib/utils.js
  var require_utils = __commonJS({
    "node_modules/arweave/node/lib/utils.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() {
          return m[k];
        } });
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.b64UrlDecode = exports.b64UrlEncode = exports.bufferTob64Url = exports.bufferTob64 = exports.b64UrlToBuffer = exports.stringToB64Url = exports.stringToBuffer = exports.bufferToString = exports.b64UrlToString = exports.concatBuffers = void 0;
      var B64js = __importStar(require_base64_js());
      function concatBuffers(buffers) {
        let total_length = 0;
        for (let i = 0; i < buffers.length; i++) {
          total_length += buffers[i].byteLength;
        }
        let temp = new Uint8Array(total_length);
        let offset = 0;
        temp.set(new Uint8Array(buffers[0]), offset);
        offset += buffers[0].byteLength;
        for (let i = 1; i < buffers.length; i++) {
          temp.set(new Uint8Array(buffers[i]), offset);
          offset += buffers[i].byteLength;
        }
        return temp;
      }
      exports.concatBuffers = concatBuffers;
      function b64UrlToString(b64UrlString) {
        let buffer = b64UrlToBuffer(b64UrlString);
        if (typeof TextDecoder == "undefined") {
          const TextDecoder2 = require_util().TextDecoder;
          return new TextDecoder2("utf-8", { fatal: true }).decode(buffer);
        }
        return new TextDecoder("utf-8", { fatal: true }).decode(buffer);
      }
      exports.b64UrlToString = b64UrlToString;
      function bufferToString(buffer) {
        if (typeof TextDecoder == "undefined") {
          const TextDecoder2 = require_util().TextDecoder;
          return new TextDecoder2("utf-8", { fatal: true }).decode(buffer);
        }
        return new TextDecoder("utf-8", { fatal: true }).decode(buffer);
      }
      exports.bufferToString = bufferToString;
      function stringToBuffer(string) {
        if (typeof TextEncoder == "undefined") {
          const TextEncoder2 = require_util().TextEncoder;
          return new TextEncoder2().encode(string);
        }
        return new TextEncoder().encode(string);
      }
      exports.stringToBuffer = stringToBuffer;
      function stringToB64Url(string) {
        return bufferTob64Url(stringToBuffer(string));
      }
      exports.stringToB64Url = stringToB64Url;
      function b64UrlToBuffer(b64UrlString) {
        return new Uint8Array(B64js.toByteArray(b64UrlDecode(b64UrlString)));
      }
      exports.b64UrlToBuffer = b64UrlToBuffer;
      function bufferTob64(buffer) {
        return B64js.fromByteArray(new Uint8Array(buffer));
      }
      exports.bufferTob64 = bufferTob64;
      function bufferTob64Url(buffer) {
        return b64UrlEncode(bufferTob64(buffer));
      }
      exports.bufferTob64Url = bufferTob64Url;
      function b64UrlEncode(b64UrlString) {
        return b64UrlString.replace(/\+/g, "-").replace(/\//g, "_").replace(/\=/g, "");
      }
      exports.b64UrlEncode = b64UrlEncode;
      function b64UrlDecode(b64UrlString) {
        b64UrlString = b64UrlString.replace(/\-/g, "+").replace(/\_/g, "/");
        let padding;
        b64UrlString.length % 4 == 0 ? padding = 0 : padding = 4 - b64UrlString.length % 4;
        return b64UrlString.concat("=".repeat(padding));
      }
      exports.b64UrlDecode = b64UrlDecode;
    }
  });

  // node_modules/bignumber.js/bignumber.js
  var require_bignumber = __commonJS({
    "node_modules/bignumber.js/bignumber.js"(exports, module2) {
      (function(globalObject) {
        "use strict";
        var BigNumber2, isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, mathceil = Math.ceil, mathfloor = Math.floor, bignumberError = "[BigNumber Error] ", tooManyDigits = bignumberError + "Number primitive has more than 15 significant digits: ", BASE = 1e14, LOG_BASE = 14, MAX_SAFE_INTEGER = 9007199254740991, POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], SQRT_BASE = 1e7, MAX = 1e9;
        function clone(configObject) {
          var div, convertBase, parseNumeric, P = BigNumber3.prototype = { constructor: BigNumber3, toString: null, valueOf: null }, ONE = new BigNumber3(1), DECIMAL_PLACES = 20, ROUNDING_MODE = 4, TO_EXP_NEG = -7, TO_EXP_POS = 21, MIN_EXP = -1e7, MAX_EXP = 1e7, CRYPTO = false, MODULO_MODE = 1, POW_PRECISION = 0, FORMAT = {
            prefix: "",
            groupSize: 3,
            secondaryGroupSize: 0,
            groupSeparator: ",",
            decimalSeparator: ".",
            fractionGroupSize: 0,
            fractionGroupSeparator: "\xA0",
            suffix: ""
          }, ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyz", alphabetHasNormalDecimalDigits = true;
          function BigNumber3(v, b) {
            var alphabet, c, caseChanged, e, i, isNum, len, str, x = this;
            if (!(x instanceof BigNumber3))
              return new BigNumber3(v, b);
            if (b == null) {
              if (v && v._isBigNumber === true) {
                x.s = v.s;
                if (!v.c || v.e > MAX_EXP) {
                  x.c = x.e = null;
                } else if (v.e < MIN_EXP) {
                  x.c = [x.e = 0];
                } else {
                  x.e = v.e;
                  x.c = v.c.slice();
                }
                return;
              }
              if ((isNum = typeof v == "number") && v * 0 == 0) {
                x.s = 1 / v < 0 ? (v = -v, -1) : 1;
                if (v === ~~v) {
                  for (e = 0, i = v; i >= 10; i /= 10, e++)
                    ;
                  if (e > MAX_EXP) {
                    x.c = x.e = null;
                  } else {
                    x.e = e;
                    x.c = [v];
                  }
                  return;
                }
                str = String(v);
              } else {
                if (!isNumeric.test(str = String(v)))
                  return parseNumeric(x, str, isNum);
                x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
              }
              if ((e = str.indexOf(".")) > -1)
                str = str.replace(".", "");
              if ((i = str.search(/e/i)) > 0) {
                if (e < 0)
                  e = i;
                e += +str.slice(i + 1);
                str = str.substring(0, i);
              } else if (e < 0) {
                e = str.length;
              }
            } else {
              intCheck(b, 2, ALPHABET.length, "Base");
              if (b == 10 && alphabetHasNormalDecimalDigits) {
                x = new BigNumber3(v);
                return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);
              }
              str = String(v);
              if (isNum = typeof v == "number") {
                if (v * 0 != 0)
                  return parseNumeric(x, str, isNum, b);
                x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;
                if (BigNumber3.DEBUG && str.replace(/^0\.0*|\./, "").length > 15) {
                  throw Error(tooManyDigits + v);
                }
              } else {
                x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
              }
              alphabet = ALPHABET.slice(0, b);
              e = i = 0;
              for (len = str.length; i < len; i++) {
                if (alphabet.indexOf(c = str.charAt(i)) < 0) {
                  if (c == ".") {
                    if (i > e) {
                      e = len;
                      continue;
                    }
                  } else if (!caseChanged) {
                    if (str == str.toUpperCase() && (str = str.toLowerCase()) || str == str.toLowerCase() && (str = str.toUpperCase())) {
                      caseChanged = true;
                      i = -1;
                      e = 0;
                      continue;
                    }
                  }
                  return parseNumeric(x, String(v), isNum, b);
                }
              }
              isNum = false;
              str = convertBase(str, b, 10, x.s);
              if ((e = str.indexOf(".")) > -1)
                str = str.replace(".", "");
              else
                e = str.length;
            }
            for (i = 0; str.charCodeAt(i) === 48; i++)
              ;
            for (len = str.length; str.charCodeAt(--len) === 48; )
              ;
            if (str = str.slice(i, ++len)) {
              len -= i;
              if (isNum && BigNumber3.DEBUG && len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {
                throw Error(tooManyDigits + x.s * v);
              }
              if ((e = e - i - 1) > MAX_EXP) {
                x.c = x.e = null;
              } else if (e < MIN_EXP) {
                x.c = [x.e = 0];
              } else {
                x.e = e;
                x.c = [];
                i = (e + 1) % LOG_BASE;
                if (e < 0)
                  i += LOG_BASE;
                if (i < len) {
                  if (i)
                    x.c.push(+str.slice(0, i));
                  for (len -= LOG_BASE; i < len; ) {
                    x.c.push(+str.slice(i, i += LOG_BASE));
                  }
                  i = LOG_BASE - (str = str.slice(i)).length;
                } else {
                  i -= len;
                }
                for (; i--; str += "0")
                  ;
                x.c.push(+str);
              }
            } else {
              x.c = [x.e = 0];
            }
          }
          BigNumber3.clone = clone;
          BigNumber3.ROUND_UP = 0;
          BigNumber3.ROUND_DOWN = 1;
          BigNumber3.ROUND_CEIL = 2;
          BigNumber3.ROUND_FLOOR = 3;
          BigNumber3.ROUND_HALF_UP = 4;
          BigNumber3.ROUND_HALF_DOWN = 5;
          BigNumber3.ROUND_HALF_EVEN = 6;
          BigNumber3.ROUND_HALF_CEIL = 7;
          BigNumber3.ROUND_HALF_FLOOR = 8;
          BigNumber3.EUCLID = 9;
          BigNumber3.config = BigNumber3.set = function(obj) {
            var p, v;
            if (obj != null) {
              if (typeof obj == "object") {
                if (obj.hasOwnProperty(p = "DECIMAL_PLACES")) {
                  v = obj[p];
                  intCheck(v, 0, MAX, p);
                  DECIMAL_PLACES = v;
                }
                if (obj.hasOwnProperty(p = "ROUNDING_MODE")) {
                  v = obj[p];
                  intCheck(v, 0, 8, p);
                  ROUNDING_MODE = v;
                }
                if (obj.hasOwnProperty(p = "EXPONENTIAL_AT")) {
                  v = obj[p];
                  if (v && v.pop) {
                    intCheck(v[0], -MAX, 0, p);
                    intCheck(v[1], 0, MAX, p);
                    TO_EXP_NEG = v[0];
                    TO_EXP_POS = v[1];
                  } else {
                    intCheck(v, -MAX, MAX, p);
                    TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);
                  }
                }
                if (obj.hasOwnProperty(p = "RANGE")) {
                  v = obj[p];
                  if (v && v.pop) {
                    intCheck(v[0], -MAX, -1, p);
                    intCheck(v[1], 1, MAX, p);
                    MIN_EXP = v[0];
                    MAX_EXP = v[1];
                  } else {
                    intCheck(v, -MAX, MAX, p);
                    if (v) {
                      MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);
                    } else {
                      throw Error(bignumberError + p + " cannot be zero: " + v);
                    }
                  }
                }
                if (obj.hasOwnProperty(p = "CRYPTO")) {
                  v = obj[p];
                  if (v === !!v) {
                    if (v) {
                      if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
                        CRYPTO = v;
                      } else {
                        CRYPTO = !v;
                        throw Error(bignumberError + "crypto unavailable");
                      }
                    } else {
                      CRYPTO = v;
                    }
                  } else {
                    throw Error(bignumberError + p + " not true or false: " + v);
                  }
                }
                if (obj.hasOwnProperty(p = "MODULO_MODE")) {
                  v = obj[p];
                  intCheck(v, 0, 9, p);
                  MODULO_MODE = v;
                }
                if (obj.hasOwnProperty(p = "POW_PRECISION")) {
                  v = obj[p];
                  intCheck(v, 0, MAX, p);
                  POW_PRECISION = v;
                }
                if (obj.hasOwnProperty(p = "FORMAT")) {
                  v = obj[p];
                  if (typeof v == "object")
                    FORMAT = v;
                  else
                    throw Error(bignumberError + p + " not an object: " + v);
                }
                if (obj.hasOwnProperty(p = "ALPHABET")) {
                  v = obj[p];
                  if (typeof v == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(v)) {
                    alphabetHasNormalDecimalDigits = v.slice(0, 10) == "0123456789";
                    ALPHABET = v;
                  } else {
                    throw Error(bignumberError + p + " invalid: " + v);
                  }
                }
              } else {
                throw Error(bignumberError + "Object expected: " + obj);
              }
            }
            return {
              DECIMAL_PLACES,
              ROUNDING_MODE,
              EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
              RANGE: [MIN_EXP, MAX_EXP],
              CRYPTO,
              MODULO_MODE,
              POW_PRECISION,
              FORMAT,
              ALPHABET
            };
          };
          BigNumber3.isBigNumber = function(v) {
            if (!v || v._isBigNumber !== true)
              return false;
            if (!BigNumber3.DEBUG)
              return true;
            var i, n, c = v.c, e = v.e, s = v.s;
            out:
              if ({}.toString.call(c) == "[object Array]") {
                if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {
                  if (c[0] === 0) {
                    if (e === 0 && c.length === 1)
                      return true;
                    break out;
                  }
                  i = (e + 1) % LOG_BASE;
                  if (i < 1)
                    i += LOG_BASE;
                  if (String(c[0]).length == i) {
                    for (i = 0; i < c.length; i++) {
                      n = c[i];
                      if (n < 0 || n >= BASE || n !== mathfloor(n))
                        break out;
                    }
                    if (n !== 0)
                      return true;
                  }
                }
              } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {
                return true;
              }
            throw Error(bignumberError + "Invalid BigNumber: " + v);
          };
          BigNumber3.maximum = BigNumber3.max = function() {
            return maxOrMin(arguments, P.lt);
          };
          BigNumber3.minimum = BigNumber3.min = function() {
            return maxOrMin(arguments, P.gt);
          };
          BigNumber3.random = function() {
            var pow2_53 = 9007199254740992;
            var random53bitInt = Math.random() * pow2_53 & 2097151 ? function() {
              return mathfloor(Math.random() * pow2_53);
            } : function() {
              return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
            };
            return function(dp) {
              var a, b, e, k, v, i = 0, c = [], rand = new BigNumber3(ONE);
              if (dp == null)
                dp = DECIMAL_PLACES;
              else
                intCheck(dp, 0, MAX);
              k = mathceil(dp / LOG_BASE);
              if (CRYPTO) {
                if (crypto.getRandomValues) {
                  a = crypto.getRandomValues(new Uint32Array(k *= 2));
                  for (; i < k; ) {
                    v = a[i] * 131072 + (a[i + 1] >>> 11);
                    if (v >= 9e15) {
                      b = crypto.getRandomValues(new Uint32Array(2));
                      a[i] = b[0];
                      a[i + 1] = b[1];
                    } else {
                      c.push(v % 1e14);
                      i += 2;
                    }
                  }
                  i = k / 2;
                } else if (crypto.randomBytes) {
                  a = crypto.randomBytes(k *= 7);
                  for (; i < k; ) {
                    v = (a[i] & 31) * 281474976710656 + a[i + 1] * 1099511627776 + a[i + 2] * 4294967296 + a[i + 3] * 16777216 + (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];
                    if (v >= 9e15) {
                      crypto.randomBytes(7).copy(a, i);
                    } else {
                      c.push(v % 1e14);
                      i += 7;
                    }
                  }
                  i = k / 7;
                } else {
                  CRYPTO = false;
                  throw Error(bignumberError + "crypto unavailable");
                }
              }
              if (!CRYPTO) {
                for (; i < k; ) {
                  v = random53bitInt();
                  if (v < 9e15)
                    c[i++] = v % 1e14;
                }
              }
              k = c[--i];
              dp %= LOG_BASE;
              if (k && dp) {
                v = POWS_TEN[LOG_BASE - dp];
                c[i] = mathfloor(k / v) * v;
              }
              for (; c[i] === 0; c.pop(), i--)
                ;
              if (i < 0) {
                c = [e = 0];
              } else {
                for (e = -1; c[0] === 0; c.splice(0, 1), e -= LOG_BASE)
                  ;
                for (i = 1, v = c[0]; v >= 10; v /= 10, i++)
                  ;
                if (i < LOG_BASE)
                  e -= LOG_BASE - i;
              }
              rand.e = e;
              rand.c = c;
              return rand;
            };
          }();
          BigNumber3.sum = function() {
            var i = 1, args = arguments, sum = new BigNumber3(args[0]);
            for (; i < args.length; )
              sum = sum.plus(args[i++]);
            return sum;
          };
          convertBase = function() {
            var decimal = "0123456789";
            function toBaseOut(str, baseIn, baseOut, alphabet) {
              var j, arr = [0], arrL, i = 0, len = str.length;
              for (; i < len; ) {
                for (arrL = arr.length; arrL--; arr[arrL] *= baseIn)
                  ;
                arr[0] += alphabet.indexOf(str.charAt(i++));
                for (j = 0; j < arr.length; j++) {
                  if (arr[j] > baseOut - 1) {
                    if (arr[j + 1] == null)
                      arr[j + 1] = 0;
                    arr[j + 1] += arr[j] / baseOut | 0;
                    arr[j] %= baseOut;
                  }
                }
              }
              return arr.reverse();
            }
            return function(str, baseIn, baseOut, sign, callerIsToString) {
              var alphabet, d, e, k, r, x, xc, y, i = str.indexOf("."), dp = DECIMAL_PLACES, rm = ROUNDING_MODE;
              if (i >= 0) {
                k = POW_PRECISION;
                POW_PRECISION = 0;
                str = str.replace(".", "");
                y = new BigNumber3(baseIn);
                x = y.pow(str.length - i);
                POW_PRECISION = k;
                y.c = toBaseOut(toFixedPoint(coeffToString(x.c), x.e, "0"), 10, baseOut, decimal);
                y.e = y.c.length;
              }
              xc = toBaseOut(str, baseIn, baseOut, callerIsToString ? (alphabet = ALPHABET, decimal) : (alphabet = decimal, ALPHABET));
              e = k = xc.length;
              for (; xc[--k] == 0; xc.pop())
                ;
              if (!xc[0])
                return alphabet.charAt(0);
              if (i < 0) {
                --e;
              } else {
                x.c = xc;
                x.e = e;
                x.s = sign;
                x = div(x, y, dp, rm, baseOut);
                xc = x.c;
                r = x.r;
                e = x.e;
              }
              d = e + dp + 1;
              i = xc[d];
              k = baseOut / 2;
              r = r || d < 0 || xc[d + 1] != null;
              r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : i > k || i == k && (rm == 4 || r || rm == 6 && xc[d - 1] & 1 || rm == (x.s < 0 ? 8 : 7));
              if (d < 1 || !xc[0]) {
                str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
              } else {
                xc.length = d;
                if (r) {
                  for (--baseOut; ++xc[--d] > baseOut; ) {
                    xc[d] = 0;
                    if (!d) {
                      ++e;
                      xc = [1].concat(xc);
                    }
                  }
                }
                for (k = xc.length; !xc[--k]; )
                  ;
                for (i = 0, str = ""; i <= k; str += alphabet.charAt(xc[i++]))
                  ;
                str = toFixedPoint(str, e, alphabet.charAt(0));
              }
              return str;
            };
          }();
          div = function() {
            function multiply(x, k, base) {
              var m, temp, xlo, xhi, carry = 0, i = x.length, klo = k % SQRT_BASE, khi = k / SQRT_BASE | 0;
              for (x = x.slice(); i--; ) {
                xlo = x[i] % SQRT_BASE;
                xhi = x[i] / SQRT_BASE | 0;
                m = khi * xlo + xhi * klo;
                temp = klo * xlo + m % SQRT_BASE * SQRT_BASE + carry;
                carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;
                x[i] = temp % base;
              }
              if (carry)
                x = [carry].concat(x);
              return x;
            }
            function compare2(a, b, aL, bL) {
              var i, cmp;
              if (aL != bL) {
                cmp = aL > bL ? 1 : -1;
              } else {
                for (i = cmp = 0; i < aL; i++) {
                  if (a[i] != b[i]) {
                    cmp = a[i] > b[i] ? 1 : -1;
                    break;
                  }
                }
              }
              return cmp;
            }
            function subtract(a, b, aL, base) {
              var i = 0;
              for (; aL--; ) {
                a[aL] -= i;
                i = a[aL] < b[aL] ? 1 : 0;
                a[aL] = i * base + a[aL] - b[aL];
              }
              for (; !a[0] && a.length > 1; a.splice(0, 1))
                ;
            }
            return function(x, y, dp, rm, base) {
              var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0, yL, yz, s = x.s == y.s ? 1 : -1, xc = x.c, yc = y.c;
              if (!xc || !xc[0] || !yc || !yc[0]) {
                return new BigNumber3(!x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN : xc && xc[0] == 0 || !yc ? s * 0 : s / 0);
              }
              q = new BigNumber3(s);
              qc = q.c = [];
              e = x.e - y.e;
              s = dp + e + 1;
              if (!base) {
                base = BASE;
                e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);
                s = s / LOG_BASE | 0;
              }
              for (i = 0; yc[i] == (xc[i] || 0); i++)
                ;
              if (yc[i] > (xc[i] || 0))
                e--;
              if (s < 0) {
                qc.push(1);
                more = true;
              } else {
                xL = xc.length;
                yL = yc.length;
                i = 0;
                s += 2;
                n = mathfloor(base / (yc[0] + 1));
                if (n > 1) {
                  yc = multiply(yc, n, base);
                  xc = multiply(xc, n, base);
                  yL = yc.length;
                  xL = xc.length;
                }
                xi = yL;
                rem = xc.slice(0, yL);
                remL = rem.length;
                for (; remL < yL; rem[remL++] = 0)
                  ;
                yz = yc.slice();
                yz = [0].concat(yz);
                yc0 = yc[0];
                if (yc[1] >= base / 2)
                  yc0++;
                do {
                  n = 0;
                  cmp = compare2(yc, rem, yL, remL);
                  if (cmp < 0) {
                    rem0 = rem[0];
                    if (yL != remL)
                      rem0 = rem0 * base + (rem[1] || 0);
                    n = mathfloor(rem0 / yc0);
                    if (n > 1) {
                      if (n >= base)
                        n = base - 1;
                      prod = multiply(yc, n, base);
                      prodL = prod.length;
                      remL = rem.length;
                      while (compare2(prod, rem, prodL, remL) == 1) {
                        n--;
                        subtract(prod, yL < prodL ? yz : yc, prodL, base);
                        prodL = prod.length;
                        cmp = 1;
                      }
                    } else {
                      if (n == 0) {
                        cmp = n = 1;
                      }
                      prod = yc.slice();
                      prodL = prod.length;
                    }
                    if (prodL < remL)
                      prod = [0].concat(prod);
                    subtract(rem, prod, remL, base);
                    remL = rem.length;
                    if (cmp == -1) {
                      while (compare2(yc, rem, yL, remL) < 1) {
                        n++;
                        subtract(rem, yL < remL ? yz : yc, remL, base);
                        remL = rem.length;
                      }
                    }
                  } else if (cmp === 0) {
                    n++;
                    rem = [0];
                  }
                  qc[i++] = n;
                  if (rem[0]) {
                    rem[remL++] = xc[xi] || 0;
                  } else {
                    rem = [xc[xi]];
                    remL = 1;
                  }
                } while ((xi++ < xL || rem[0] != null) && s--);
                more = rem[0] != null;
                if (!qc[0])
                  qc.splice(0, 1);
              }
              if (base == BASE) {
                for (i = 1, s = qc[0]; s >= 10; s /= 10, i++)
                  ;
                round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);
              } else {
                q.e = e;
                q.r = +more;
              }
              return q;
            };
          }();
          function format(n, i, rm, id) {
            var c0, e, ne, len, str;
            if (rm == null)
              rm = ROUNDING_MODE;
            else
              intCheck(rm, 0, 8);
            if (!n.c)
              return n.toString();
            c0 = n.c[0];
            ne = n.e;
            if (i == null) {
              str = coeffToString(n.c);
              str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS) ? toExponential(str, ne) : toFixedPoint(str, ne, "0");
            } else {
              n = round(new BigNumber3(n), i, rm);
              e = n.e;
              str = coeffToString(n.c);
              len = str.length;
              if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {
                for (; len < i; str += "0", len++)
                  ;
                str = toExponential(str, e);
              } else {
                i -= ne;
                str = toFixedPoint(str, e, "0");
                if (e + 1 > len) {
                  if (--i > 0)
                    for (str += "."; i--; str += "0")
                      ;
                } else {
                  i += e - len;
                  if (i > 0) {
                    if (e + 1 == len)
                      str += ".";
                    for (; i--; str += "0")
                      ;
                  }
                }
              }
            }
            return n.s < 0 && c0 ? "-" + str : str;
          }
          function maxOrMin(args, method) {
            var n, i = 1, m = new BigNumber3(args[0]);
            for (; i < args.length; i++) {
              n = new BigNumber3(args[i]);
              if (!n.s) {
                m = n;
                break;
              } else if (method.call(m, n)) {
                m = n;
              }
            }
            return m;
          }
          function normalise(n, c, e) {
            var i = 1, j = c.length;
            for (; !c[--j]; c.pop())
              ;
            for (j = c[0]; j >= 10; j /= 10, i++)
              ;
            if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {
              n.c = n.e = null;
            } else if (e < MIN_EXP) {
              n.c = [n.e = 0];
            } else {
              n.e = e;
              n.c = c;
            }
            return n;
          }
          parseNumeric = function() {
            var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i, dotAfter = /^([^.]+)\.$/, dotBefore = /^\.([^.]+)$/, isInfinityOrNaN = /^-?(Infinity|NaN)$/, whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
            return function(x, str, isNum, b) {
              var base, s = isNum ? str : str.replace(whitespaceOrPlus, "");
              if (isInfinityOrNaN.test(s)) {
                x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
              } else {
                if (!isNum) {
                  s = s.replace(basePrefix, function(m, p1, p2) {
                    base = (p2 = p2.toLowerCase()) == "x" ? 16 : p2 == "b" ? 2 : 8;
                    return !b || b == base ? p1 : m;
                  });
                  if (b) {
                    base = b;
                    s = s.replace(dotAfter, "$1").replace(dotBefore, "0.$1");
                  }
                  if (str != s)
                    return new BigNumber3(s, base);
                }
                if (BigNumber3.DEBUG) {
                  throw Error(bignumberError + "Not a" + (b ? " base " + b : "") + " number: " + str);
                }
                x.s = null;
              }
              x.c = x.e = null;
            };
          }();
          function round(x, sd, rm, r) {
            var d, i, j, k, n, ni, rd, xc = x.c, pows10 = POWS_TEN;
            if (xc) {
              out: {
                for (d = 1, k = xc[0]; k >= 10; k /= 10, d++)
                  ;
                i = sd - d;
                if (i < 0) {
                  i += LOG_BASE;
                  j = sd;
                  n = xc[ni = 0];
                  rd = n / pows10[d - j - 1] % 10 | 0;
                } else {
                  ni = mathceil((i + 1) / LOG_BASE);
                  if (ni >= xc.length) {
                    if (r) {
                      for (; xc.length <= ni; xc.push(0))
                        ;
                      n = rd = 0;
                      d = 1;
                      i %= LOG_BASE;
                      j = i - LOG_BASE + 1;
                    } else {
                      break out;
                    }
                  } else {
                    n = k = xc[ni];
                    for (d = 1; k >= 10; k /= 10, d++)
                      ;
                    i %= LOG_BASE;
                    j = i - LOG_BASE + d;
                    rd = j < 0 ? 0 : n / pows10[d - j - 1] % 10 | 0;
                  }
                }
                r = r || sd < 0 || xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);
                r = rm < 4 ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 && (i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));
                if (sd < 1 || !xc[0]) {
                  xc.length = 0;
                  if (r) {
                    sd -= x.e + 1;
                    xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
                    x.e = -sd || 0;
                  } else {
                    xc[0] = x.e = 0;
                  }
                  return x;
                }
                if (i == 0) {
                  xc.length = ni;
                  k = 1;
                  ni--;
                } else {
                  xc.length = ni + 1;
                  k = pows10[LOG_BASE - i];
                  xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;
                }
                if (r) {
                  for (; ; ) {
                    if (ni == 0) {
                      for (i = 1, j = xc[0]; j >= 10; j /= 10, i++)
                        ;
                      j = xc[0] += k;
                      for (k = 1; j >= 10; j /= 10, k++)
                        ;
                      if (i != k) {
                        x.e++;
                        if (xc[0] == BASE)
                          xc[0] = 1;
                      }
                      break;
                    } else {
                      xc[ni] += k;
                      if (xc[ni] != BASE)
                        break;
                      xc[ni--] = 0;
                      k = 1;
                    }
                  }
                }
                for (i = xc.length; xc[--i] === 0; xc.pop())
                  ;
              }
              if (x.e > MAX_EXP) {
                x.c = x.e = null;
              } else if (x.e < MIN_EXP) {
                x.c = [x.e = 0];
              }
            }
            return x;
          }
          function valueOf(n) {
            var str, e = n.e;
            if (e === null)
              return n.toString();
            str = coeffToString(n.c);
            str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(str, e) : toFixedPoint(str, e, "0");
            return n.s < 0 ? "-" + str : str;
          }
          P.absoluteValue = P.abs = function() {
            var x = new BigNumber3(this);
            if (x.s < 0)
              x.s = 1;
            return x;
          };
          P.comparedTo = function(y, b) {
            return compare(this, new BigNumber3(y, b));
          };
          P.decimalPlaces = P.dp = function(dp, rm) {
            var c, n, v, x = this;
            if (dp != null) {
              intCheck(dp, 0, MAX);
              if (rm == null)
                rm = ROUNDING_MODE;
              else
                intCheck(rm, 0, 8);
              return round(new BigNumber3(x), dp + x.e + 1, rm);
            }
            if (!(c = x.c))
              return null;
            n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;
            if (v = c[v])
              for (; v % 10 == 0; v /= 10, n--)
                ;
            if (n < 0)
              n = 0;
            return n;
          };
          P.dividedBy = P.div = function(y, b) {
            return div(this, new BigNumber3(y, b), DECIMAL_PLACES, ROUNDING_MODE);
          };
          P.dividedToIntegerBy = P.idiv = function(y, b) {
            return div(this, new BigNumber3(y, b), 0, 1);
          };
          P.exponentiatedBy = P.pow = function(n, m) {
            var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y, x = this;
            n = new BigNumber3(n);
            if (n.c && !n.isInteger()) {
              throw Error(bignumberError + "Exponent not an integer: " + valueOf(n));
            }
            if (m != null)
              m = new BigNumber3(m);
            nIsBig = n.e > 14;
            if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {
              y = new BigNumber3(Math.pow(+valueOf(x), nIsBig ? 2 - isOdd(n) : +valueOf(n)));
              return m ? y.mod(m) : y;
            }
            nIsNeg = n.s < 0;
            if (m) {
              if (m.c ? !m.c[0] : !m.s)
                return new BigNumber3(NaN);
              isModExp = !nIsNeg && x.isInteger() && m.isInteger();
              if (isModExp)
                x = x.mod(m);
            } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0 ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7 : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {
              k = x.s < 0 && isOdd(n) ? -0 : 0;
              if (x.e > -1)
                k = 1 / k;
              return new BigNumber3(nIsNeg ? 1 / k : k);
            } else if (POW_PRECISION) {
              k = mathceil(POW_PRECISION / LOG_BASE + 2);
            }
            if (nIsBig) {
              half = new BigNumber3(0.5);
              if (nIsNeg)
                n.s = 1;
              nIsOdd = isOdd(n);
            } else {
              i = Math.abs(+valueOf(n));
              nIsOdd = i % 2;
            }
            y = new BigNumber3(ONE);
            for (; ; ) {
              if (nIsOdd) {
                y = y.times(x);
                if (!y.c)
                  break;
                if (k) {
                  if (y.c.length > k)
                    y.c.length = k;
                } else if (isModExp) {
                  y = y.mod(m);
                }
              }
              if (i) {
                i = mathfloor(i / 2);
                if (i === 0)
                  break;
                nIsOdd = i % 2;
              } else {
                n = n.times(half);
                round(n, n.e + 1, 1);
                if (n.e > 14) {
                  nIsOdd = isOdd(n);
                } else {
                  i = +valueOf(n);
                  if (i === 0)
                    break;
                  nIsOdd = i % 2;
                }
              }
              x = x.times(x);
              if (k) {
                if (x.c && x.c.length > k)
                  x.c.length = k;
              } else if (isModExp) {
                x = x.mod(m);
              }
            }
            if (isModExp)
              return y;
            if (nIsNeg)
              y = ONE.div(y);
            return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;
          };
          P.integerValue = function(rm) {
            var n = new BigNumber3(this);
            if (rm == null)
              rm = ROUNDING_MODE;
            else
              intCheck(rm, 0, 8);
            return round(n, n.e + 1, rm);
          };
          P.isEqualTo = P.eq = function(y, b) {
            return compare(this, new BigNumber3(y, b)) === 0;
          };
          P.isFinite = function() {
            return !!this.c;
          };
          P.isGreaterThan = P.gt = function(y, b) {
            return compare(this, new BigNumber3(y, b)) > 0;
          };
          P.isGreaterThanOrEqualTo = P.gte = function(y, b) {
            return (b = compare(this, new BigNumber3(y, b))) === 1 || b === 0;
          };
          P.isInteger = function() {
            return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
          };
          P.isLessThan = P.lt = function(y, b) {
            return compare(this, new BigNumber3(y, b)) < 0;
          };
          P.isLessThanOrEqualTo = P.lte = function(y, b) {
            return (b = compare(this, new BigNumber3(y, b))) === -1 || b === 0;
          };
          P.isNaN = function() {
            return !this.s;
          };
          P.isNegative = function() {
            return this.s < 0;
          };
          P.isPositive = function() {
            return this.s > 0;
          };
          P.isZero = function() {
            return !!this.c && this.c[0] == 0;
          };
          P.minus = function(y, b) {
            var i, j, t, xLTy, x = this, a = x.s;
            y = new BigNumber3(y, b);
            b = y.s;
            if (!a || !b)
              return new BigNumber3(NaN);
            if (a != b) {
              y.s = -b;
              return x.plus(y);
            }
            var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
            if (!xe || !ye) {
              if (!xc || !yc)
                return xc ? (y.s = -b, y) : new BigNumber3(yc ? x : NaN);
              if (!xc[0] || !yc[0]) {
                return yc[0] ? (y.s = -b, y) : new BigNumber3(xc[0] ? x : ROUNDING_MODE == 3 ? -0 : 0);
              }
            }
            xe = bitFloor(xe);
            ye = bitFloor(ye);
            xc = xc.slice();
            if (a = xe - ye) {
              if (xLTy = a < 0) {
                a = -a;
                t = xc;
              } else {
                ye = xe;
                t = yc;
              }
              t.reverse();
              for (b = a; b--; t.push(0))
                ;
              t.reverse();
            } else {
              j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;
              for (a = b = 0; b < j; b++) {
                if (xc[b] != yc[b]) {
                  xLTy = xc[b] < yc[b];
                  break;
                }
              }
            }
            if (xLTy)
              t = xc, xc = yc, yc = t, y.s = -y.s;
            b = (j = yc.length) - (i = xc.length);
            if (b > 0)
              for (; b--; xc[i++] = 0)
                ;
            b = BASE - 1;
            for (; j > a; ) {
              if (xc[--j] < yc[j]) {
                for (i = j; i && !xc[--i]; xc[i] = b)
                  ;
                --xc[i];
                xc[j] += BASE;
              }
              xc[j] -= yc[j];
            }
            for (; xc[0] == 0; xc.splice(0, 1), --ye)
              ;
            if (!xc[0]) {
              y.s = ROUNDING_MODE == 3 ? -1 : 1;
              y.c = [y.e = 0];
              return y;
            }
            return normalise(y, xc, ye);
          };
          P.modulo = P.mod = function(y, b) {
            var q, s, x = this;
            y = new BigNumber3(y, b);
            if (!x.c || !y.s || y.c && !y.c[0]) {
              return new BigNumber3(NaN);
            } else if (!y.c || x.c && !x.c[0]) {
              return new BigNumber3(x);
            }
            if (MODULO_MODE == 9) {
              s = y.s;
              y.s = 1;
              q = div(x, y, 0, 3);
              y.s = s;
              q.s *= s;
            } else {
              q = div(x, y, 0, MODULO_MODE);
            }
            y = x.minus(q.times(y));
            if (!y.c[0] && MODULO_MODE == 1)
              y.s = x.s;
            return y;
          };
          P.multipliedBy = P.times = function(y, b) {
            var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc, base, sqrtBase, x = this, xc = x.c, yc = (y = new BigNumber3(y, b)).c;
            if (!xc || !yc || !xc[0] || !yc[0]) {
              if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
                y.c = y.e = y.s = null;
              } else {
                y.s *= x.s;
                if (!xc || !yc) {
                  y.c = y.e = null;
                } else {
                  y.c = [0];
                  y.e = 0;
                }
              }
              return y;
            }
            e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);
            y.s *= x.s;
            xcL = xc.length;
            ycL = yc.length;
            if (xcL < ycL)
              zc = xc, xc = yc, yc = zc, i = xcL, xcL = ycL, ycL = i;
            for (i = xcL + ycL, zc = []; i--; zc.push(0))
              ;
            base = BASE;
            sqrtBase = SQRT_BASE;
            for (i = ycL; --i >= 0; ) {
              c = 0;
              ylo = yc[i] % sqrtBase;
              yhi = yc[i] / sqrtBase | 0;
              for (k = xcL, j = i + k; j > i; ) {
                xlo = xc[--k] % sqrtBase;
                xhi = xc[k] / sqrtBase | 0;
                m = yhi * xlo + xhi * ylo;
                xlo = ylo * xlo + m % sqrtBase * sqrtBase + zc[j] + c;
                c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;
                zc[j--] = xlo % base;
              }
              zc[j] = c;
            }
            if (c) {
              ++e;
            } else {
              zc.splice(0, 1);
            }
            return normalise(y, zc, e);
          };
          P.negated = function() {
            var x = new BigNumber3(this);
            x.s = -x.s || null;
            return x;
          };
          P.plus = function(y, b) {
            var t, x = this, a = x.s;
            y = new BigNumber3(y, b);
            b = y.s;
            if (!a || !b)
              return new BigNumber3(NaN);
            if (a != b) {
              y.s = -b;
              return x.minus(y);
            }
            var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
            if (!xe || !ye) {
              if (!xc || !yc)
                return new BigNumber3(a / 0);
              if (!xc[0] || !yc[0])
                return yc[0] ? y : new BigNumber3(xc[0] ? x : a * 0);
            }
            xe = bitFloor(xe);
            ye = bitFloor(ye);
            xc = xc.slice();
            if (a = xe - ye) {
              if (a > 0) {
                ye = xe;
                t = yc;
              } else {
                a = -a;
                t = xc;
              }
              t.reverse();
              for (; a--; t.push(0))
                ;
              t.reverse();
            }
            a = xc.length;
            b = yc.length;
            if (a - b < 0)
              t = yc, yc = xc, xc = t, b = a;
            for (a = 0; b; ) {
              a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;
              xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;
            }
            if (a) {
              xc = [a].concat(xc);
              ++ye;
            }
            return normalise(y, xc, ye);
          };
          P.precision = P.sd = function(sd, rm) {
            var c, n, v, x = this;
            if (sd != null && sd !== !!sd) {
              intCheck(sd, 1, MAX);
              if (rm == null)
                rm = ROUNDING_MODE;
              else
                intCheck(rm, 0, 8);
              return round(new BigNumber3(x), sd, rm);
            }
            if (!(c = x.c))
              return null;
            v = c.length - 1;
            n = v * LOG_BASE + 1;
            if (v = c[v]) {
              for (; v % 10 == 0; v /= 10, n--)
                ;
              for (v = c[0]; v >= 10; v /= 10, n++)
                ;
            }
            if (sd && x.e + 1 > n)
              n = x.e + 1;
            return n;
          };
          P.shiftedBy = function(k) {
            intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
            return this.times("1e" + k);
          };
          P.squareRoot = P.sqrt = function() {
            var m, n, r, rep, t, x = this, c = x.c, s = x.s, e = x.e, dp = DECIMAL_PLACES + 4, half = new BigNumber3("0.5");
            if (s !== 1 || !c || !c[0]) {
              return new BigNumber3(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);
            }
            s = Math.sqrt(+valueOf(x));
            if (s == 0 || s == 1 / 0) {
              n = coeffToString(c);
              if ((n.length + e) % 2 == 0)
                n += "0";
              s = Math.sqrt(+n);
              e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);
              if (s == 1 / 0) {
                n = "5e" + e;
              } else {
                n = s.toExponential();
                n = n.slice(0, n.indexOf("e") + 1) + e;
              }
              r = new BigNumber3(n);
            } else {
              r = new BigNumber3(s + "");
            }
            if (r.c[0]) {
              e = r.e;
              s = e + dp;
              if (s < 3)
                s = 0;
              for (; ; ) {
                t = r;
                r = half.times(t.plus(div(x, t, dp, 1)));
                if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {
                  if (r.e < e)
                    --s;
                  n = n.slice(s - 3, s + 1);
                  if (n == "9999" || !rep && n == "4999") {
                    if (!rep) {
                      round(t, t.e + DECIMAL_PLACES + 2, 0);
                      if (t.times(t).eq(x)) {
                        r = t;
                        break;
                      }
                    }
                    dp += 4;
                    s += 4;
                    rep = 1;
                  } else {
                    if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
                      round(r, r.e + DECIMAL_PLACES + 2, 1);
                      m = !r.times(r).eq(x);
                    }
                    break;
                  }
                }
              }
            }
            return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);
          };
          P.toExponential = function(dp, rm) {
            if (dp != null) {
              intCheck(dp, 0, MAX);
              dp++;
            }
            return format(this, dp, rm, 1);
          };
          P.toFixed = function(dp, rm) {
            if (dp != null) {
              intCheck(dp, 0, MAX);
              dp = dp + this.e + 1;
            }
            return format(this, dp, rm);
          };
          P.toFormat = function(dp, rm, format2) {
            var str, x = this;
            if (format2 == null) {
              if (dp != null && rm && typeof rm == "object") {
                format2 = rm;
                rm = null;
              } else if (dp && typeof dp == "object") {
                format2 = dp;
                dp = rm = null;
              } else {
                format2 = FORMAT;
              }
            } else if (typeof format2 != "object") {
              throw Error(bignumberError + "Argument not an object: " + format2);
            }
            str = x.toFixed(dp, rm);
            if (x.c) {
              var i, arr = str.split("."), g1 = +format2.groupSize, g2 = +format2.secondaryGroupSize, groupSeparator = format2.groupSeparator || "", intPart = arr[0], fractionPart = arr[1], isNeg = x.s < 0, intDigits = isNeg ? intPart.slice(1) : intPart, len = intDigits.length;
              if (g2)
                i = g1, g1 = g2, g2 = i, len -= i;
              if (g1 > 0 && len > 0) {
                i = len % g1 || g1;
                intPart = intDigits.substr(0, i);
                for (; i < len; i += g1)
                  intPart += groupSeparator + intDigits.substr(i, g1);
                if (g2 > 0)
                  intPart += groupSeparator + intDigits.slice(i);
                if (isNeg)
                  intPart = "-" + intPart;
              }
              str = fractionPart ? intPart + (format2.decimalSeparator || "") + ((g2 = +format2.fractionGroupSize) ? fractionPart.replace(new RegExp("\\d{" + g2 + "}\\B", "g"), "$&" + (format2.fractionGroupSeparator || "")) : fractionPart) : intPart;
            }
            return (format2.prefix || "") + str + (format2.suffix || "");
          };
          P.toFraction = function(md) {
            var d, d0, d1, d2, e, exp, n, n0, n1, q, r, s, x = this, xc = x.c;
            if (md != null) {
              n = new BigNumber3(md);
              if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {
                throw Error(bignumberError + "Argument " + (n.isInteger() ? "out of range: " : "not an integer: ") + valueOf(n));
              }
            }
            if (!xc)
              return new BigNumber3(x);
            d = new BigNumber3(ONE);
            n1 = d0 = new BigNumber3(ONE);
            d1 = n0 = new BigNumber3(ONE);
            s = coeffToString(xc);
            e = d.e = s.length - x.e - 1;
            d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
            md = !md || n.comparedTo(d) > 0 ? e > 0 ? d : n1 : n;
            exp = MAX_EXP;
            MAX_EXP = 1 / 0;
            n = new BigNumber3(s);
            n0.c[0] = 0;
            for (; ; ) {
              q = div(n, d, 0, 1);
              d2 = d0.plus(q.times(d1));
              if (d2.comparedTo(md) == 1)
                break;
              d0 = d1;
              d1 = d2;
              n1 = n0.plus(q.times(d2 = n1));
              n0 = d2;
              d = n.minus(q.times(d2 = d));
              n = d2;
            }
            d2 = div(md.minus(d0), d1, 0, 1);
            n0 = n0.plus(d2.times(n1));
            d0 = d0.plus(d2.times(d1));
            n0.s = n1.s = x.s;
            e = e * 2;
            r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(div(n0, d0, e, ROUNDING_MODE).minus(x).abs()) < 1 ? [n1, d1] : [n0, d0];
            MAX_EXP = exp;
            return r;
          };
          P.toNumber = function() {
            return +valueOf(this);
          };
          P.toPrecision = function(sd, rm) {
            if (sd != null)
              intCheck(sd, 1, MAX);
            return format(this, sd, rm, 2);
          };
          P.toString = function(b) {
            var str, n = this, s = n.s, e = n.e;
            if (e === null) {
              if (s) {
                str = "Infinity";
                if (s < 0)
                  str = "-" + str;
              } else {
                str = "NaN";
              }
            } else {
              if (b == null) {
                str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(coeffToString(n.c), e) : toFixedPoint(coeffToString(n.c), e, "0");
              } else if (b === 10 && alphabetHasNormalDecimalDigits) {
                n = round(new BigNumber3(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);
                str = toFixedPoint(coeffToString(n.c), n.e, "0");
              } else {
                intCheck(b, 2, ALPHABET.length, "Base");
                str = convertBase(toFixedPoint(coeffToString(n.c), e, "0"), 10, b, s, true);
              }
              if (s < 0 && n.c[0])
                str = "-" + str;
            }
            return str;
          };
          P.valueOf = P.toJSON = function() {
            return valueOf(this);
          };
          P._isBigNumber = true;
          if (configObject != null)
            BigNumber3.set(configObject);
          return BigNumber3;
        }
        function bitFloor(n) {
          var i = n | 0;
          return n > 0 || n === i ? i : i - 1;
        }
        function coeffToString(a) {
          var s, z, i = 1, j = a.length, r = a[0] + "";
          for (; i < j; ) {
            s = a[i++] + "";
            z = LOG_BASE - s.length;
            for (; z--; s = "0" + s)
              ;
            r += s;
          }
          for (j = r.length; r.charCodeAt(--j) === 48; )
            ;
          return r.slice(0, j + 1 || 1);
        }
        function compare(x, y) {
          var a, b, xc = x.c, yc = y.c, i = x.s, j = y.s, k = x.e, l = y.e;
          if (!i || !j)
            return null;
          a = xc && !xc[0];
          b = yc && !yc[0];
          if (a || b)
            return a ? b ? 0 : -j : i;
          if (i != j)
            return i;
          a = i < 0;
          b = k == l;
          if (!xc || !yc)
            return b ? 0 : !xc ^ a ? 1 : -1;
          if (!b)
            return k > l ^ a ? 1 : -1;
          j = (k = xc.length) < (l = yc.length) ? k : l;
          for (i = 0; i < j; i++)
            if (xc[i] != yc[i])
              return xc[i] > yc[i] ^ a ? 1 : -1;
          return k == l ? 0 : k > l ^ a ? 1 : -1;
        }
        function intCheck(n, min, max, name) {
          if (n < min || n > max || n !== mathfloor(n)) {
            throw Error(bignumberError + (name || "Argument") + (typeof n == "number" ? n < min || n > max ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(n));
          }
        }
        function isOdd(n) {
          var k = n.c.length - 1;
          return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;
        }
        function toExponential(str, e) {
          return (str.length > 1 ? str.charAt(0) + "." + str.slice(1) : str) + (e < 0 ? "e" : "e+") + e;
        }
        function toFixedPoint(str, e, z) {
          var len, zs;
          if (e < 0) {
            for (zs = z + "."; ++e; zs += z)
              ;
            str = zs + str;
          } else {
            len = str.length;
            if (++e > len) {
              for (zs = z, e -= len; --e; zs += z)
                ;
              str += zs;
            } else if (e < len) {
              str = str.slice(0, e) + "." + str.slice(e);
            }
          }
          return str;
        }
        BigNumber2 = clone();
        BigNumber2["default"] = BigNumber2.BigNumber = BigNumber2;
        if (typeof define == "function" && define.amd) {
          define(function() {
            return BigNumber2;
          });
        } else if (typeof module2 != "undefined" && module2.exports) {
          module2.exports = BigNumber2;
        } else {
          if (!globalObject) {
            globalObject = typeof self != "undefined" && self ? self : window;
          }
          globalObject.BigNumber = BigNumber2;
        }
      })(exports);
    }
  });

  // node_modules/arweave/node/ar.js
  var require_ar = __commonJS({
    "node_modules/arweave/node/ar.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var bignumber_js_1 = require_bignumber();
      var Ar = class {
        constructor() {
          this.BigNum = (value, decimals) => {
            let instance = bignumber_js_1.BigNumber.clone({ DECIMAL_PLACES: decimals });
            return new instance(value);
          };
        }
        winstonToAr(winstonString, { formatted = false, decimals = 12, trim = true } = {}) {
          let number = this.stringToBigNum(winstonString, decimals).shiftedBy(-12);
          return formatted ? number.toFormat(decimals) : number.toFixed(decimals);
        }
        arToWinston(arString, { formatted = false } = {}) {
          let number = this.stringToBigNum(arString).shiftedBy(12);
          return formatted ? number.toFormat() : number.toFixed(0);
        }
        compare(winstonStringA, winstonStringB) {
          let a = this.stringToBigNum(winstonStringA);
          let b = this.stringToBigNum(winstonStringB);
          return a.comparedTo(b);
        }
        isEqual(winstonStringA, winstonStringB) {
          return this.compare(winstonStringA, winstonStringB) === 0;
        }
        isLessThan(winstonStringA, winstonStringB) {
          let a = this.stringToBigNum(winstonStringA);
          let b = this.stringToBigNum(winstonStringB);
          return a.isLessThan(b);
        }
        isGreaterThan(winstonStringA, winstonStringB) {
          let a = this.stringToBigNum(winstonStringA);
          let b = this.stringToBigNum(winstonStringB);
          return a.isGreaterThan(b);
        }
        add(winstonStringA, winstonStringB) {
          let a = this.stringToBigNum(winstonStringA);
          let b = this.stringToBigNum(winstonStringB);
          return a.plus(winstonStringB).toFixed(0);
        }
        sub(winstonStringA, winstonStringB) {
          let a = this.stringToBigNum(winstonStringA);
          let b = this.stringToBigNum(winstonStringB);
          return a.minus(winstonStringB).toFixed(0);
        }
        stringToBigNum(stringValue, decimalPlaces = 12) {
          return this.BigNum(stringValue, decimalPlaces);
        }
      };
      exports.default = Ar;
    }
  });

  // node_modules/axios/lib/helpers/bind.js
  var require_bind = __commonJS({
    "node_modules/axios/lib/helpers/bind.js"(exports, module2) {
      "use strict";
      module2.exports = function bind(fn, thisArg) {
        return function wrap() {
          var args = new Array(arguments.length);
          for (var i = 0; i < args.length; i++) {
            args[i] = arguments[i];
          }
          return fn.apply(thisArg, args);
        };
      };
    }
  });

  // node_modules/axios/lib/utils.js
  var require_utils2 = __commonJS({
    "node_modules/axios/lib/utils.js"(exports, module2) {
      "use strict";
      var bind = require_bind();
      var toString2 = Object.prototype.toString;
      function isArray(val) {
        return toString2.call(val) === "[object Array]";
      }
      function isUndefined(val) {
        return typeof val === "undefined";
      }
      function isBuffer(val) {
        return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && typeof val.constructor.isBuffer === "function" && val.constructor.isBuffer(val);
      }
      function isArrayBuffer(val) {
        return toString2.call(val) === "[object ArrayBuffer]";
      }
      function isFormData(val) {
        return typeof FormData !== "undefined" && val instanceof FormData;
      }
      function isArrayBufferView(val) {
        var result;
        if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
          result = ArrayBuffer.isView(val);
        } else {
          result = val && val.buffer && val.buffer instanceof ArrayBuffer;
        }
        return result;
      }
      function isString(val) {
        return typeof val === "string";
      }
      function isNumber(val) {
        return typeof val === "number";
      }
      function isObject2(val) {
        return val !== null && typeof val === "object";
      }
      function isPlainObject(val) {
        if (toString2.call(val) !== "[object Object]") {
          return false;
        }
        var prototype = Object.getPrototypeOf(val);
        return prototype === null || prototype === Object.prototype;
      }
      function isDate(val) {
        return toString2.call(val) === "[object Date]";
      }
      function isFile(val) {
        return toString2.call(val) === "[object File]";
      }
      function isBlob2(val) {
        return toString2.call(val) === "[object Blob]";
      }
      function isFunction(val) {
        return toString2.call(val) === "[object Function]";
      }
      function isStream(val) {
        return isObject2(val) && isFunction(val.pipe);
      }
      function isURLSearchParams(val) {
        return typeof URLSearchParams !== "undefined" && val instanceof URLSearchParams;
      }
      function trim(str) {
        return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
      }
      function isStandardBrowserEnv() {
        if (typeof navigator !== "undefined" && (navigator.product === "ReactNative" || navigator.product === "NativeScript" || navigator.product === "NS")) {
          return false;
        }
        return typeof window !== "undefined" && typeof document !== "undefined";
      }
      function forEach(obj, fn) {
        if (obj === null || typeof obj === "undefined") {
          return;
        }
        if (typeof obj !== "object") {
          obj = [obj];
        }
        if (isArray(obj)) {
          for (var i = 0, l = obj.length; i < l; i++) {
            fn.call(null, obj[i], i, obj);
          }
        } else {
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              fn.call(null, obj[key], key, obj);
            }
          }
        }
      }
      function merge() {
        var result = {};
        function assignValue(val, key) {
          if (isPlainObject(result[key]) && isPlainObject(val)) {
            result[key] = merge(result[key], val);
          } else if (isPlainObject(val)) {
            result[key] = merge({}, val);
          } else if (isArray(val)) {
            result[key] = val.slice();
          } else {
            result[key] = val;
          }
        }
        for (var i = 0, l = arguments.length; i < l; i++) {
          forEach(arguments[i], assignValue);
        }
        return result;
      }
      function extend(a, b, thisArg) {
        forEach(b, function assignValue(val, key) {
          if (thisArg && typeof val === "function") {
            a[key] = bind(val, thisArg);
          } else {
            a[key] = val;
          }
        });
        return a;
      }
      function stripBOM(content) {
        if (content.charCodeAt(0) === 65279) {
          content = content.slice(1);
        }
        return content;
      }
      module2.exports = {
        isArray,
        isArrayBuffer,
        isBuffer,
        isFormData,
        isArrayBufferView,
        isString,
        isNumber,
        isObject: isObject2,
        isPlainObject,
        isUndefined,
        isDate,
        isFile,
        isBlob: isBlob2,
        isFunction,
        isStream,
        isURLSearchParams,
        isStandardBrowserEnv,
        forEach,
        merge,
        extend,
        trim,
        stripBOM
      };
    }
  });

  // node_modules/axios/lib/helpers/buildURL.js
  var require_buildURL = __commonJS({
    "node_modules/axios/lib/helpers/buildURL.js"(exports, module2) {
      "use strict";
      var utils = require_utils2();
      function encode(val) {
        return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
      }
      module2.exports = function buildURL(url, params, paramsSerializer) {
        if (!params) {
          return url;
        }
        var serializedParams;
        if (paramsSerializer) {
          serializedParams = paramsSerializer(params);
        } else if (utils.isURLSearchParams(params)) {
          serializedParams = params.toString();
        } else {
          var parts = [];
          utils.forEach(params, function serialize(val, key) {
            if (val === null || typeof val === "undefined") {
              return;
            }
            if (utils.isArray(val)) {
              key = key + "[]";
            } else {
              val = [val];
            }
            utils.forEach(val, function parseValue(v) {
              if (utils.isDate(v)) {
                v = v.toISOString();
              } else if (utils.isObject(v)) {
                v = JSON.stringify(v);
              }
              parts.push(encode(key) + "=" + encode(v));
            });
          });
          serializedParams = parts.join("&");
        }
        if (serializedParams) {
          var hashmarkIndex = url.indexOf("#");
          if (hashmarkIndex !== -1) {
            url = url.slice(0, hashmarkIndex);
          }
          url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
        }
        return url;
      };
    }
  });

  // node_modules/axios/lib/core/InterceptorManager.js
  var require_InterceptorManager = __commonJS({
    "node_modules/axios/lib/core/InterceptorManager.js"(exports, module2) {
      "use strict";
      var utils = require_utils2();
      function InterceptorManager() {
        this.handlers = [];
      }
      InterceptorManager.prototype.use = function use(fulfilled, rejected, options) {
        this.handlers.push({
          fulfilled,
          rejected,
          synchronous: options ? options.synchronous : false,
          runWhen: options ? options.runWhen : null
        });
        return this.handlers.length - 1;
      };
      InterceptorManager.prototype.eject = function eject(id) {
        if (this.handlers[id]) {
          this.handlers[id] = null;
        }
      };
      InterceptorManager.prototype.forEach = function forEach(fn) {
        utils.forEach(this.handlers, function forEachHandler(h) {
          if (h !== null) {
            fn(h);
          }
        });
      };
      module2.exports = InterceptorManager;
    }
  });

  // node_modules/axios/lib/helpers/normalizeHeaderName.js
  var require_normalizeHeaderName = __commonJS({
    "node_modules/axios/lib/helpers/normalizeHeaderName.js"(exports, module2) {
      "use strict";
      var utils = require_utils2();
      module2.exports = function normalizeHeaderName(headers, normalizedName) {
        utils.forEach(headers, function processHeader(value, name) {
          if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
            headers[normalizedName] = value;
            delete headers[name];
          }
        });
      };
    }
  });

  // node_modules/axios/lib/core/enhanceError.js
  var require_enhanceError = __commonJS({
    "node_modules/axios/lib/core/enhanceError.js"(exports, module2) {
      "use strict";
      module2.exports = function enhanceError(error, config2, code, request, response) {
        error.config = config2;
        if (code) {
          error.code = code;
        }
        error.request = request;
        error.response = response;
        error.isAxiosError = true;
        error.toJSON = function toJSON() {
          return {
            message: this.message,
            name: this.name,
            description: this.description,
            number: this.number,
            fileName: this.fileName,
            lineNumber: this.lineNumber,
            columnNumber: this.columnNumber,
            stack: this.stack,
            config: this.config,
            code: this.code,
            status: this.response && this.response.status ? this.response.status : null
          };
        };
        return error;
      };
    }
  });

  // node_modules/axios/lib/core/createError.js
  var require_createError = __commonJS({
    "node_modules/axios/lib/core/createError.js"(exports, module2) {
      "use strict";
      var enhanceError = require_enhanceError();
      module2.exports = function createError(message, config2, code, request, response) {
        var error = new Error(message);
        return enhanceError(error, config2, code, request, response);
      };
    }
  });

  // node_modules/axios/lib/core/settle.js
  var require_settle = __commonJS({
    "node_modules/axios/lib/core/settle.js"(exports, module2) {
      "use strict";
      var createError = require_createError();
      module2.exports = function settle(resolve, reject, response) {
        var validateStatus = response.config.validateStatus;
        if (!response.status || !validateStatus || validateStatus(response.status)) {
          resolve(response);
        } else {
          reject(createError("Request failed with status code " + response.status, response.config, null, response.request, response));
        }
      };
    }
  });

  // node_modules/axios/lib/helpers/cookies.js
  var require_cookies = __commonJS({
    "node_modules/axios/lib/helpers/cookies.js"(exports, module2) {
      "use strict";
      var utils = require_utils2();
      module2.exports = utils.isStandardBrowserEnv() ? function standardBrowserEnv() {
        return {
          write: function write(name, value, expires, path2, domain, secure) {
            var cookie = [];
            cookie.push(name + "=" + encodeURIComponent(value));
            if (utils.isNumber(expires)) {
              cookie.push("expires=" + new Date(expires).toGMTString());
            }
            if (utils.isString(path2)) {
              cookie.push("path=" + path2);
            }
            if (utils.isString(domain)) {
              cookie.push("domain=" + domain);
            }
            if (secure === true) {
              cookie.push("secure");
            }
            document.cookie = cookie.join("; ");
          },
          read: function read(name) {
            var match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
            return match ? decodeURIComponent(match[3]) : null;
          },
          remove: function remove(name) {
            this.write(name, "", Date.now() - 864e5);
          }
        };
      }() : function nonStandardBrowserEnv() {
        return {
          write: function write() {
          },
          read: function read() {
            return null;
          },
          remove: function remove() {
          }
        };
      }();
    }
  });

  // node_modules/axios/lib/helpers/isAbsoluteURL.js
  var require_isAbsoluteURL = __commonJS({
    "node_modules/axios/lib/helpers/isAbsoluteURL.js"(exports, module2) {
      "use strict";
      module2.exports = function isAbsoluteURL(url) {
        return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
      };
    }
  });

  // node_modules/axios/lib/helpers/combineURLs.js
  var require_combineURLs = __commonJS({
    "node_modules/axios/lib/helpers/combineURLs.js"(exports, module2) {
      "use strict";
      module2.exports = function combineURLs(baseURL, relativeURL) {
        return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
      };
    }
  });

  // node_modules/axios/lib/core/buildFullPath.js
  var require_buildFullPath = __commonJS({
    "node_modules/axios/lib/core/buildFullPath.js"(exports, module2) {
      "use strict";
      var isAbsoluteURL = require_isAbsoluteURL();
      var combineURLs = require_combineURLs();
      module2.exports = function buildFullPath(baseURL, requestedURL) {
        if (baseURL && !isAbsoluteURL(requestedURL)) {
          return combineURLs(baseURL, requestedURL);
        }
        return requestedURL;
      };
    }
  });

  // node_modules/axios/lib/helpers/parseHeaders.js
  var require_parseHeaders = __commonJS({
    "node_modules/axios/lib/helpers/parseHeaders.js"(exports, module2) {
      "use strict";
      var utils = require_utils2();
      var ignoreDuplicateOf = [
        "age",
        "authorization",
        "content-length",
        "content-type",
        "etag",
        "expires",
        "from",
        "host",
        "if-modified-since",
        "if-unmodified-since",
        "last-modified",
        "location",
        "max-forwards",
        "proxy-authorization",
        "referer",
        "retry-after",
        "user-agent"
      ];
      module2.exports = function parseHeaders(headers) {
        var parsed = {};
        var key;
        var val;
        var i;
        if (!headers) {
          return parsed;
        }
        utils.forEach(headers.split("\n"), function parser(line) {
          i = line.indexOf(":");
          key = utils.trim(line.substr(0, i)).toLowerCase();
          val = utils.trim(line.substr(i + 1));
          if (key) {
            if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
              return;
            }
            if (key === "set-cookie") {
              parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
            } else {
              parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
            }
          }
        });
        return parsed;
      };
    }
  });

  // node_modules/axios/lib/helpers/isURLSameOrigin.js
  var require_isURLSameOrigin = __commonJS({
    "node_modules/axios/lib/helpers/isURLSameOrigin.js"(exports, module2) {
      "use strict";
      var utils = require_utils2();
      module2.exports = utils.isStandardBrowserEnv() ? function standardBrowserEnv() {
        var msie = /(msie|trident)/i.test(navigator.userAgent);
        var urlParsingNode = document.createElement("a");
        var originURL;
        function resolveURL(url) {
          var href = url;
          if (msie) {
            urlParsingNode.setAttribute("href", href);
            href = urlParsingNode.href;
          }
          urlParsingNode.setAttribute("href", href);
          return {
            href: urlParsingNode.href,
            protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
            host: urlParsingNode.host,
            search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
            hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
            hostname: urlParsingNode.hostname,
            port: urlParsingNode.port,
            pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
          };
        }
        originURL = resolveURL(window.location.href);
        return function isURLSameOrigin(requestURL) {
          var parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;
          return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
        };
      }() : function nonStandardBrowserEnv() {
        return function isURLSameOrigin() {
          return true;
        };
      }();
    }
  });

  // node_modules/axios/lib/cancel/Cancel.js
  var require_Cancel = __commonJS({
    "node_modules/axios/lib/cancel/Cancel.js"(exports, module2) {
      "use strict";
      function Cancel(message) {
        this.message = message;
      }
      Cancel.prototype.toString = function toString2() {
        return "Cancel" + (this.message ? ": " + this.message : "");
      };
      Cancel.prototype.__CANCEL__ = true;
      module2.exports = Cancel;
    }
  });

  // node_modules/axios/lib/adapters/xhr.js
  var require_xhr = __commonJS({
    "node_modules/axios/lib/adapters/xhr.js"(exports, module2) {
      "use strict";
      var utils = require_utils2();
      var settle = require_settle();
      var cookies = require_cookies();
      var buildURL = require_buildURL();
      var buildFullPath = require_buildFullPath();
      var parseHeaders = require_parseHeaders();
      var isURLSameOrigin = require_isURLSameOrigin();
      var createError = require_createError();
      var defaults = require_defaults();
      var Cancel = require_Cancel();
      module2.exports = function xhrAdapter(config2) {
        return new Promise(function dispatchXhrRequest(resolve, reject) {
          var requestData = config2.data;
          var requestHeaders = config2.headers;
          var responseType = config2.responseType;
          var onCanceled;
          function done() {
            if (config2.cancelToken) {
              config2.cancelToken.unsubscribe(onCanceled);
            }
            if (config2.signal) {
              config2.signal.removeEventListener("abort", onCanceled);
            }
          }
          if (utils.isFormData(requestData)) {
            delete requestHeaders["Content-Type"];
          }
          var request = new XMLHttpRequest();
          if (config2.auth) {
            var username = config2.auth.username || "";
            var password = config2.auth.password ? unescape(encodeURIComponent(config2.auth.password)) : "";
            requestHeaders.Authorization = "Basic " + btoa(username + ":" + password);
          }
          var fullPath = buildFullPath(config2.baseURL, config2.url);
          request.open(config2.method.toUpperCase(), buildURL(fullPath, config2.params, config2.paramsSerializer), true);
          request.timeout = config2.timeout;
          function onloadend() {
            if (!request) {
              return;
            }
            var responseHeaders = "getAllResponseHeaders" in request ? parseHeaders(request.getAllResponseHeaders()) : null;
            var responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
            var response = {
              data: responseData,
              status: request.status,
              statusText: request.statusText,
              headers: responseHeaders,
              config: config2,
              request
            };
            settle(function _resolve(value) {
              resolve(value);
              done();
            }, function _reject(err) {
              reject(err);
              done();
            }, response);
            request = null;
          }
          if ("onloadend" in request) {
            request.onloadend = onloadend;
          } else {
            request.onreadystatechange = function handleLoad() {
              if (!request || request.readyState !== 4) {
                return;
              }
              if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
                return;
              }
              setTimeout(onloadend);
            };
          }
          request.onabort = function handleAbort() {
            if (!request) {
              return;
            }
            reject(createError("Request aborted", config2, "ECONNABORTED", request));
            request = null;
          };
          request.onerror = function handleError() {
            reject(createError("Network Error", config2, null, request));
            request = null;
          };
          request.ontimeout = function handleTimeout() {
            var timeoutErrorMessage = "timeout of " + config2.timeout + "ms exceeded";
            var transitional = config2.transitional || defaults.transitional;
            if (config2.timeoutErrorMessage) {
              timeoutErrorMessage = config2.timeoutErrorMessage;
            }
            reject(createError(timeoutErrorMessage, config2, transitional.clarifyTimeoutError ? "ETIMEDOUT" : "ECONNABORTED", request));
            request = null;
          };
          if (utils.isStandardBrowserEnv()) {
            var xsrfValue = (config2.withCredentials || isURLSameOrigin(fullPath)) && config2.xsrfCookieName ? cookies.read(config2.xsrfCookieName) : void 0;
            if (xsrfValue) {
              requestHeaders[config2.xsrfHeaderName] = xsrfValue;
            }
          }
          if ("setRequestHeader" in request) {
            utils.forEach(requestHeaders, function setRequestHeader(val, key) {
              if (typeof requestData === "undefined" && key.toLowerCase() === "content-type") {
                delete requestHeaders[key];
              } else {
                request.setRequestHeader(key, val);
              }
            });
          }
          if (!utils.isUndefined(config2.withCredentials)) {
            request.withCredentials = !!config2.withCredentials;
          }
          if (responseType && responseType !== "json") {
            request.responseType = config2.responseType;
          }
          if (typeof config2.onDownloadProgress === "function") {
            request.addEventListener("progress", config2.onDownloadProgress);
          }
          if (typeof config2.onUploadProgress === "function" && request.upload) {
            request.upload.addEventListener("progress", config2.onUploadProgress);
          }
          if (config2.cancelToken || config2.signal) {
            onCanceled = function(cancel) {
              if (!request) {
                return;
              }
              reject(!cancel || cancel && cancel.type ? new Cancel("canceled") : cancel);
              request.abort();
              request = null;
            };
            config2.cancelToken && config2.cancelToken.subscribe(onCanceled);
            if (config2.signal) {
              config2.signal.aborted ? onCanceled() : config2.signal.addEventListener("abort", onCanceled);
            }
          }
          if (!requestData) {
            requestData = null;
          }
          request.send(requestData);
        });
      };
    }
  });

  // node_modules/axios/lib/defaults.js
  var require_defaults = __commonJS({
    "node_modules/axios/lib/defaults.js"(exports, module2) {
      "use strict";
      var utils = require_utils2();
      var normalizeHeaderName = require_normalizeHeaderName();
      var enhanceError = require_enhanceError();
      var DEFAULT_CONTENT_TYPE = {
        "Content-Type": "application/x-www-form-urlencoded"
      };
      function setContentTypeIfUnset(headers, value) {
        if (!utils.isUndefined(headers) && utils.isUndefined(headers["Content-Type"])) {
          headers["Content-Type"] = value;
        }
      }
      function getDefaultAdapter() {
        var adapter;
        if (typeof XMLHttpRequest !== "undefined") {
          adapter = require_xhr();
        } else if (typeof process !== "undefined" && Object.prototype.toString.call(process) === "[object process]") {
          adapter = require_xhr();
        }
        return adapter;
      }
      function stringifySafely(rawValue, parser, encoder2) {
        if (utils.isString(rawValue)) {
          try {
            (parser || JSON.parse)(rawValue);
            return utils.trim(rawValue);
          } catch (e) {
            if (e.name !== "SyntaxError") {
              throw e;
            }
          }
        }
        return (encoder2 || JSON.stringify)(rawValue);
      }
      var defaults = {
        transitional: {
          silentJSONParsing: true,
          forcedJSONParsing: true,
          clarifyTimeoutError: false
        },
        adapter: getDefaultAdapter(),
        transformRequest: [function transformRequest(data, headers) {
          normalizeHeaderName(headers, "Accept");
          normalizeHeaderName(headers, "Content-Type");
          if (utils.isFormData(data) || utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) {
            return data;
          }
          if (utils.isArrayBufferView(data)) {
            return data.buffer;
          }
          if (utils.isURLSearchParams(data)) {
            setContentTypeIfUnset(headers, "application/x-www-form-urlencoded;charset=utf-8");
            return data.toString();
          }
          if (utils.isObject(data) || headers && headers["Content-Type"] === "application/json") {
            setContentTypeIfUnset(headers, "application/json");
            return stringifySafely(data);
          }
          return data;
        }],
        transformResponse: [function transformResponse(data) {
          var transitional = this.transitional || defaults.transitional;
          var silentJSONParsing = transitional && transitional.silentJSONParsing;
          var forcedJSONParsing = transitional && transitional.forcedJSONParsing;
          var strictJSONParsing = !silentJSONParsing && this.responseType === "json";
          if (strictJSONParsing || forcedJSONParsing && utils.isString(data) && data.length) {
            try {
              return JSON.parse(data);
            } catch (e) {
              if (strictJSONParsing) {
                if (e.name === "SyntaxError") {
                  throw enhanceError(e, this, "E_JSON_PARSE");
                }
                throw e;
              }
            }
          }
          return data;
        }],
        timeout: 0,
        xsrfCookieName: "XSRF-TOKEN",
        xsrfHeaderName: "X-XSRF-TOKEN",
        maxContentLength: -1,
        maxBodyLength: -1,
        validateStatus: function validateStatus(status) {
          return status >= 200 && status < 300;
        },
        headers: {
          common: {
            "Accept": "application/json, text/plain, */*"
          }
        }
      };
      utils.forEach(["delete", "get", "head"], function forEachMethodNoData(method) {
        defaults.headers[method] = {};
      });
      utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
        defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
      });
      module2.exports = defaults;
    }
  });

  // node_modules/axios/lib/core/transformData.js
  var require_transformData = __commonJS({
    "node_modules/axios/lib/core/transformData.js"(exports, module2) {
      "use strict";
      var utils = require_utils2();
      var defaults = require_defaults();
      module2.exports = function transformData(data, headers, fns) {
        var context = this || defaults;
        utils.forEach(fns, function transform(fn) {
          data = fn.call(context, data, headers);
        });
        return data;
      };
    }
  });

  // node_modules/axios/lib/cancel/isCancel.js
  var require_isCancel = __commonJS({
    "node_modules/axios/lib/cancel/isCancel.js"(exports, module2) {
      "use strict";
      module2.exports = function isCancel(value) {
        return !!(value && value.__CANCEL__);
      };
    }
  });

  // node_modules/axios/lib/core/dispatchRequest.js
  var require_dispatchRequest = __commonJS({
    "node_modules/axios/lib/core/dispatchRequest.js"(exports, module2) {
      "use strict";
      var utils = require_utils2();
      var transformData = require_transformData();
      var isCancel = require_isCancel();
      var defaults = require_defaults();
      var Cancel = require_Cancel();
      function throwIfCancellationRequested(config2) {
        if (config2.cancelToken) {
          config2.cancelToken.throwIfRequested();
        }
        if (config2.signal && config2.signal.aborted) {
          throw new Cancel("canceled");
        }
      }
      module2.exports = function dispatchRequest(config2) {
        throwIfCancellationRequested(config2);
        config2.headers = config2.headers || {};
        config2.data = transformData.call(config2, config2.data, config2.headers, config2.transformRequest);
        config2.headers = utils.merge(config2.headers.common || {}, config2.headers[config2.method] || {}, config2.headers);
        utils.forEach(["delete", "get", "head", "post", "put", "patch", "common"], function cleanHeaderConfig(method) {
          delete config2.headers[method];
        });
        var adapter = config2.adapter || defaults.adapter;
        return adapter(config2).then(function onAdapterResolution(response) {
          throwIfCancellationRequested(config2);
          response.data = transformData.call(config2, response.data, response.headers, config2.transformResponse);
          return response;
        }, function onAdapterRejection(reason) {
          if (!isCancel(reason)) {
            throwIfCancellationRequested(config2);
            if (reason && reason.response) {
              reason.response.data = transformData.call(config2, reason.response.data, reason.response.headers, config2.transformResponse);
            }
          }
          return Promise.reject(reason);
        });
      };
    }
  });

  // node_modules/axios/lib/core/mergeConfig.js
  var require_mergeConfig = __commonJS({
    "node_modules/axios/lib/core/mergeConfig.js"(exports, module2) {
      "use strict";
      var utils = require_utils2();
      module2.exports = function mergeConfig(config1, config2) {
        config2 = config2 || {};
        var config3 = {};
        function getMergedValue(target, source) {
          if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
            return utils.merge(target, source);
          } else if (utils.isPlainObject(source)) {
            return utils.merge({}, source);
          } else if (utils.isArray(source)) {
            return source.slice();
          }
          return source;
        }
        function mergeDeepProperties(prop) {
          if (!utils.isUndefined(config2[prop])) {
            return getMergedValue(config1[prop], config2[prop]);
          } else if (!utils.isUndefined(config1[prop])) {
            return getMergedValue(void 0, config1[prop]);
          }
        }
        function valueFromConfig2(prop) {
          if (!utils.isUndefined(config2[prop])) {
            return getMergedValue(void 0, config2[prop]);
          }
        }
        function defaultToConfig2(prop) {
          if (!utils.isUndefined(config2[prop])) {
            return getMergedValue(void 0, config2[prop]);
          } else if (!utils.isUndefined(config1[prop])) {
            return getMergedValue(void 0, config1[prop]);
          }
        }
        function mergeDirectKeys(prop) {
          if (prop in config2) {
            return getMergedValue(config1[prop], config2[prop]);
          } else if (prop in config1) {
            return getMergedValue(void 0, config1[prop]);
          }
        }
        var mergeMap = {
          "url": valueFromConfig2,
          "method": valueFromConfig2,
          "data": valueFromConfig2,
          "baseURL": defaultToConfig2,
          "transformRequest": defaultToConfig2,
          "transformResponse": defaultToConfig2,
          "paramsSerializer": defaultToConfig2,
          "timeout": defaultToConfig2,
          "timeoutMessage": defaultToConfig2,
          "withCredentials": defaultToConfig2,
          "adapter": defaultToConfig2,
          "responseType": defaultToConfig2,
          "xsrfCookieName": defaultToConfig2,
          "xsrfHeaderName": defaultToConfig2,
          "onUploadProgress": defaultToConfig2,
          "onDownloadProgress": defaultToConfig2,
          "decompress": defaultToConfig2,
          "maxContentLength": defaultToConfig2,
          "maxBodyLength": defaultToConfig2,
          "transport": defaultToConfig2,
          "httpAgent": defaultToConfig2,
          "httpsAgent": defaultToConfig2,
          "cancelToken": defaultToConfig2,
          "socketPath": defaultToConfig2,
          "responseEncoding": defaultToConfig2,
          "validateStatus": mergeDirectKeys
        };
        utils.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {
          var merge = mergeMap[prop] || mergeDeepProperties;
          var configValue = merge(prop);
          utils.isUndefined(configValue) && merge !== mergeDirectKeys || (config3[prop] = configValue);
        });
        return config3;
      };
    }
  });

  // node_modules/axios/lib/env/data.js
  var require_data = __commonJS({
    "node_modules/axios/lib/env/data.js"(exports, module2) {
      module2.exports = {
        "version": "0.22.0"
      };
    }
  });

  // node_modules/axios/lib/helpers/validator.js
  var require_validator = __commonJS({
    "node_modules/axios/lib/helpers/validator.js"(exports, module2) {
      "use strict";
      var VERSION = require_data().version;
      var validators = {};
      ["object", "boolean", "number", "function", "string", "symbol"].forEach(function(type, i) {
        validators[type] = function validator(thing) {
          return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
        };
      });
      var deprecatedWarnings = {};
      validators.transitional = function transitional(validator, version, message) {
        function formatMessage(opt, desc2) {
          return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc2 + (message ? ". " + message : "");
        }
        return function(value, opt, opts) {
          if (validator === false) {
            throw new Error(formatMessage(opt, " has been removed" + (version ? " in " + version : "")));
          }
          if (version && !deprecatedWarnings[opt]) {
            deprecatedWarnings[opt] = true;
            console.warn(formatMessage(opt, " has been deprecated since v" + version + " and will be removed in the near future"));
          }
          return validator ? validator(value, opt, opts) : true;
        };
      };
      function assertOptions(options, schema, allowUnknown) {
        if (typeof options !== "object") {
          throw new TypeError("options must be an object");
        }
        var keys = Object.keys(options);
        var i = keys.length;
        while (i-- > 0) {
          var opt = keys[i];
          var validator = schema[opt];
          if (validator) {
            var value = options[opt];
            var result = value === void 0 || validator(value, opt, options);
            if (result !== true) {
              throw new TypeError("option " + opt + " must be " + result);
            }
            continue;
          }
          if (allowUnknown !== true) {
            throw Error("Unknown option " + opt);
          }
        }
      }
      module2.exports = {
        assertOptions,
        validators
      };
    }
  });

  // node_modules/axios/lib/core/Axios.js
  var require_Axios = __commonJS({
    "node_modules/axios/lib/core/Axios.js"(exports, module2) {
      "use strict";
      var utils = require_utils2();
      var buildURL = require_buildURL();
      var InterceptorManager = require_InterceptorManager();
      var dispatchRequest = require_dispatchRequest();
      var mergeConfig = require_mergeConfig();
      var validator = require_validator();
      var validators = validator.validators;
      function Axios(instanceConfig) {
        this.defaults = instanceConfig;
        this.interceptors = {
          request: new InterceptorManager(),
          response: new InterceptorManager()
        };
      }
      Axios.prototype.request = function request(config2) {
        if (typeof config2 === "string") {
          config2 = arguments[1] || {};
          config2.url = arguments[0];
        } else {
          config2 = config2 || {};
        }
        config2 = mergeConfig(this.defaults, config2);
        if (config2.method) {
          config2.method = config2.method.toLowerCase();
        } else if (this.defaults.method) {
          config2.method = this.defaults.method.toLowerCase();
        } else {
          config2.method = "get";
        }
        var transitional = config2.transitional;
        if (transitional !== void 0) {
          validator.assertOptions(transitional, {
            silentJSONParsing: validators.transitional(validators.boolean),
            forcedJSONParsing: validators.transitional(validators.boolean),
            clarifyTimeoutError: validators.transitional(validators.boolean)
          }, false);
        }
        var requestInterceptorChain = [];
        var synchronousRequestInterceptors = true;
        this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
          if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config2) === false) {
            return;
          }
          synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
          requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
        });
        var responseInterceptorChain = [];
        this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
          responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
        });
        var promise;
        if (!synchronousRequestInterceptors) {
          var chain = [dispatchRequest, void 0];
          Array.prototype.unshift.apply(chain, requestInterceptorChain);
          chain = chain.concat(responseInterceptorChain);
          promise = Promise.resolve(config2);
          while (chain.length) {
            promise = promise.then(chain.shift(), chain.shift());
          }
          return promise;
        }
        var newConfig = config2;
        while (requestInterceptorChain.length) {
          var onFulfilled = requestInterceptorChain.shift();
          var onRejected = requestInterceptorChain.shift();
          try {
            newConfig = onFulfilled(newConfig);
          } catch (error) {
            onRejected(error);
            break;
          }
        }
        try {
          promise = dispatchRequest(newConfig);
        } catch (error) {
          return Promise.reject(error);
        }
        while (responseInterceptorChain.length) {
          promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
        }
        return promise;
      };
      Axios.prototype.getUri = function getUri(config2) {
        config2 = mergeConfig(this.defaults, config2);
        return buildURL(config2.url, config2.params, config2.paramsSerializer).replace(/^\?/, "");
      };
      utils.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
        Axios.prototype[method] = function(url, config2) {
          return this.request(mergeConfig(config2 || {}, {
            method,
            url,
            data: (config2 || {}).data
          }));
        };
      });
      utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
        Axios.prototype[method] = function(url, data, config2) {
          return this.request(mergeConfig(config2 || {}, {
            method,
            url,
            data
          }));
        };
      });
      module2.exports = Axios;
    }
  });

  // node_modules/axios/lib/cancel/CancelToken.js
  var require_CancelToken = __commonJS({
    "node_modules/axios/lib/cancel/CancelToken.js"(exports, module2) {
      "use strict";
      var Cancel = require_Cancel();
      function CancelToken(executor) {
        if (typeof executor !== "function") {
          throw new TypeError("executor must be a function.");
        }
        var resolvePromise;
        this.promise = new Promise(function promiseExecutor(resolve) {
          resolvePromise = resolve;
        });
        var token = this;
        this.promise.then(function(cancel) {
          if (!token._listeners)
            return;
          var i;
          var l = token._listeners.length;
          for (i = 0; i < l; i++) {
            token._listeners[i](cancel);
          }
          token._listeners = null;
        });
        this.promise.then = function(onfulfilled) {
          var _resolve;
          var promise = new Promise(function(resolve) {
            token.subscribe(resolve);
            _resolve = resolve;
          }).then(onfulfilled);
          promise.cancel = function reject() {
            token.unsubscribe(_resolve);
          };
          return promise;
        };
        executor(function cancel(message) {
          if (token.reason) {
            return;
          }
          token.reason = new Cancel(message);
          resolvePromise(token.reason);
        });
      }
      CancelToken.prototype.throwIfRequested = function throwIfRequested() {
        if (this.reason) {
          throw this.reason;
        }
      };
      CancelToken.prototype.subscribe = function subscribe(listener) {
        if (this.reason) {
          listener(this.reason);
          return;
        }
        if (this._listeners) {
          this._listeners.push(listener);
        } else {
          this._listeners = [listener];
        }
      };
      CancelToken.prototype.unsubscribe = function unsubscribe(listener) {
        if (!this._listeners) {
          return;
        }
        var index = this._listeners.indexOf(listener);
        if (index !== -1) {
          this._listeners.splice(index, 1);
        }
      };
      CancelToken.source = function source() {
        var cancel;
        var token = new CancelToken(function executor(c) {
          cancel = c;
        });
        return {
          token,
          cancel
        };
      };
      module2.exports = CancelToken;
    }
  });

  // node_modules/axios/lib/helpers/spread.js
  var require_spread = __commonJS({
    "node_modules/axios/lib/helpers/spread.js"(exports, module2) {
      "use strict";
      module2.exports = function spread(callback) {
        return function wrap(arr) {
          return callback.apply(null, arr);
        };
      };
    }
  });

  // node_modules/axios/lib/helpers/isAxiosError.js
  var require_isAxiosError = __commonJS({
    "node_modules/axios/lib/helpers/isAxiosError.js"(exports, module2) {
      "use strict";
      module2.exports = function isAxiosError(payload) {
        return typeof payload === "object" && payload.isAxiosError === true;
      };
    }
  });

  // node_modules/axios/lib/axios.js
  var require_axios = __commonJS({
    "node_modules/axios/lib/axios.js"(exports, module2) {
      "use strict";
      var utils = require_utils2();
      var bind = require_bind();
      var Axios = require_Axios();
      var mergeConfig = require_mergeConfig();
      var defaults = require_defaults();
      function createInstance(defaultConfig) {
        var context = new Axios(defaultConfig);
        var instance = bind(Axios.prototype.request, context);
        utils.extend(instance, Axios.prototype, context);
        utils.extend(instance, context);
        instance.create = function create(instanceConfig) {
          return createInstance(mergeConfig(defaultConfig, instanceConfig));
        };
        return instance;
      }
      var axios2 = createInstance(defaults);
      axios2.Axios = Axios;
      axios2.Cancel = require_Cancel();
      axios2.CancelToken = require_CancelToken();
      axios2.isCancel = require_isCancel();
      axios2.VERSION = require_data().version;
      axios2.all = function all(promises) {
        return Promise.all(promises);
      };
      axios2.spread = require_spread();
      axios2.isAxiosError = require_isAxiosError();
      module2.exports = axios2;
      module2.exports.default = axios2;
    }
  });

  // node_modules/axios/index.js
  var require_axios2 = __commonJS({
    "node_modules/axios/index.js"(exports, module2) {
      module2.exports = require_axios();
    }
  });

  // node_modules/arweave/node/lib/api.js
  var require_api = __commonJS({
    "node_modules/arweave/node/lib/api.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      var axios_1 = __importDefault(require_axios2());
      var Api = class {
        constructor(config2) {
          this.METHOD_GET = "GET";
          this.METHOD_POST = "POST";
          this.applyConfig(config2);
        }
        applyConfig(config2) {
          this.config = this.mergeDefaults(config2);
        }
        getConfig() {
          return this.config;
        }
        mergeDefaults(config2) {
          const protocol = config2.protocol || "http";
          const port = config2.port || (protocol === "https" ? 443 : 80);
          return {
            host: config2.host || "127.0.0.1",
            protocol,
            port,
            timeout: config2.timeout || 2e4,
            logging: config2.logging || false,
            logger: config2.logger || console.log
          };
        }
        async get(endpoint, config2) {
          try {
            return await this.request().get(endpoint, config2);
          } catch (error) {
            if (error.response && error.response.status) {
              return error.response;
            }
            throw error;
          }
        }
        async post(endpoint, body, config2) {
          try {
            return await this.request().post(endpoint, body, config2);
          } catch (error) {
            if (error.response && error.response.status) {
              return error.response;
            }
            throw error;
          }
        }
        request() {
          let instance = axios_1.default.create({
            baseURL: `${this.config.protocol}://${this.config.host}:${this.config.port}`,
            timeout: this.config.timeout,
            maxContentLength: 1024 * 1024 * 512
          });
          if (this.config.logging) {
            instance.interceptors.request.use((request) => {
              this.config.logger(`Requesting: ${request.baseURL}/${request.url}`);
              return request;
            });
            instance.interceptors.response.use((response) => {
              this.config.logger(`Response:   ${response.config.url} - ${response.status}`);
              return response;
            });
          }
          return instance;
        }
      };
      exports.default = Api;
    }
  });

  // node_modules/arweave/node/network.js
  var require_network = __commonJS({
    "node_modules/arweave/node/network.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var Network = class {
        constructor(api) {
          this.api = api;
        }
        getInfo() {
          return this.api.get(`info`).then((response) => {
            return response.data;
          });
        }
        getPeers() {
          return this.api.get(`peers`).then((response) => {
            return response.data;
          });
        }
      };
      exports.default = Network;
    }
  });

  // node_modules/arweave/node/lib/error.js
  var require_error = __commonJS({
    "node_modules/arweave/node/lib/error.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getError = void 0;
      var ArweaveError = class extends Error {
        constructor(type, optional = {}) {
          if (optional.message) {
            super(optional.message);
          } else {
            super();
          }
          this.type = type;
          this.response = optional.response;
        }
        getType() {
          return this.type;
        }
      };
      exports.default = ArweaveError;
      function getError(resp) {
        let data = resp.data;
        if (typeof resp.data === "string") {
          try {
            data = JSON.parse(resp.data);
          } catch (e) {
          }
        }
        if (resp.data instanceof ArrayBuffer || resp.data instanceof Uint8Array) {
          try {
            data = JSON.parse(data.toString());
          } catch (e) {
          }
        }
        return data ? data.error || data : resp.statusText || "unknown";
      }
      exports.getError = getError;
    }
  });

  // node_modules/arweave/node/lib/merkle.js
  var require_merkle = __commonJS({
    "node_modules/arweave/node/lib/merkle.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.debug = exports.validatePath = exports.arrayCompare = exports.bufferToInt = exports.intToBuffer = exports.arrayFlatten = exports.generateProofs = exports.buildLayers = exports.generateTransactionChunks = exports.generateTree = exports.computeRootHash = exports.generateLeaves = exports.chunkData = exports.MIN_CHUNK_SIZE = exports.MAX_CHUNK_SIZE = void 0;
      var common_1 = __importDefault(require_common());
      var utils_1 = require_utils();
      exports.MAX_CHUNK_SIZE = 256 * 1024;
      exports.MIN_CHUNK_SIZE = 32 * 1024;
      var NOTE_SIZE = 32;
      var HASH_SIZE = 32;
      async function chunkData(data) {
        let chunks = [];
        let rest = data;
        let cursor = 0;
        while (rest.byteLength >= exports.MAX_CHUNK_SIZE) {
          let chunkSize = exports.MAX_CHUNK_SIZE;
          let nextChunkSize = rest.byteLength - exports.MAX_CHUNK_SIZE;
          if (nextChunkSize > 0 && nextChunkSize < exports.MIN_CHUNK_SIZE) {
            chunkSize = Math.ceil(rest.byteLength / 2);
          }
          const chunk = rest.slice(0, chunkSize);
          const dataHash = await common_1.default.crypto.hash(chunk);
          cursor += chunk.byteLength;
          chunks.push({
            dataHash,
            minByteRange: cursor - chunk.byteLength,
            maxByteRange: cursor
          });
          rest = rest.slice(chunkSize);
        }
        chunks.push({
          dataHash: await common_1.default.crypto.hash(rest),
          minByteRange: cursor,
          maxByteRange: cursor + rest.byteLength
        });
        return chunks;
      }
      exports.chunkData = chunkData;
      async function generateLeaves(chunks) {
        return Promise.all(chunks.map(async ({ dataHash, minByteRange, maxByteRange }) => {
          return {
            type: "leaf",
            id: await hash(await Promise.all([hash(dataHash), hash(intToBuffer(maxByteRange))])),
            dataHash,
            minByteRange,
            maxByteRange
          };
        }));
      }
      exports.generateLeaves = generateLeaves;
      async function computeRootHash(data) {
        const rootNode = await generateTree(data);
        return rootNode.id;
      }
      exports.computeRootHash = computeRootHash;
      async function generateTree(data) {
        const rootNode = await buildLayers(await generateLeaves(await chunkData(data)));
        return rootNode;
      }
      exports.generateTree = generateTree;
      async function generateTransactionChunks(data) {
        const chunks = await chunkData(data);
        const leaves = await generateLeaves(chunks);
        const root = await buildLayers(leaves);
        const proofs = await generateProofs(root);
        const lastChunk = chunks.slice(-1)[0];
        if (lastChunk.maxByteRange - lastChunk.minByteRange === 0) {
          chunks.splice(chunks.length - 1, 1);
          proofs.splice(proofs.length - 1, 1);
        }
        return {
          data_root: root.id,
          chunks,
          proofs
        };
      }
      exports.generateTransactionChunks = generateTransactionChunks;
      async function buildLayers(nodes, level = 0) {
        if (nodes.length < 2) {
          const root = nodes[0];
          return root;
        }
        const nextLayer = [];
        for (let i = 0; i < nodes.length; i += 2) {
          nextLayer.push(await hashBranch(nodes[i], nodes[i + 1]));
        }
        return buildLayers(nextLayer, level + 1);
      }
      exports.buildLayers = buildLayers;
      function generateProofs(root) {
        const proofs = resolveBranchProofs(root);
        if (!Array.isArray(proofs)) {
          return [proofs];
        }
        return arrayFlatten(proofs);
      }
      exports.generateProofs = generateProofs;
      function resolveBranchProofs(node, proof = new Uint8Array(), depth = 0) {
        if (node.type == "leaf") {
          return {
            offset: node.maxByteRange - 1,
            proof: (0, utils_1.concatBuffers)([
              proof,
              node.dataHash,
              intToBuffer(node.maxByteRange)
            ])
          };
        }
        if (node.type == "branch") {
          const partialProof = (0, utils_1.concatBuffers)([
            proof,
            node.leftChild.id,
            node.rightChild.id,
            intToBuffer(node.byteRange)
          ]);
          return [
            resolveBranchProofs(node.leftChild, partialProof, depth + 1),
            resolveBranchProofs(node.rightChild, partialProof, depth + 1)
          ];
        }
        throw new Error(`Unexpected node type`);
      }
      function arrayFlatten(input) {
        const flat = [];
        input.forEach((item) => {
          if (Array.isArray(item)) {
            flat.push(...arrayFlatten(item));
          } else {
            flat.push(item);
          }
        });
        return flat;
      }
      exports.arrayFlatten = arrayFlatten;
      async function hashBranch(left, right) {
        if (!right) {
          return left;
        }
        let branch = {
          type: "branch",
          id: await hash([
            await hash(left.id),
            await hash(right.id),
            await hash(intToBuffer(left.maxByteRange))
          ]),
          byteRange: left.maxByteRange,
          maxByteRange: right.maxByteRange,
          leftChild: left,
          rightChild: right
        };
        return branch;
      }
      async function hash(data) {
        if (Array.isArray(data)) {
          data = common_1.default.utils.concatBuffers(data);
        }
        return new Uint8Array(await common_1.default.crypto.hash(data));
      }
      function intToBuffer(note) {
        const buffer = new Uint8Array(NOTE_SIZE);
        for (var i = buffer.length - 1; i >= 0; i--) {
          var byte = note % 256;
          buffer[i] = byte;
          note = (note - byte) / 256;
        }
        return buffer;
      }
      exports.intToBuffer = intToBuffer;
      function bufferToInt(buffer) {
        let value = 0;
        for (var i = 0; i < buffer.length; i++) {
          value *= 256;
          value += buffer[i];
        }
        return value;
      }
      exports.bufferToInt = bufferToInt;
      var arrayCompare = (a, b) => a.every((value, index) => b[index] === value);
      exports.arrayCompare = arrayCompare;
      async function validatePath(id, dest, leftBound, rightBound, path2) {
        if (rightBound <= 0) {
          return false;
        }
        if (dest >= rightBound) {
          return validatePath(id, 0, rightBound - 1, rightBound, path2);
        }
        if (dest < 0) {
          return validatePath(id, 0, 0, rightBound, path2);
        }
        if (path2.length == HASH_SIZE + NOTE_SIZE) {
          const pathData = path2.slice(0, HASH_SIZE);
          const endOffsetBuffer = path2.slice(pathData.length, pathData.length + NOTE_SIZE);
          const pathDataHash = await hash([
            await hash(pathData),
            await hash(endOffsetBuffer)
          ]);
          let result = (0, exports.arrayCompare)(id, pathDataHash);
          if (result) {
            return {
              offset: rightBound - 1,
              leftBound,
              rightBound,
              chunkSize: rightBound - leftBound
            };
          }
          return false;
        }
        const left = path2.slice(0, HASH_SIZE);
        const right = path2.slice(left.length, left.length + HASH_SIZE);
        const offsetBuffer = path2.slice(left.length + right.length, left.length + right.length + NOTE_SIZE);
        const offset = bufferToInt(offsetBuffer);
        const remainder = path2.slice(left.length + right.length + offsetBuffer.length);
        const pathHash = await hash([
          await hash(left),
          await hash(right),
          await hash(offsetBuffer)
        ]);
        if ((0, exports.arrayCompare)(id, pathHash)) {
          if (dest < offset) {
            return await validatePath(left, dest, leftBound, Math.min(rightBound, offset), remainder);
          }
          return await validatePath(right, dest, Math.max(leftBound, offset), rightBound, remainder);
        }
        return false;
      }
      exports.validatePath = validatePath;
      async function debug(proof, output = "") {
        if (proof.byteLength < 1) {
          return output;
        }
        const left = proof.slice(0, HASH_SIZE);
        const right = proof.slice(left.length, left.length + HASH_SIZE);
        const offsetBuffer = proof.slice(left.length + right.length, left.length + right.length + NOTE_SIZE);
        const offset = bufferToInt(offsetBuffer);
        const remainder = proof.slice(left.length + right.length + offsetBuffer.length);
        const pathHash = await hash([
          await hash(left),
          await hash(right),
          await hash(offsetBuffer)
        ]);
        const updatedOutput = `${output}
${JSON.stringify(Buffer.from(left))},${JSON.stringify(Buffer.from(right))},${offset} => ${JSON.stringify(pathHash)}`;
        return debug(remainder, updatedOutput);
      }
      exports.debug = debug;
    }
  });

  // node_modules/arweave/node/lib/transaction-uploader.js
  var require_transaction_uploader = __commonJS({
    "node_modules/arweave/node/lib/transaction-uploader.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() {
          return m[k];
        } });
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.TransactionUploader = void 0;
      var transaction_1 = __importDefault(require_transaction());
      var ArweaveUtils = __importStar(require_utils());
      var error_1 = require_error();
      var merkle_1 = require_merkle();
      var MAX_CHUNKS_IN_BODY = 1;
      var FATAL_CHUNK_UPLOAD_ERRORS = [
        "invalid_json",
        "chunk_too_big",
        "data_path_too_big",
        "offset_too_big",
        "data_size_too_big",
        "chunk_proof_ratio_not_attractive",
        "invalid_proof"
      ];
      var ERROR_DELAY = 1e3 * 40;
      var TransactionUploader = class {
        constructor(api, transaction) {
          this.api = api;
          this.chunkIndex = 0;
          this.txPosted = false;
          this.lastRequestTimeEnd = 0;
          this.totalErrors = 0;
          this.lastResponseStatus = 0;
          this.lastResponseError = "";
          if (!transaction.id) {
            throw new Error(`Transaction is not signed`);
          }
          if (!transaction.chunks) {
            throw new Error(`Transaction chunks not prepared`);
          }
          this.data = transaction.data;
          this.transaction = new transaction_1.default(Object.assign({}, transaction, { data: new Uint8Array(0) }));
        }
        get isComplete() {
          return this.txPosted && this.chunkIndex === this.transaction.chunks.chunks.length;
        }
        get totalChunks() {
          return this.transaction.chunks.chunks.length;
        }
        get uploadedChunks() {
          return this.chunkIndex;
        }
        get pctComplete() {
          return Math.trunc(this.uploadedChunks / this.totalChunks * 100);
        }
        async uploadChunk(chunkIndex_) {
          if (this.isComplete) {
            throw new Error(`Upload is already complete`);
          }
          if (this.lastResponseError !== "") {
            this.totalErrors++;
          } else {
            this.totalErrors = 0;
          }
          if (this.totalErrors === 100) {
            throw new Error(`Unable to complete upload: ${this.lastResponseStatus}: ${this.lastResponseError}`);
          }
          let delay = this.lastResponseError === "" ? 0 : Math.max(this.lastRequestTimeEnd + ERROR_DELAY - Date.now(), ERROR_DELAY);
          if (delay > 0) {
            delay = delay - delay * Math.random() * 0.3;
            await new Promise((res) => setTimeout(res, delay));
          }
          this.lastResponseError = "";
          if (!this.txPosted) {
            await this.postTransaction();
            return;
          }
          if (chunkIndex_) {
            this.chunkIndex = chunkIndex_;
          }
          const chunk = this.transaction.getChunk(chunkIndex_ || this.chunkIndex, this.data);
          const chunkOk = await (0, merkle_1.validatePath)(this.transaction.chunks.data_root, parseInt(chunk.offset), 0, parseInt(chunk.data_size), ArweaveUtils.b64UrlToBuffer(chunk.data_path));
          if (!chunkOk) {
            throw new Error(`Unable to validate chunk ${this.chunkIndex}`);
          }
          const resp = await this.api.post(`chunk`, this.transaction.getChunk(this.chunkIndex, this.data)).catch((e) => {
            console.error(e.message);
            return { status: -1, data: { error: e.message } };
          });
          this.lastRequestTimeEnd = Date.now();
          this.lastResponseStatus = resp.status;
          if (this.lastResponseStatus == 200) {
            this.chunkIndex++;
          } else {
            this.lastResponseError = (0, error_1.getError)(resp);
            if (FATAL_CHUNK_UPLOAD_ERRORS.includes(this.lastResponseError)) {
              throw new Error(`Fatal error uploading chunk ${this.chunkIndex}: ${this.lastResponseError}`);
            }
          }
        }
        static async fromSerialized(api, serialized, data) {
          if (!serialized || typeof serialized.chunkIndex !== "number" || typeof serialized.transaction !== "object") {
            throw new Error(`Serialized object does not match expected format.`);
          }
          var transaction = new transaction_1.default(serialized.transaction);
          if (!transaction.chunks) {
            await transaction.prepareChunks(data);
          }
          const upload = new TransactionUploader(api, transaction);
          upload.chunkIndex = serialized.chunkIndex;
          upload.lastRequestTimeEnd = serialized.lastRequestTimeEnd;
          upload.lastResponseError = serialized.lastResponseError;
          upload.lastResponseStatus = serialized.lastResponseStatus;
          upload.txPosted = serialized.txPosted;
          upload.data = data;
          if (upload.transaction.data_root !== serialized.transaction.data_root) {
            throw new Error(`Data mismatch: Uploader doesn't match provided data.`);
          }
          return upload;
        }
        static async fromTransactionId(api, id) {
          const resp = await api.get(`tx/${id}`);
          if (resp.status !== 200) {
            throw new Error(`Tx ${id} not found: ${resp.status}`);
          }
          const transaction = resp.data;
          transaction.data = new Uint8Array(0);
          const serialized = {
            txPosted: true,
            chunkIndex: 0,
            lastResponseError: "",
            lastRequestTimeEnd: 0,
            lastResponseStatus: 0,
            transaction
          };
          return serialized;
        }
        toJSON() {
          return {
            chunkIndex: this.chunkIndex,
            transaction: this.transaction,
            lastRequestTimeEnd: this.lastRequestTimeEnd,
            lastResponseStatus: this.lastResponseStatus,
            lastResponseError: this.lastResponseError,
            txPosted: this.txPosted
          };
        }
        async postTransaction() {
          const uploadInBody = this.totalChunks <= MAX_CHUNKS_IN_BODY;
          if (uploadInBody) {
            this.transaction.data = this.data;
            const resp2 = await this.api.post(`tx`, this.transaction).catch((e) => {
              console.error(e);
              return { status: -1, data: { error: e.message } };
            });
            this.lastRequestTimeEnd = Date.now();
            this.lastResponseStatus = resp2.status;
            this.transaction.data = new Uint8Array(0);
            if (resp2.status >= 200 && resp2.status < 300) {
              this.txPosted = true;
              this.chunkIndex = MAX_CHUNKS_IN_BODY;
              return;
            }
            this.lastResponseError = (0, error_1.getError)(resp2);
            throw new Error(`Unable to upload transaction: ${resp2.status}, ${this.lastResponseError}`);
          }
          const resp = await this.api.post(`tx`, this.transaction);
          this.lastRequestTimeEnd = Date.now();
          this.lastResponseStatus = resp.status;
          if (!(resp.status >= 200 && resp.status < 300)) {
            this.lastResponseError = (0, error_1.getError)(resp);
            throw new Error(`Unable to upload transaction: ${resp.status}, ${this.lastResponseError}`);
          }
          this.txPosted = true;
        }
      };
      exports.TransactionUploader = TransactionUploader;
    }
  });

  // node_modules/arconnect/index.js
  var require_arconnect = __commonJS({
    "node_modules/arconnect/index.js"(exports, module2) {
      module2.exports = {};
    }
  });

  // node_modules/arweave/node/transactions.js
  var require_transactions = __commonJS({
    "node_modules/arweave/node/transactions.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() {
          return m[k];
        } });
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      var __await = exports && exports.__await || function(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
      };
      var __asyncGenerator = exports && exports.__asyncGenerator || function(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
          return this;
        }, i;
        function verb(n) {
          if (g[n])
            i[n] = function(v) {
              return new Promise(function(a, b) {
                q.push([n, v, a, b]) > 1 || resume(n, v);
              });
            };
        }
        function resume(n, v) {
          try {
            step(g[n](v));
          } catch (e) {
            settle(q[0][3], e);
          }
        }
        function step(r) {
          r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
        }
        function fulfill(value) {
          resume("next", value);
        }
        function reject(value) {
          resume("throw", value);
        }
        function settle(f, v) {
          if (f(v), q.shift(), q.length)
            resume(q[0][0], q[0][1]);
        }
      };
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      var error_1 = __importDefault(require_error());
      var transaction_1 = __importDefault(require_transaction());
      var ArweaveUtils = __importStar(require_utils());
      var transaction_uploader_1 = require_transaction_uploader();
      require_arconnect();
      var Transactions = class {
        constructor(api, crypto3, chunks) {
          this.api = api;
          this.crypto = crypto3;
          this.chunks = chunks;
        }
        getTransactionAnchor() {
          return this.api.get(`tx_anchor`, { transformResponse: [] }).then((response) => {
            return response.data;
          });
        }
        getPrice(byteSize, targetAddress) {
          let endpoint = targetAddress ? `price/${byteSize}/${targetAddress}` : `price/${byteSize}`;
          return this.api.get(endpoint, {
            transformResponse: [
              function(data) {
                return data;
              }
            ]
          }).then((response) => {
            return response.data;
          });
        }
        async get(id) {
          const response = await this.api.get(`tx/${id}`);
          if (response.status == 200) {
            const data_size = parseInt(response.data.data_size);
            if (response.data.format >= 2 && data_size > 0 && data_size <= 1024 * 1024 * 12) {
              const data = await this.getData(id);
              return new transaction_1.default(Object.assign(Object.assign({}, response.data), { data }));
            }
            return new transaction_1.default(Object.assign(Object.assign({}, response.data), { format: response.data.format || 1 }));
          }
          if (response.status == 404) {
            throw new error_1.default("TX_NOT_FOUND");
          }
          if (response.status == 410) {
            throw new error_1.default("TX_FAILED");
          }
          throw new error_1.default("TX_INVALID");
        }
        fromRaw(attributes) {
          return new transaction_1.default(attributes);
        }
        async search(tagName, tagValue) {
          return this.api.post(`arql`, {
            op: "equals",
            expr1: tagName,
            expr2: tagValue
          }).then((response) => {
            if (!response.data) {
              return [];
            }
            return response.data;
          });
        }
        getStatus(id) {
          return this.api.get(`tx/${id}/status`).then((response) => {
            if (response.status == 200) {
              return {
                status: 200,
                confirmed: response.data
              };
            }
            return {
              status: response.status,
              confirmed: null
            };
          });
        }
        async getData(id, options) {
          const data = await this.chunks.downloadChunkedData(id);
          if (options && options.decode && !options.string) {
            return data;
          }
          if (options && options.decode && options.string) {
            return ArweaveUtils.bufferToString(data);
          }
          return ArweaveUtils.bufferTob64Url(data);
        }
        async sign(transaction, jwk, options) {
          if (!jwk && (typeof window === "undefined" || !window.arweaveWallet)) {
            throw new Error(`A new Arweave transaction must provide the jwk parameter.`);
          } else if (!jwk || jwk === "use_wallet") {
            try {
              const existingPermissions = await window.arweaveWallet.getPermissions();
              if (!existingPermissions.includes("SIGN_TRANSACTION"))
                await window.arweaveWallet.connect(["SIGN_TRANSACTION"]);
            } catch (_a) {
            }
            const signedTransaction = await window.arweaveWallet.sign(transaction, options);
            transaction.setSignature({
              id: signedTransaction.id,
              owner: signedTransaction.owner,
              reward: signedTransaction.reward,
              tags: signedTransaction.tags,
              signature: signedTransaction.signature
            });
          } else {
            transaction.setOwner(jwk.n);
            let dataToSign = await transaction.getSignatureData();
            let rawSignature = await this.crypto.sign(jwk, dataToSign, options);
            let id = await this.crypto.hash(rawSignature);
            transaction.setSignature({
              id: ArweaveUtils.bufferTob64Url(id),
              owner: jwk.n,
              signature: ArweaveUtils.bufferTob64Url(rawSignature)
            });
          }
        }
        async verify(transaction) {
          const signaturePayload = await transaction.getSignatureData();
          const rawSignature = transaction.get("signature", {
            decode: true,
            string: false
          });
          const expectedId = ArweaveUtils.bufferTob64Url(await this.crypto.hash(rawSignature));
          if (transaction.id !== expectedId) {
            throw new Error(`Invalid transaction signature or ID! The transaction ID doesn't match the expected SHA-256 hash of the signature.`);
          }
          return this.crypto.verify(transaction.owner, signaturePayload, rawSignature);
        }
        async post(transaction) {
          if (typeof transaction === "string") {
            transaction = new transaction_1.default(JSON.parse(transaction));
          } else if (typeof transaction.readInt32BE === "function") {
            transaction = new transaction_1.default(JSON.parse(transaction.toString()));
          } else if (typeof transaction === "object" && !(transaction instanceof transaction_1.default)) {
            transaction = new transaction_1.default(transaction);
          }
          if (!(transaction instanceof transaction_1.default)) {
            throw new Error(`Must be Transaction object`);
          }
          if (!transaction.chunks) {
            await transaction.prepareChunks(transaction.data);
          }
          const uploader = await this.getUploader(transaction, transaction.data);
          try {
            while (!uploader.isComplete) {
              await uploader.uploadChunk();
            }
          } catch (e) {
            if (uploader.lastResponseStatus > 0) {
              return {
                status: uploader.lastResponseStatus,
                statusText: uploader.lastResponseError,
                data: {
                  error: uploader.lastResponseError
                }
              };
            }
            throw e;
          }
          return {
            status: 200,
            statusText: "OK",
            data: {}
          };
        }
        async getUploader(upload, data) {
          let uploader;
          if (data instanceof ArrayBuffer) {
            data = new Uint8Array(data);
          }
          if (upload instanceof transaction_1.default) {
            if (!data) {
              data = upload.data;
            }
            if (!(data instanceof Uint8Array)) {
              throw new Error("Data format is invalid");
            }
            if (!upload.chunks) {
              await upload.prepareChunks(data);
            }
            uploader = new transaction_uploader_1.TransactionUploader(this.api, upload);
            if (!uploader.data || uploader.data.length === 0) {
              uploader.data = data;
            }
          } else {
            if (typeof upload === "string") {
              upload = await transaction_uploader_1.TransactionUploader.fromTransactionId(this.api, upload);
            }
            if (!data || !(data instanceof Uint8Array)) {
              throw new Error(`Must provide data when resuming upload`);
            }
            uploader = await transaction_uploader_1.TransactionUploader.fromSerialized(this.api, upload, data);
          }
          return uploader;
        }
        upload(upload, data) {
          return __asyncGenerator(this, arguments, function* upload_1() {
            const uploader = yield __await(this.getUploader(upload, data));
            while (!uploader.isComplete) {
              yield __await(uploader.uploadChunk());
              yield yield __await(uploader);
            }
            return yield __await(uploader);
          });
        }
      };
      exports.default = Transactions;
    }
  });

  // node_modules/arweave/node/wallets.js
  var require_wallets = __commonJS({
    "node_modules/arweave/node/wallets.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() {
          return m[k];
        } });
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      var ArweaveUtils = __importStar(require_utils());
      require_arconnect();
      var Wallets = class {
        constructor(api, crypto3) {
          this.api = api;
          this.crypto = crypto3;
        }
        getBalance(address) {
          return this.api.get(`wallet/${address}/balance`, {
            transformResponse: [
              function(data) {
                return data;
              }
            ]
          }).then((response) => {
            return response.data;
          });
        }
        getLastTransactionID(address) {
          return this.api.get(`wallet/${address}/last_tx`).then((response) => {
            return response.data;
          });
        }
        generate() {
          return this.crypto.generateJWK();
        }
        async jwkToAddress(jwk) {
          if (!jwk || jwk === "use_wallet") {
            return this.getAddress();
          } else {
            return this.getAddress(jwk);
          }
        }
        async getAddress(jwk) {
          if (!jwk || jwk === "use_wallet") {
            try {
              await window.arweaveWallet.connect(["ACCESS_ADDRESS"]);
            } catch (_a) {
            }
            return window.arweaveWallet.getActiveAddress();
          } else {
            return this.ownerToAddress(jwk.n);
          }
        }
        async ownerToAddress(owner) {
          return ArweaveUtils.bufferTob64Url(await this.crypto.hash(ArweaveUtils.b64UrlToBuffer(owner)));
        }
      };
      exports.default = Wallets;
    }
  });

  // node_modules/arweave/node/silo.js
  var require_silo = __commonJS({
    "node_modules/arweave/node/silo.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() {
          return m[k];
        } });
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SiloResource = void 0;
      var ArweaveUtils = __importStar(require_utils());
      var Silo = class {
        constructor(api, crypto3, transactions) {
          this.api = api;
          this.crypto = crypto3;
          this.transactions = transactions;
        }
        async get(siloURI) {
          if (!siloURI) {
            throw new Error(`No Silo URI specified`);
          }
          const resource = await this.parseUri(siloURI);
          const ids = await this.transactions.search("Silo-Name", resource.getAccessKey());
          if (ids.length == 0) {
            throw new Error(`No data could be found for the Silo URI: ${siloURI}`);
          }
          const transaction = await this.transactions.get(ids[0]);
          if (!transaction) {
            throw new Error(`No data could be found for the Silo URI: ${siloURI}`);
          }
          const encrypted = transaction.get("data", { decode: true, string: false });
          return this.crypto.decrypt(encrypted, resource.getEncryptionKey());
        }
        async readTransactionData(transaction, siloURI) {
          if (!siloURI) {
            throw new Error(`No Silo URI specified`);
          }
          const resource = await this.parseUri(siloURI);
          const encrypted = transaction.get("data", { decode: true, string: false });
          return this.crypto.decrypt(encrypted, resource.getEncryptionKey());
        }
        async parseUri(siloURI) {
          const parsed = siloURI.match(/^([a-z0-9-_]+)\.([0-9]+)/i);
          if (!parsed) {
            throw new Error(`Invalid Silo name, must be a name in the format of [a-z0-9]+.[0-9]+, e.g. 'bubble.7'`);
          }
          const siloName = parsed[1];
          const hashIterations = Math.pow(2, parseInt(parsed[2]));
          const digest = await this.hash(ArweaveUtils.stringToBuffer(siloName), hashIterations);
          const accessKey = ArweaveUtils.bufferTob64(digest.slice(0, 15));
          const encryptionkey = await this.hash(digest.slice(16, 31), 1);
          return new SiloResource(siloURI, accessKey, encryptionkey);
        }
        async hash(input, iterations) {
          let digest = await this.crypto.hash(input);
          for (let count = 0; count < iterations - 1; count++) {
            digest = await this.crypto.hash(digest);
          }
          return digest;
        }
      };
      exports.default = Silo;
      var SiloResource = class {
        constructor(uri, accessKey, encryptionKey) {
          this.uri = uri;
          this.accessKey = accessKey;
          this.encryptionKey = encryptionKey;
        }
        getUri() {
          return this.uri;
        }
        getAccessKey() {
          return this.accessKey;
        }
        getEncryptionKey() {
          return this.encryptionKey;
        }
      };
      exports.SiloResource = SiloResource;
    }
  });

  // node_modules/arweave/node/chunks.js
  var require_chunks = __commonJS({
    "node_modules/arweave/node/chunks.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() {
          return m[k];
        } });
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      var error_1 = require_error();
      var ArweaveUtils = __importStar(require_utils());
      var Chunks = class {
        constructor(api) {
          this.api = api;
        }
        async getTransactionOffset(id) {
          const resp = await this.api.get(`tx/${id}/offset`);
          if (resp.status === 200) {
            return resp.data;
          }
          throw new Error(`Unable to get transaction offset: ${(0, error_1.getError)(resp)}`);
        }
        async getChunk(offset) {
          const resp = await this.api.get(`chunk/${offset}`);
          if (resp.status === 200) {
            return resp.data;
          }
          throw new Error(`Unable to get chunk: ${(0, error_1.getError)(resp)}`);
        }
        async getChunkData(offset) {
          const chunk = await this.getChunk(offset);
          const buf = ArweaveUtils.b64UrlToBuffer(chunk.chunk);
          return buf;
        }
        firstChunkOffset(offsetResponse) {
          return parseInt(offsetResponse.offset) - parseInt(offsetResponse.size) + 1;
        }
        async downloadChunkedData(id) {
          const offsetResponse = await this.getTransactionOffset(id);
          const size = parseInt(offsetResponse.size);
          const endOffset = parseInt(offsetResponse.offset);
          const startOffset = endOffset - size + 1;
          const data = new Uint8Array(size);
          let byte = 0;
          while (byte < size) {
            if (this.api.config.logging) {
              console.log(`[chunk] ${byte}/${size}`);
            }
            let chunkData;
            try {
              chunkData = await this.getChunkData(startOffset + byte);
            } catch (error) {
              console.error(`[chunk] Failed to fetch chunk at offset ${startOffset + byte}`);
              console.error(`[chunk] This could indicate that the chunk wasn't uploaded or hasn't yet seeded properly to a particular gatway/node`);
            }
            if (chunkData) {
              data.set(chunkData, byte);
              byte += chunkData.length;
            } else {
              throw new Error(`Coudn't complete data download at ${byte}/${size}`);
            }
          }
          return data;
        }
      };
      exports.default = Chunks;
    }
  });

  // node_modules/arweave/node/blocks.js
  var require_blocks = __commonJS({
    "node_modules/arweave/node/blocks.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      var error_1 = __importDefault(require_error());
      require_arconnect();
      var Blocks = class {
        constructor(api, network) {
          this.api = api;
          this.network = network;
        }
        async get(indepHash) {
          const response = await this.api.get(`${Blocks.ENDPOINT}${indepHash}`);
          if (response.status === 200) {
            return response.data;
          } else {
            if (response.status === 404) {
              throw new error_1.default("BLOCK_NOT_FOUND");
            } else {
              throw new Error(`Error while loading block data: ${response}`);
            }
          }
        }
        async getCurrent() {
          const { current } = await this.network.getInfo();
          return await this.get(current);
        }
      };
      exports.default = Blocks;
      Blocks.ENDPOINT = "block/hash/";
    }
  });

  // node_modules/arweave/node/common.js
  var require_common = __commonJS({
    "node_modules/arweave/node/common.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() {
          return m[k];
        } });
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      var ar_1 = __importDefault(require_ar());
      var api_1 = __importDefault(require_api());
      var network_1 = __importDefault(require_network());
      var transactions_1 = __importDefault(require_transactions());
      var wallets_1 = __importDefault(require_wallets());
      var transaction_1 = __importDefault(require_transaction());
      var ArweaveUtils = __importStar(require_utils());
      var silo_1 = __importDefault(require_silo());
      var chunks_1 = __importDefault(require_chunks());
      var blocks_1 = __importDefault(require_blocks());
      var Arweave2 = class {
        constructor(apiConfig) {
          this.api = new api_1.default(apiConfig);
          this.wallets = new wallets_1.default(this.api, Arweave2.crypto);
          this.chunks = new chunks_1.default(this.api);
          this.transactions = new transactions_1.default(this.api, Arweave2.crypto, this.chunks);
          this.silo = new silo_1.default(this.api, this.crypto, this.transactions);
          this.network = new network_1.default(this.api);
          this.blocks = new blocks_1.default(this.api, this.network);
          this.ar = new ar_1.default();
        }
        get crypto() {
          return Arweave2.crypto;
        }
        get utils() {
          return Arweave2.utils;
        }
        getConfig() {
          return {
            api: this.api.getConfig(),
            crypto: null
          };
        }
        async createTransaction(attributes, jwk) {
          const transaction = {};
          Object.assign(transaction, attributes);
          if (!attributes.data && !(attributes.target && attributes.quantity)) {
            throw new Error(`A new Arweave transaction must have a 'data' value, or 'target' and 'quantity' values.`);
          }
          if (attributes.owner == void 0) {
            if (jwk && jwk !== "use_wallet") {
              transaction.owner = jwk.n;
            }
          }
          if (attributes.last_tx == void 0) {
            transaction.last_tx = await this.transactions.getTransactionAnchor();
          }
          if (typeof attributes.data === "string") {
            attributes.data = ArweaveUtils.stringToBuffer(attributes.data);
          }
          if (attributes.data instanceof ArrayBuffer) {
            attributes.data = new Uint8Array(attributes.data);
          }
          if (attributes.data && !(attributes.data instanceof Uint8Array)) {
            throw new Error("Expected data to be a string, Uint8Array or ArrayBuffer");
          }
          if (attributes.reward == void 0) {
            const length = attributes.data ? attributes.data.byteLength : 0;
            transaction.reward = await this.transactions.getPrice(length, transaction.target);
          }
          transaction.data_root = "";
          transaction.data_size = attributes.data ? attributes.data.byteLength.toString() : "0";
          transaction.data = attributes.data || new Uint8Array(0);
          const createdTransaction = new transaction_1.default(transaction);
          await createdTransaction.getSignatureData();
          return createdTransaction;
        }
        async createSiloTransaction(attributes, jwk, siloUri) {
          const transaction = {};
          Object.assign(transaction, attributes);
          if (!attributes.data) {
            throw new Error(`Silo transactions must have a 'data' value`);
          }
          if (!siloUri) {
            throw new Error(`No Silo URI specified.`);
          }
          if (attributes.target || attributes.quantity) {
            throw new Error(`Silo transactions can only be used for storing data, sending AR to other wallets isn't supported.`);
          }
          if (attributes.owner == void 0) {
            if (!jwk || !jwk.n) {
              throw new Error(`A new Arweave transaction must either have an 'owner' attribute, or you must provide the jwk parameter.`);
            }
            transaction.owner = jwk.n;
          }
          if (attributes.last_tx == void 0) {
            transaction.last_tx = await this.transactions.getTransactionAnchor();
          }
          const siloResource = await this.silo.parseUri(siloUri);
          if (typeof attributes.data == "string") {
            const encrypted = await this.crypto.encrypt(ArweaveUtils.stringToBuffer(attributes.data), siloResource.getEncryptionKey());
            transaction.reward = await this.transactions.getPrice(encrypted.byteLength);
            transaction.data = ArweaveUtils.bufferTob64Url(encrypted);
          }
          if (attributes.data instanceof Uint8Array) {
            const encrypted = await this.crypto.encrypt(attributes.data, siloResource.getEncryptionKey());
            transaction.reward = await this.transactions.getPrice(encrypted.byteLength);
            transaction.data = ArweaveUtils.bufferTob64Url(encrypted);
          }
          const siloTransaction = new transaction_1.default(transaction);
          siloTransaction.addTag("Silo-Name", siloResource.getAccessKey());
          siloTransaction.addTag("Silo-Version", `0.1.0`);
          return siloTransaction;
        }
        arql(query) {
          return this.api.post("/arql", query).then((response) => response.data || []);
        }
      };
      exports.default = Arweave2;
      Arweave2.utils = ArweaveUtils;
    }
  });

  // node_modules/arweave/node/lib/deepHash.js
  var require_deepHash = __commonJS({
    "node_modules/arweave/node/lib/deepHash.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      var common_1 = __importDefault(require_common());
      async function deepHash(data) {
        if (Array.isArray(data)) {
          const tag2 = common_1.default.utils.concatBuffers([
            common_1.default.utils.stringToBuffer("list"),
            common_1.default.utils.stringToBuffer(data.length.toString())
          ]);
          return await deepHashChunks(data, await common_1.default.crypto.hash(tag2, "SHA-384"));
        }
        const tag = common_1.default.utils.concatBuffers([
          common_1.default.utils.stringToBuffer("blob"),
          common_1.default.utils.stringToBuffer(data.byteLength.toString())
        ]);
        const taggedHash = common_1.default.utils.concatBuffers([
          await common_1.default.crypto.hash(tag, "SHA-384"),
          await common_1.default.crypto.hash(data, "SHA-384")
        ]);
        return await common_1.default.crypto.hash(taggedHash, "SHA-384");
      }
      exports.default = deepHash;
      async function deepHashChunks(chunks, acc) {
        if (chunks.length < 1) {
          return acc;
        }
        const hashPair = common_1.default.utils.concatBuffers([
          acc,
          await deepHash(chunks[0])
        ]);
        const newAcc = await common_1.default.crypto.hash(hashPair, "SHA-384");
        return await deepHashChunks(chunks.slice(1), newAcc);
      }
    }
  });

  // node_modules/arweave/node/lib/transaction.js
  var require_transaction = __commonJS({
    "node_modules/arweave/node/lib/transaction.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() {
          return m[k];
        } });
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Tag = void 0;
      var ArweaveUtils = __importStar(require_utils());
      var deepHash_1 = __importDefault(require_deepHash());
      var merkle_1 = require_merkle();
      var BaseObject = class {
        get(field, options) {
          if (!Object.getOwnPropertyNames(this).includes(field)) {
            throw new Error(`Field "${field}" is not a property of the Arweave Transaction class.`);
          }
          if (this[field] instanceof Uint8Array) {
            if (options && options.decode && options.string) {
              return ArweaveUtils.bufferToString(this[field]);
            }
            if (options && options.decode && !options.string) {
              return this[field];
            }
            return ArweaveUtils.bufferTob64Url(this[field]);
          }
          if (options && options.decode == true) {
            if (options && options.string) {
              return ArweaveUtils.b64UrlToString(this[field]);
            }
            return ArweaveUtils.b64UrlToBuffer(this[field]);
          }
          return this[field];
        }
      };
      var Tag = class extends BaseObject {
        constructor(name, value, decode = false) {
          super();
          this.name = name;
          this.value = value;
        }
      };
      exports.Tag = Tag;
      var Transaction4 = class extends BaseObject {
        constructor(attributes = {}) {
          super();
          this.format = 2;
          this.id = "";
          this.last_tx = "";
          this.owner = "";
          this.tags = [];
          this.target = "";
          this.quantity = "0";
          this.data_size = "0";
          this.data = new Uint8Array();
          this.data_root = "";
          this.reward = "0";
          this.signature = "";
          Object.assign(this, attributes);
          if (typeof this.data === "string") {
            this.data = ArweaveUtils.b64UrlToBuffer(this.data);
          }
          if (attributes.tags) {
            this.tags = attributes.tags.map((tag) => {
              return new Tag(tag.name, tag.value);
            });
          }
        }
        addTag(name, value) {
          this.tags.push(new Tag(ArweaveUtils.stringToB64Url(name), ArweaveUtils.stringToB64Url(value)));
        }
        toJSON() {
          return {
            format: this.format,
            id: this.id,
            last_tx: this.last_tx,
            owner: this.owner,
            tags: this.tags,
            target: this.target,
            quantity: this.quantity,
            data: ArweaveUtils.bufferTob64Url(this.data),
            data_size: this.data_size,
            data_root: this.data_root,
            data_tree: this.data_tree,
            reward: this.reward,
            signature: this.signature
          };
        }
        setOwner(owner) {
          this.owner = owner;
        }
        setSignature({ id, owner, reward, tags, signature }) {
          this.id = id;
          this.owner = owner;
          if (reward)
            this.reward = reward;
          if (tags)
            this.tags = tags;
          this.signature = signature;
        }
        async prepareChunks(data) {
          if (!this.chunks && data.byteLength > 0) {
            this.chunks = await (0, merkle_1.generateTransactionChunks)(data);
            this.data_root = ArweaveUtils.bufferTob64Url(this.chunks.data_root);
          }
          if (!this.chunks && data.byteLength === 0) {
            this.chunks = {
              chunks: [],
              data_root: new Uint8Array(),
              proofs: []
            };
            this.data_root = "";
          }
        }
        getChunk(idx, data) {
          if (!this.chunks) {
            throw new Error(`Chunks have not been prepared`);
          }
          const proof = this.chunks.proofs[idx];
          const chunk = this.chunks.chunks[idx];
          return {
            data_root: this.data_root,
            data_size: this.data_size,
            data_path: ArweaveUtils.bufferTob64Url(proof.proof),
            offset: proof.offset.toString(),
            chunk: ArweaveUtils.bufferTob64Url(data.slice(chunk.minByteRange, chunk.maxByteRange))
          };
        }
        async getSignatureData() {
          switch (this.format) {
            case 1:
              let tags = this.tags.reduce((accumulator, tag) => {
                return ArweaveUtils.concatBuffers([
                  accumulator,
                  tag.get("name", { decode: true, string: false }),
                  tag.get("value", { decode: true, string: false })
                ]);
              }, new Uint8Array());
              return ArweaveUtils.concatBuffers([
                this.get("owner", { decode: true, string: false }),
                this.get("target", { decode: true, string: false }),
                this.get("data", { decode: true, string: false }),
                ArweaveUtils.stringToBuffer(this.quantity),
                ArweaveUtils.stringToBuffer(this.reward),
                this.get("last_tx", { decode: true, string: false }),
                tags
              ]);
            case 2:
              if (!this.data_root) {
                await this.prepareChunks(this.data);
              }
              const tagList = this.tags.map((tag) => [
                tag.get("name", { decode: true, string: false }),
                tag.get("value", { decode: true, string: false })
              ]);
              return await (0, deepHash_1.default)([
                ArweaveUtils.stringToBuffer(this.format.toString()),
                this.get("owner", { decode: true, string: false }),
                this.get("target", { decode: true, string: false }),
                ArweaveUtils.stringToBuffer(this.quantity),
                ArweaveUtils.stringToBuffer(this.reward),
                this.get("last_tx", { decode: true, string: false }),
                tagList,
                ArweaveUtils.stringToBuffer(this.data_size),
                this.get("data_root", { decode: true, string: false })
              ]);
            default:
              throw new Error(`Unexpected transaction format: ${this.format}`);
          }
        }
      };
      exports.default = Transaction4;
    }
  });

  // node_modules/lodash/_listCacheClear.js
  var require_listCacheClear = __commonJS({
    "node_modules/lodash/_listCacheClear.js"(exports, module2) {
      function listCacheClear() {
        this.__data__ = [];
        this.size = 0;
      }
      module2.exports = listCacheClear;
    }
  });

  // node_modules/lodash/eq.js
  var require_eq = __commonJS({
    "node_modules/lodash/eq.js"(exports, module2) {
      function eq(value, other) {
        return value === other || value !== value && other !== other;
      }
      module2.exports = eq;
    }
  });

  // node_modules/lodash/_assocIndexOf.js
  var require_assocIndexOf = __commonJS({
    "node_modules/lodash/_assocIndexOf.js"(exports, module2) {
      var eq = require_eq();
      function assocIndexOf(array, key) {
        var length = array.length;
        while (length--) {
          if (eq(array[length][0], key)) {
            return length;
          }
        }
        return -1;
      }
      module2.exports = assocIndexOf;
    }
  });

  // node_modules/lodash/_listCacheDelete.js
  var require_listCacheDelete = __commonJS({
    "node_modules/lodash/_listCacheDelete.js"(exports, module2) {
      var assocIndexOf = require_assocIndexOf();
      var arrayProto = Array.prototype;
      var splice = arrayProto.splice;
      function listCacheDelete(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        if (index < 0) {
          return false;
        }
        var lastIndex = data.length - 1;
        if (index == lastIndex) {
          data.pop();
        } else {
          splice.call(data, index, 1);
        }
        --this.size;
        return true;
      }
      module2.exports = listCacheDelete;
    }
  });

  // node_modules/lodash/_listCacheGet.js
  var require_listCacheGet = __commonJS({
    "node_modules/lodash/_listCacheGet.js"(exports, module2) {
      var assocIndexOf = require_assocIndexOf();
      function listCacheGet(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        return index < 0 ? void 0 : data[index][1];
      }
      module2.exports = listCacheGet;
    }
  });

  // node_modules/lodash/_listCacheHas.js
  var require_listCacheHas = __commonJS({
    "node_modules/lodash/_listCacheHas.js"(exports, module2) {
      var assocIndexOf = require_assocIndexOf();
      function listCacheHas(key) {
        return assocIndexOf(this.__data__, key) > -1;
      }
      module2.exports = listCacheHas;
    }
  });

  // node_modules/lodash/_listCacheSet.js
  var require_listCacheSet = __commonJS({
    "node_modules/lodash/_listCacheSet.js"(exports, module2) {
      var assocIndexOf = require_assocIndexOf();
      function listCacheSet(key, value) {
        var data = this.__data__, index = assocIndexOf(data, key);
        if (index < 0) {
          ++this.size;
          data.push([key, value]);
        } else {
          data[index][1] = value;
        }
        return this;
      }
      module2.exports = listCacheSet;
    }
  });

  // node_modules/lodash/_ListCache.js
  var require_ListCache = __commonJS({
    "node_modules/lodash/_ListCache.js"(exports, module2) {
      var listCacheClear = require_listCacheClear();
      var listCacheDelete = require_listCacheDelete();
      var listCacheGet = require_listCacheGet();
      var listCacheHas = require_listCacheHas();
      var listCacheSet = require_listCacheSet();
      function ListCache(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      ListCache.prototype.clear = listCacheClear;
      ListCache.prototype["delete"] = listCacheDelete;
      ListCache.prototype.get = listCacheGet;
      ListCache.prototype.has = listCacheHas;
      ListCache.prototype.set = listCacheSet;
      module2.exports = ListCache;
    }
  });

  // node_modules/lodash/_stackClear.js
  var require_stackClear = __commonJS({
    "node_modules/lodash/_stackClear.js"(exports, module2) {
      var ListCache = require_ListCache();
      function stackClear() {
        this.__data__ = new ListCache();
        this.size = 0;
      }
      module2.exports = stackClear;
    }
  });

  // node_modules/lodash/_stackDelete.js
  var require_stackDelete = __commonJS({
    "node_modules/lodash/_stackDelete.js"(exports, module2) {
      function stackDelete(key) {
        var data = this.__data__, result = data["delete"](key);
        this.size = data.size;
        return result;
      }
      module2.exports = stackDelete;
    }
  });

  // node_modules/lodash/_stackGet.js
  var require_stackGet = __commonJS({
    "node_modules/lodash/_stackGet.js"(exports, module2) {
      function stackGet(key) {
        return this.__data__.get(key);
      }
      module2.exports = stackGet;
    }
  });

  // node_modules/lodash/_stackHas.js
  var require_stackHas = __commonJS({
    "node_modules/lodash/_stackHas.js"(exports, module2) {
      function stackHas(key) {
        return this.__data__.has(key);
      }
      module2.exports = stackHas;
    }
  });

  // node_modules/lodash/_freeGlobal.js
  var require_freeGlobal = __commonJS({
    "node_modules/lodash/_freeGlobal.js"(exports, module2) {
      var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
      module2.exports = freeGlobal;
    }
  });

  // node_modules/lodash/_root.js
  var require_root = __commonJS({
    "node_modules/lodash/_root.js"(exports, module2) {
      var freeGlobal = require_freeGlobal();
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root = freeGlobal || freeSelf || Function("return this")();
      module2.exports = root;
    }
  });

  // node_modules/lodash/_Symbol.js
  var require_Symbol = __commonJS({
    "node_modules/lodash/_Symbol.js"(exports, module2) {
      var root = require_root();
      var Symbol2 = root.Symbol;
      module2.exports = Symbol2;
    }
  });

  // node_modules/lodash/_getRawTag.js
  var require_getRawTag = __commonJS({
    "node_modules/lodash/_getRawTag.js"(exports, module2) {
      var Symbol2 = require_Symbol();
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      var nativeObjectToString = objectProto.toString;
      var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
      function getRawTag(value) {
        var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
        try {
          value[symToStringTag] = void 0;
          var unmasked = true;
        } catch (e) {
        }
        var result = nativeObjectToString.call(value);
        if (unmasked) {
          if (isOwn) {
            value[symToStringTag] = tag;
          } else {
            delete value[symToStringTag];
          }
        }
        return result;
      }
      module2.exports = getRawTag;
    }
  });

  // node_modules/lodash/_objectToString.js
  var require_objectToString = __commonJS({
    "node_modules/lodash/_objectToString.js"(exports, module2) {
      var objectProto = Object.prototype;
      var nativeObjectToString = objectProto.toString;
      function objectToString(value) {
        return nativeObjectToString.call(value);
      }
      module2.exports = objectToString;
    }
  });

  // node_modules/lodash/_baseGetTag.js
  var require_baseGetTag = __commonJS({
    "node_modules/lodash/_baseGetTag.js"(exports, module2) {
      var Symbol2 = require_Symbol();
      var getRawTag = require_getRawTag();
      var objectToString = require_objectToString();
      var nullTag = "[object Null]";
      var undefinedTag = "[object Undefined]";
      var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
      function baseGetTag(value) {
        if (value == null) {
          return value === void 0 ? undefinedTag : nullTag;
        }
        return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
      }
      module2.exports = baseGetTag;
    }
  });

  // node_modules/lodash/isObject.js
  var require_isObject = __commonJS({
    "node_modules/lodash/isObject.js"(exports, module2) {
      function isObject2(value) {
        var type = typeof value;
        return value != null && (type == "object" || type == "function");
      }
      module2.exports = isObject2;
    }
  });

  // node_modules/lodash/isFunction.js
  var require_isFunction = __commonJS({
    "node_modules/lodash/isFunction.js"(exports, module2) {
      var baseGetTag = require_baseGetTag();
      var isObject2 = require_isObject();
      var asyncTag = "[object AsyncFunction]";
      var funcTag = "[object Function]";
      var genTag = "[object GeneratorFunction]";
      var proxyTag = "[object Proxy]";
      function isFunction(value) {
        if (!isObject2(value)) {
          return false;
        }
        var tag = baseGetTag(value);
        return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
      }
      module2.exports = isFunction;
    }
  });

  // node_modules/lodash/_coreJsData.js
  var require_coreJsData = __commonJS({
    "node_modules/lodash/_coreJsData.js"(exports, module2) {
      var root = require_root();
      var coreJsData = root["__core-js_shared__"];
      module2.exports = coreJsData;
    }
  });

  // node_modules/lodash/_isMasked.js
  var require_isMasked = __commonJS({
    "node_modules/lodash/_isMasked.js"(exports, module2) {
      var coreJsData = require_coreJsData();
      var maskSrcKey = function() {
        var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
        return uid ? "Symbol(src)_1." + uid : "";
      }();
      function isMasked(func) {
        return !!maskSrcKey && maskSrcKey in func;
      }
      module2.exports = isMasked;
    }
  });

  // node_modules/lodash/_toSource.js
  var require_toSource = __commonJS({
    "node_modules/lodash/_toSource.js"(exports, module2) {
      var funcProto = Function.prototype;
      var funcToString = funcProto.toString;
      function toSource(func) {
        if (func != null) {
          try {
            return funcToString.call(func);
          } catch (e) {
          }
          try {
            return func + "";
          } catch (e) {
          }
        }
        return "";
      }
      module2.exports = toSource;
    }
  });

  // node_modules/lodash/_baseIsNative.js
  var require_baseIsNative = __commonJS({
    "node_modules/lodash/_baseIsNative.js"(exports, module2) {
      var isFunction = require_isFunction();
      var isMasked = require_isMasked();
      var isObject2 = require_isObject();
      var toSource = require_toSource();
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
      var funcProto = Function.prototype;
      var objectProto = Object.prototype;
      var funcToString = funcProto.toString;
      var hasOwnProperty = objectProto.hasOwnProperty;
      var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
      function baseIsNative(value) {
        if (!isObject2(value) || isMasked(value)) {
          return false;
        }
        var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
        return pattern.test(toSource(value));
      }
      module2.exports = baseIsNative;
    }
  });

  // node_modules/lodash/_getValue.js
  var require_getValue = __commonJS({
    "node_modules/lodash/_getValue.js"(exports, module2) {
      function getValue(object, key) {
        return object == null ? void 0 : object[key];
      }
      module2.exports = getValue;
    }
  });

  // node_modules/lodash/_getNative.js
  var require_getNative = __commonJS({
    "node_modules/lodash/_getNative.js"(exports, module2) {
      var baseIsNative = require_baseIsNative();
      var getValue = require_getValue();
      function getNative(object, key) {
        var value = getValue(object, key);
        return baseIsNative(value) ? value : void 0;
      }
      module2.exports = getNative;
    }
  });

  // node_modules/lodash/_Map.js
  var require_Map = __commonJS({
    "node_modules/lodash/_Map.js"(exports, module2) {
      var getNative = require_getNative();
      var root = require_root();
      var Map2 = getNative(root, "Map");
      module2.exports = Map2;
    }
  });

  // node_modules/lodash/_nativeCreate.js
  var require_nativeCreate = __commonJS({
    "node_modules/lodash/_nativeCreate.js"(exports, module2) {
      var getNative = require_getNative();
      var nativeCreate = getNative(Object, "create");
      module2.exports = nativeCreate;
    }
  });

  // node_modules/lodash/_hashClear.js
  var require_hashClear = __commonJS({
    "node_modules/lodash/_hashClear.js"(exports, module2) {
      var nativeCreate = require_nativeCreate();
      function hashClear() {
        this.__data__ = nativeCreate ? nativeCreate(null) : {};
        this.size = 0;
      }
      module2.exports = hashClear;
    }
  });

  // node_modules/lodash/_hashDelete.js
  var require_hashDelete = __commonJS({
    "node_modules/lodash/_hashDelete.js"(exports, module2) {
      function hashDelete(key) {
        var result = this.has(key) && delete this.__data__[key];
        this.size -= result ? 1 : 0;
        return result;
      }
      module2.exports = hashDelete;
    }
  });

  // node_modules/lodash/_hashGet.js
  var require_hashGet = __commonJS({
    "node_modules/lodash/_hashGet.js"(exports, module2) {
      var nativeCreate = require_nativeCreate();
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      function hashGet(key) {
        var data = this.__data__;
        if (nativeCreate) {
          var result = data[key];
          return result === HASH_UNDEFINED ? void 0 : result;
        }
        return hasOwnProperty.call(data, key) ? data[key] : void 0;
      }
      module2.exports = hashGet;
    }
  });

  // node_modules/lodash/_hashHas.js
  var require_hashHas = __commonJS({
    "node_modules/lodash/_hashHas.js"(exports, module2) {
      var nativeCreate = require_nativeCreate();
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      function hashHas(key) {
        var data = this.__data__;
        return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
      }
      module2.exports = hashHas;
    }
  });

  // node_modules/lodash/_hashSet.js
  var require_hashSet = __commonJS({
    "node_modules/lodash/_hashSet.js"(exports, module2) {
      var nativeCreate = require_nativeCreate();
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      function hashSet(key, value) {
        var data = this.__data__;
        this.size += this.has(key) ? 0 : 1;
        data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
        return this;
      }
      module2.exports = hashSet;
    }
  });

  // node_modules/lodash/_Hash.js
  var require_Hash = __commonJS({
    "node_modules/lodash/_Hash.js"(exports, module2) {
      var hashClear = require_hashClear();
      var hashDelete = require_hashDelete();
      var hashGet = require_hashGet();
      var hashHas = require_hashHas();
      var hashSet = require_hashSet();
      function Hash(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      Hash.prototype.clear = hashClear;
      Hash.prototype["delete"] = hashDelete;
      Hash.prototype.get = hashGet;
      Hash.prototype.has = hashHas;
      Hash.prototype.set = hashSet;
      module2.exports = Hash;
    }
  });

  // node_modules/lodash/_mapCacheClear.js
  var require_mapCacheClear = __commonJS({
    "node_modules/lodash/_mapCacheClear.js"(exports, module2) {
      var Hash = require_Hash();
      var ListCache = require_ListCache();
      var Map2 = require_Map();
      function mapCacheClear() {
        this.size = 0;
        this.__data__ = {
          "hash": new Hash(),
          "map": new (Map2 || ListCache)(),
          "string": new Hash()
        };
      }
      module2.exports = mapCacheClear;
    }
  });

  // node_modules/lodash/_isKeyable.js
  var require_isKeyable = __commonJS({
    "node_modules/lodash/_isKeyable.js"(exports, module2) {
      function isKeyable(value) {
        var type = typeof value;
        return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
      }
      module2.exports = isKeyable;
    }
  });

  // node_modules/lodash/_getMapData.js
  var require_getMapData = __commonJS({
    "node_modules/lodash/_getMapData.js"(exports, module2) {
      var isKeyable = require_isKeyable();
      function getMapData(map, key) {
        var data = map.__data__;
        return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
      }
      module2.exports = getMapData;
    }
  });

  // node_modules/lodash/_mapCacheDelete.js
  var require_mapCacheDelete = __commonJS({
    "node_modules/lodash/_mapCacheDelete.js"(exports, module2) {
      var getMapData = require_getMapData();
      function mapCacheDelete(key) {
        var result = getMapData(this, key)["delete"](key);
        this.size -= result ? 1 : 0;
        return result;
      }
      module2.exports = mapCacheDelete;
    }
  });

  // node_modules/lodash/_mapCacheGet.js
  var require_mapCacheGet = __commonJS({
    "node_modules/lodash/_mapCacheGet.js"(exports, module2) {
      var getMapData = require_getMapData();
      function mapCacheGet(key) {
        return getMapData(this, key).get(key);
      }
      module2.exports = mapCacheGet;
    }
  });

  // node_modules/lodash/_mapCacheHas.js
  var require_mapCacheHas = __commonJS({
    "node_modules/lodash/_mapCacheHas.js"(exports, module2) {
      var getMapData = require_getMapData();
      function mapCacheHas(key) {
        return getMapData(this, key).has(key);
      }
      module2.exports = mapCacheHas;
    }
  });

  // node_modules/lodash/_mapCacheSet.js
  var require_mapCacheSet = __commonJS({
    "node_modules/lodash/_mapCacheSet.js"(exports, module2) {
      var getMapData = require_getMapData();
      function mapCacheSet(key, value) {
        var data = getMapData(this, key), size = data.size;
        data.set(key, value);
        this.size += data.size == size ? 0 : 1;
        return this;
      }
      module2.exports = mapCacheSet;
    }
  });

  // node_modules/lodash/_MapCache.js
  var require_MapCache = __commonJS({
    "node_modules/lodash/_MapCache.js"(exports, module2) {
      var mapCacheClear = require_mapCacheClear();
      var mapCacheDelete = require_mapCacheDelete();
      var mapCacheGet = require_mapCacheGet();
      var mapCacheHas = require_mapCacheHas();
      var mapCacheSet = require_mapCacheSet();
      function MapCache(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      MapCache.prototype.clear = mapCacheClear;
      MapCache.prototype["delete"] = mapCacheDelete;
      MapCache.prototype.get = mapCacheGet;
      MapCache.prototype.has = mapCacheHas;
      MapCache.prototype.set = mapCacheSet;
      module2.exports = MapCache;
    }
  });

  // node_modules/lodash/_stackSet.js
  var require_stackSet = __commonJS({
    "node_modules/lodash/_stackSet.js"(exports, module2) {
      var ListCache = require_ListCache();
      var Map2 = require_Map();
      var MapCache = require_MapCache();
      var LARGE_ARRAY_SIZE = 200;
      function stackSet(key, value) {
        var data = this.__data__;
        if (data instanceof ListCache) {
          var pairs = data.__data__;
          if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
            pairs.push([key, value]);
            this.size = ++data.size;
            return this;
          }
          data = this.__data__ = new MapCache(pairs);
        }
        data.set(key, value);
        this.size = data.size;
        return this;
      }
      module2.exports = stackSet;
    }
  });

  // node_modules/lodash/_Stack.js
  var require_Stack = __commonJS({
    "node_modules/lodash/_Stack.js"(exports, module2) {
      var ListCache = require_ListCache();
      var stackClear = require_stackClear();
      var stackDelete = require_stackDelete();
      var stackGet = require_stackGet();
      var stackHas = require_stackHas();
      var stackSet = require_stackSet();
      function Stack(entries) {
        var data = this.__data__ = new ListCache(entries);
        this.size = data.size;
      }
      Stack.prototype.clear = stackClear;
      Stack.prototype["delete"] = stackDelete;
      Stack.prototype.get = stackGet;
      Stack.prototype.has = stackHas;
      Stack.prototype.set = stackSet;
      module2.exports = Stack;
    }
  });

  // node_modules/lodash/_arrayEach.js
  var require_arrayEach = __commonJS({
    "node_modules/lodash/_arrayEach.js"(exports, module2) {
      function arrayEach(array, iteratee) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (iteratee(array[index], index, array) === false) {
            break;
          }
        }
        return array;
      }
      module2.exports = arrayEach;
    }
  });

  // node_modules/lodash/_defineProperty.js
  var require_defineProperty = __commonJS({
    "node_modules/lodash/_defineProperty.js"(exports, module2) {
      var getNative = require_getNative();
      var defineProperty = function() {
        try {
          var func = getNative(Object, "defineProperty");
          func({}, "", {});
          return func;
        } catch (e) {
        }
      }();
      module2.exports = defineProperty;
    }
  });

  // node_modules/lodash/_baseAssignValue.js
  var require_baseAssignValue = __commonJS({
    "node_modules/lodash/_baseAssignValue.js"(exports, module2) {
      var defineProperty = require_defineProperty();
      function baseAssignValue(object, key, value) {
        if (key == "__proto__" && defineProperty) {
          defineProperty(object, key, {
            "configurable": true,
            "enumerable": true,
            "value": value,
            "writable": true
          });
        } else {
          object[key] = value;
        }
      }
      module2.exports = baseAssignValue;
    }
  });

  // node_modules/lodash/_assignValue.js
  var require_assignValue = __commonJS({
    "node_modules/lodash/_assignValue.js"(exports, module2) {
      var baseAssignValue = require_baseAssignValue();
      var eq = require_eq();
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      function assignValue(object, key, value) {
        var objValue = object[key];
        if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
          baseAssignValue(object, key, value);
        }
      }
      module2.exports = assignValue;
    }
  });

  // node_modules/lodash/_copyObject.js
  var require_copyObject = __commonJS({
    "node_modules/lodash/_copyObject.js"(exports, module2) {
      var assignValue = require_assignValue();
      var baseAssignValue = require_baseAssignValue();
      function copyObject(source, props, object, customizer) {
        var isNew = !object;
        object || (object = {});
        var index = -1, length = props.length;
        while (++index < length) {
          var key = props[index];
          var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
          if (newValue === void 0) {
            newValue = source[key];
          }
          if (isNew) {
            baseAssignValue(object, key, newValue);
          } else {
            assignValue(object, key, newValue);
          }
        }
        return object;
      }
      module2.exports = copyObject;
    }
  });

  // node_modules/lodash/_baseTimes.js
  var require_baseTimes = __commonJS({
    "node_modules/lodash/_baseTimes.js"(exports, module2) {
      function baseTimes(n, iteratee) {
        var index = -1, result = Array(n);
        while (++index < n) {
          result[index] = iteratee(index);
        }
        return result;
      }
      module2.exports = baseTimes;
    }
  });

  // node_modules/lodash/isObjectLike.js
  var require_isObjectLike = __commonJS({
    "node_modules/lodash/isObjectLike.js"(exports, module2) {
      function isObjectLike(value) {
        return value != null && typeof value == "object";
      }
      module2.exports = isObjectLike;
    }
  });

  // node_modules/lodash/_baseIsArguments.js
  var require_baseIsArguments = __commonJS({
    "node_modules/lodash/_baseIsArguments.js"(exports, module2) {
      var baseGetTag = require_baseGetTag();
      var isObjectLike = require_isObjectLike();
      var argsTag = "[object Arguments]";
      function baseIsArguments(value) {
        return isObjectLike(value) && baseGetTag(value) == argsTag;
      }
      module2.exports = baseIsArguments;
    }
  });

  // node_modules/lodash/isArguments.js
  var require_isArguments = __commonJS({
    "node_modules/lodash/isArguments.js"(exports, module2) {
      var baseIsArguments = require_baseIsArguments();
      var isObjectLike = require_isObjectLike();
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      var propertyIsEnumerable = objectProto.propertyIsEnumerable;
      var isArguments = baseIsArguments(function() {
        return arguments;
      }()) ? baseIsArguments : function(value) {
        return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
      };
      module2.exports = isArguments;
    }
  });

  // node_modules/lodash/isArray.js
  var require_isArray = __commonJS({
    "node_modules/lodash/isArray.js"(exports, module2) {
      var isArray = Array.isArray;
      module2.exports = isArray;
    }
  });

  // node_modules/lodash/stubFalse.js
  var require_stubFalse = __commonJS({
    "node_modules/lodash/stubFalse.js"(exports, module2) {
      function stubFalse() {
        return false;
      }
      module2.exports = stubFalse;
    }
  });

  // node_modules/lodash/isBuffer.js
  var require_isBuffer = __commonJS({
    "node_modules/lodash/isBuffer.js"(exports, module2) {
      var root = require_root();
      var stubFalse = require_stubFalse();
      var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var Buffer3 = moduleExports ? root.Buffer : void 0;
      var nativeIsBuffer = Buffer3 ? Buffer3.isBuffer : void 0;
      var isBuffer = nativeIsBuffer || stubFalse;
      module2.exports = isBuffer;
    }
  });

  // node_modules/lodash/_isIndex.js
  var require_isIndex = __commonJS({
    "node_modules/lodash/_isIndex.js"(exports, module2) {
      var MAX_SAFE_INTEGER = 9007199254740991;
      var reIsUint = /^(?:0|[1-9]\d*)$/;
      function isIndex(value, length) {
        var type = typeof value;
        length = length == null ? MAX_SAFE_INTEGER : length;
        return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
      }
      module2.exports = isIndex;
    }
  });

  // node_modules/lodash/isLength.js
  var require_isLength = __commonJS({
    "node_modules/lodash/isLength.js"(exports, module2) {
      var MAX_SAFE_INTEGER = 9007199254740991;
      function isLength(value) {
        return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
      }
      module2.exports = isLength;
    }
  });

  // node_modules/lodash/_baseIsTypedArray.js
  var require_baseIsTypedArray = __commonJS({
    "node_modules/lodash/_baseIsTypedArray.js"(exports, module2) {
      var baseGetTag = require_baseGetTag();
      var isLength = require_isLength();
      var isObjectLike = require_isObjectLike();
      var argsTag = "[object Arguments]";
      var arrayTag = "[object Array]";
      var boolTag = "[object Boolean]";
      var dateTag = "[object Date]";
      var errorTag = "[object Error]";
      var funcTag = "[object Function]";
      var mapTag = "[object Map]";
      var numberTag = "[object Number]";
      var objectTag = "[object Object]";
      var regexpTag = "[object RegExp]";
      var setTag = "[object Set]";
      var stringTag = "[object String]";
      var weakMapTag = "[object WeakMap]";
      var arrayBufferTag = "[object ArrayBuffer]";
      var dataViewTag = "[object DataView]";
      var float32Tag = "[object Float32Array]";
      var float64Tag = "[object Float64Array]";
      var int8Tag = "[object Int8Array]";
      var int16Tag = "[object Int16Array]";
      var int32Tag = "[object Int32Array]";
      var uint8Tag = "[object Uint8Array]";
      var uint8ClampedTag = "[object Uint8ClampedArray]";
      var uint16Tag = "[object Uint16Array]";
      var uint32Tag = "[object Uint32Array]";
      var typedArrayTags = {};
      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
      typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
      function baseIsTypedArray(value) {
        return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
      }
      module2.exports = baseIsTypedArray;
    }
  });

  // node_modules/lodash/_baseUnary.js
  var require_baseUnary = __commonJS({
    "node_modules/lodash/_baseUnary.js"(exports, module2) {
      function baseUnary(func) {
        return function(value) {
          return func(value);
        };
      }
      module2.exports = baseUnary;
    }
  });

  // node_modules/lodash/_nodeUtil.js
  var require_nodeUtil = __commonJS({
    "node_modules/lodash/_nodeUtil.js"(exports, module2) {
      var freeGlobal = require_freeGlobal();
      var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var freeProcess = moduleExports && freeGlobal.process;
      var nodeUtil = function() {
        try {
          var types = freeModule && freeModule.require && freeModule.require("util").types;
          if (types) {
            return types;
          }
          return freeProcess && freeProcess.binding && freeProcess.binding("util");
        } catch (e) {
        }
      }();
      module2.exports = nodeUtil;
    }
  });

  // node_modules/lodash/isTypedArray.js
  var require_isTypedArray = __commonJS({
    "node_modules/lodash/isTypedArray.js"(exports, module2) {
      var baseIsTypedArray = require_baseIsTypedArray();
      var baseUnary = require_baseUnary();
      var nodeUtil = require_nodeUtil();
      var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
      var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
      module2.exports = isTypedArray;
    }
  });

  // node_modules/lodash/_arrayLikeKeys.js
  var require_arrayLikeKeys = __commonJS({
    "node_modules/lodash/_arrayLikeKeys.js"(exports, module2) {
      var baseTimes = require_baseTimes();
      var isArguments = require_isArguments();
      var isArray = require_isArray();
      var isBuffer = require_isBuffer();
      var isIndex = require_isIndex();
      var isTypedArray = require_isTypedArray();
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      function arrayLikeKeys(value, inherited) {
        var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
        for (var key in value) {
          if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex(key, length)))) {
            result.push(key);
          }
        }
        return result;
      }
      module2.exports = arrayLikeKeys;
    }
  });

  // node_modules/lodash/_isPrototype.js
  var require_isPrototype = __commonJS({
    "node_modules/lodash/_isPrototype.js"(exports, module2) {
      var objectProto = Object.prototype;
      function isPrototype(value) {
        var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
        return value === proto;
      }
      module2.exports = isPrototype;
    }
  });

  // node_modules/lodash/_overArg.js
  var require_overArg = __commonJS({
    "node_modules/lodash/_overArg.js"(exports, module2) {
      function overArg(func, transform) {
        return function(arg) {
          return func(transform(arg));
        };
      }
      module2.exports = overArg;
    }
  });

  // node_modules/lodash/_nativeKeys.js
  var require_nativeKeys = __commonJS({
    "node_modules/lodash/_nativeKeys.js"(exports, module2) {
      var overArg = require_overArg();
      var nativeKeys = overArg(Object.keys, Object);
      module2.exports = nativeKeys;
    }
  });

  // node_modules/lodash/_baseKeys.js
  var require_baseKeys = __commonJS({
    "node_modules/lodash/_baseKeys.js"(exports, module2) {
      var isPrototype = require_isPrototype();
      var nativeKeys = require_nativeKeys();
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      function baseKeys(object) {
        if (!isPrototype(object)) {
          return nativeKeys(object);
        }
        var result = [];
        for (var key in Object(object)) {
          if (hasOwnProperty.call(object, key) && key != "constructor") {
            result.push(key);
          }
        }
        return result;
      }
      module2.exports = baseKeys;
    }
  });

  // node_modules/lodash/isArrayLike.js
  var require_isArrayLike = __commonJS({
    "node_modules/lodash/isArrayLike.js"(exports, module2) {
      var isFunction = require_isFunction();
      var isLength = require_isLength();
      function isArrayLike(value) {
        return value != null && isLength(value.length) && !isFunction(value);
      }
      module2.exports = isArrayLike;
    }
  });

  // node_modules/lodash/keys.js
  var require_keys = __commonJS({
    "node_modules/lodash/keys.js"(exports, module2) {
      var arrayLikeKeys = require_arrayLikeKeys();
      var baseKeys = require_baseKeys();
      var isArrayLike = require_isArrayLike();
      function keys(object) {
        return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
      }
      module2.exports = keys;
    }
  });

  // node_modules/lodash/_baseAssign.js
  var require_baseAssign = __commonJS({
    "node_modules/lodash/_baseAssign.js"(exports, module2) {
      var copyObject = require_copyObject();
      var keys = require_keys();
      function baseAssign(object, source) {
        return object && copyObject(source, keys(source), object);
      }
      module2.exports = baseAssign;
    }
  });

  // node_modules/lodash/_nativeKeysIn.js
  var require_nativeKeysIn = __commonJS({
    "node_modules/lodash/_nativeKeysIn.js"(exports, module2) {
      function nativeKeysIn(object) {
        var result = [];
        if (object != null) {
          for (var key in Object(object)) {
            result.push(key);
          }
        }
        return result;
      }
      module2.exports = nativeKeysIn;
    }
  });

  // node_modules/lodash/_baseKeysIn.js
  var require_baseKeysIn = __commonJS({
    "node_modules/lodash/_baseKeysIn.js"(exports, module2) {
      var isObject2 = require_isObject();
      var isPrototype = require_isPrototype();
      var nativeKeysIn = require_nativeKeysIn();
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      function baseKeysIn(object) {
        if (!isObject2(object)) {
          return nativeKeysIn(object);
        }
        var isProto = isPrototype(object), result = [];
        for (var key in object) {
          if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
            result.push(key);
          }
        }
        return result;
      }
      module2.exports = baseKeysIn;
    }
  });

  // node_modules/lodash/keysIn.js
  var require_keysIn = __commonJS({
    "node_modules/lodash/keysIn.js"(exports, module2) {
      var arrayLikeKeys = require_arrayLikeKeys();
      var baseKeysIn = require_baseKeysIn();
      var isArrayLike = require_isArrayLike();
      function keysIn(object) {
        return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
      }
      module2.exports = keysIn;
    }
  });

  // node_modules/lodash/_baseAssignIn.js
  var require_baseAssignIn = __commonJS({
    "node_modules/lodash/_baseAssignIn.js"(exports, module2) {
      var copyObject = require_copyObject();
      var keysIn = require_keysIn();
      function baseAssignIn(object, source) {
        return object && copyObject(source, keysIn(source), object);
      }
      module2.exports = baseAssignIn;
    }
  });

  // node_modules/lodash/_cloneBuffer.js
  var require_cloneBuffer = __commonJS({
    "node_modules/lodash/_cloneBuffer.js"(exports, module2) {
      var root = require_root();
      var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var Buffer3 = moduleExports ? root.Buffer : void 0;
      var allocUnsafe = Buffer3 ? Buffer3.allocUnsafe : void 0;
      function cloneBuffer(buffer, isDeep) {
        if (isDeep) {
          return buffer.slice();
        }
        var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
        buffer.copy(result);
        return result;
      }
      module2.exports = cloneBuffer;
    }
  });

  // node_modules/lodash/_copyArray.js
  var require_copyArray = __commonJS({
    "node_modules/lodash/_copyArray.js"(exports, module2) {
      function copyArray(source, array) {
        var index = -1, length = source.length;
        array || (array = Array(length));
        while (++index < length) {
          array[index] = source[index];
        }
        return array;
      }
      module2.exports = copyArray;
    }
  });

  // node_modules/lodash/_arrayFilter.js
  var require_arrayFilter = __commonJS({
    "node_modules/lodash/_arrayFilter.js"(exports, module2) {
      function arrayFilter(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
        while (++index < length) {
          var value = array[index];
          if (predicate(value, index, array)) {
            result[resIndex++] = value;
          }
        }
        return result;
      }
      module2.exports = arrayFilter;
    }
  });

  // node_modules/lodash/stubArray.js
  var require_stubArray = __commonJS({
    "node_modules/lodash/stubArray.js"(exports, module2) {
      function stubArray() {
        return [];
      }
      module2.exports = stubArray;
    }
  });

  // node_modules/lodash/_getSymbols.js
  var require_getSymbols = __commonJS({
    "node_modules/lodash/_getSymbols.js"(exports, module2) {
      var arrayFilter = require_arrayFilter();
      var stubArray = require_stubArray();
      var objectProto = Object.prototype;
      var propertyIsEnumerable = objectProto.propertyIsEnumerable;
      var nativeGetSymbols = Object.getOwnPropertySymbols;
      var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
        if (object == null) {
          return [];
        }
        object = Object(object);
        return arrayFilter(nativeGetSymbols(object), function(symbol) {
          return propertyIsEnumerable.call(object, symbol);
        });
      };
      module2.exports = getSymbols;
    }
  });

  // node_modules/lodash/_copySymbols.js
  var require_copySymbols = __commonJS({
    "node_modules/lodash/_copySymbols.js"(exports, module2) {
      var copyObject = require_copyObject();
      var getSymbols = require_getSymbols();
      function copySymbols(source, object) {
        return copyObject(source, getSymbols(source), object);
      }
      module2.exports = copySymbols;
    }
  });

  // node_modules/lodash/_arrayPush.js
  var require_arrayPush = __commonJS({
    "node_modules/lodash/_arrayPush.js"(exports, module2) {
      function arrayPush(array, values) {
        var index = -1, length = values.length, offset = array.length;
        while (++index < length) {
          array[offset + index] = values[index];
        }
        return array;
      }
      module2.exports = arrayPush;
    }
  });

  // node_modules/lodash/_getPrototype.js
  var require_getPrototype = __commonJS({
    "node_modules/lodash/_getPrototype.js"(exports, module2) {
      var overArg = require_overArg();
      var getPrototype = overArg(Object.getPrototypeOf, Object);
      module2.exports = getPrototype;
    }
  });

  // node_modules/lodash/_getSymbolsIn.js
  var require_getSymbolsIn = __commonJS({
    "node_modules/lodash/_getSymbolsIn.js"(exports, module2) {
      var arrayPush = require_arrayPush();
      var getPrototype = require_getPrototype();
      var getSymbols = require_getSymbols();
      var stubArray = require_stubArray();
      var nativeGetSymbols = Object.getOwnPropertySymbols;
      var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
        var result = [];
        while (object) {
          arrayPush(result, getSymbols(object));
          object = getPrototype(object);
        }
        return result;
      };
      module2.exports = getSymbolsIn;
    }
  });

  // node_modules/lodash/_copySymbolsIn.js
  var require_copySymbolsIn = __commonJS({
    "node_modules/lodash/_copySymbolsIn.js"(exports, module2) {
      var copyObject = require_copyObject();
      var getSymbolsIn = require_getSymbolsIn();
      function copySymbolsIn(source, object) {
        return copyObject(source, getSymbolsIn(source), object);
      }
      module2.exports = copySymbolsIn;
    }
  });

  // node_modules/lodash/_baseGetAllKeys.js
  var require_baseGetAllKeys = __commonJS({
    "node_modules/lodash/_baseGetAllKeys.js"(exports, module2) {
      var arrayPush = require_arrayPush();
      var isArray = require_isArray();
      function baseGetAllKeys(object, keysFunc, symbolsFunc) {
        var result = keysFunc(object);
        return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
      }
      module2.exports = baseGetAllKeys;
    }
  });

  // node_modules/lodash/_getAllKeys.js
  var require_getAllKeys = __commonJS({
    "node_modules/lodash/_getAllKeys.js"(exports, module2) {
      var baseGetAllKeys = require_baseGetAllKeys();
      var getSymbols = require_getSymbols();
      var keys = require_keys();
      function getAllKeys(object) {
        return baseGetAllKeys(object, keys, getSymbols);
      }
      module2.exports = getAllKeys;
    }
  });

  // node_modules/lodash/_getAllKeysIn.js
  var require_getAllKeysIn = __commonJS({
    "node_modules/lodash/_getAllKeysIn.js"(exports, module2) {
      var baseGetAllKeys = require_baseGetAllKeys();
      var getSymbolsIn = require_getSymbolsIn();
      var keysIn = require_keysIn();
      function getAllKeysIn(object) {
        return baseGetAllKeys(object, keysIn, getSymbolsIn);
      }
      module2.exports = getAllKeysIn;
    }
  });

  // node_modules/lodash/_DataView.js
  var require_DataView = __commonJS({
    "node_modules/lodash/_DataView.js"(exports, module2) {
      var getNative = require_getNative();
      var root = require_root();
      var DataView2 = getNative(root, "DataView");
      module2.exports = DataView2;
    }
  });

  // node_modules/lodash/_Promise.js
  var require_Promise = __commonJS({
    "node_modules/lodash/_Promise.js"(exports, module2) {
      var getNative = require_getNative();
      var root = require_root();
      var Promise2 = getNative(root, "Promise");
      module2.exports = Promise2;
    }
  });

  // node_modules/lodash/_Set.js
  var require_Set = __commonJS({
    "node_modules/lodash/_Set.js"(exports, module2) {
      var getNative = require_getNative();
      var root = require_root();
      var Set2 = getNative(root, "Set");
      module2.exports = Set2;
    }
  });

  // node_modules/lodash/_WeakMap.js
  var require_WeakMap = __commonJS({
    "node_modules/lodash/_WeakMap.js"(exports, module2) {
      var getNative = require_getNative();
      var root = require_root();
      var WeakMap2 = getNative(root, "WeakMap");
      module2.exports = WeakMap2;
    }
  });

  // node_modules/lodash/_getTag.js
  var require_getTag = __commonJS({
    "node_modules/lodash/_getTag.js"(exports, module2) {
      var DataView2 = require_DataView();
      var Map2 = require_Map();
      var Promise2 = require_Promise();
      var Set2 = require_Set();
      var WeakMap2 = require_WeakMap();
      var baseGetTag = require_baseGetTag();
      var toSource = require_toSource();
      var mapTag = "[object Map]";
      var objectTag = "[object Object]";
      var promiseTag = "[object Promise]";
      var setTag = "[object Set]";
      var weakMapTag = "[object WeakMap]";
      var dataViewTag = "[object DataView]";
      var dataViewCtorString = toSource(DataView2);
      var mapCtorString = toSource(Map2);
      var promiseCtorString = toSource(Promise2);
      var setCtorString = toSource(Set2);
      var weakMapCtorString = toSource(WeakMap2);
      var getTag2 = baseGetTag;
      if (DataView2 && getTag2(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag2(new Map2()) != mapTag || Promise2 && getTag2(Promise2.resolve()) != promiseTag || Set2 && getTag2(new Set2()) != setTag || WeakMap2 && getTag2(new WeakMap2()) != weakMapTag) {
        getTag2 = function(value) {
          var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
          if (ctorString) {
            switch (ctorString) {
              case dataViewCtorString:
                return dataViewTag;
              case mapCtorString:
                return mapTag;
              case promiseCtorString:
                return promiseTag;
              case setCtorString:
                return setTag;
              case weakMapCtorString:
                return weakMapTag;
            }
          }
          return result;
        };
      }
      module2.exports = getTag2;
    }
  });

  // node_modules/lodash/_initCloneArray.js
  var require_initCloneArray = __commonJS({
    "node_modules/lodash/_initCloneArray.js"(exports, module2) {
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      function initCloneArray(array) {
        var length = array.length, result = new array.constructor(length);
        if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
          result.index = array.index;
          result.input = array.input;
        }
        return result;
      }
      module2.exports = initCloneArray;
    }
  });

  // node_modules/lodash/_Uint8Array.js
  var require_Uint8Array = __commonJS({
    "node_modules/lodash/_Uint8Array.js"(exports, module2) {
      var root = require_root();
      var Uint8Array2 = root.Uint8Array;
      module2.exports = Uint8Array2;
    }
  });

  // node_modules/lodash/_cloneArrayBuffer.js
  var require_cloneArrayBuffer = __commonJS({
    "node_modules/lodash/_cloneArrayBuffer.js"(exports, module2) {
      var Uint8Array2 = require_Uint8Array();
      function cloneArrayBuffer(arrayBuffer) {
        var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
        new Uint8Array2(result).set(new Uint8Array2(arrayBuffer));
        return result;
      }
      module2.exports = cloneArrayBuffer;
    }
  });

  // node_modules/lodash/_cloneDataView.js
  var require_cloneDataView = __commonJS({
    "node_modules/lodash/_cloneDataView.js"(exports, module2) {
      var cloneArrayBuffer = require_cloneArrayBuffer();
      function cloneDataView(dataView, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
        return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
      }
      module2.exports = cloneDataView;
    }
  });

  // node_modules/lodash/_cloneRegExp.js
  var require_cloneRegExp = __commonJS({
    "node_modules/lodash/_cloneRegExp.js"(exports, module2) {
      var reFlags = /\w*$/;
      function cloneRegExp(regexp) {
        var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
        result.lastIndex = regexp.lastIndex;
        return result;
      }
      module2.exports = cloneRegExp;
    }
  });

  // node_modules/lodash/_cloneSymbol.js
  var require_cloneSymbol = __commonJS({
    "node_modules/lodash/_cloneSymbol.js"(exports, module2) {
      var Symbol2 = require_Symbol();
      var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
      var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
      function cloneSymbol(symbol) {
        return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
      }
      module2.exports = cloneSymbol;
    }
  });

  // node_modules/lodash/_cloneTypedArray.js
  var require_cloneTypedArray = __commonJS({
    "node_modules/lodash/_cloneTypedArray.js"(exports, module2) {
      var cloneArrayBuffer = require_cloneArrayBuffer();
      function cloneTypedArray(typedArray, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
        return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
      }
      module2.exports = cloneTypedArray;
    }
  });

  // node_modules/lodash/_initCloneByTag.js
  var require_initCloneByTag = __commonJS({
    "node_modules/lodash/_initCloneByTag.js"(exports, module2) {
      var cloneArrayBuffer = require_cloneArrayBuffer();
      var cloneDataView = require_cloneDataView();
      var cloneRegExp = require_cloneRegExp();
      var cloneSymbol = require_cloneSymbol();
      var cloneTypedArray = require_cloneTypedArray();
      var boolTag = "[object Boolean]";
      var dateTag = "[object Date]";
      var mapTag = "[object Map]";
      var numberTag = "[object Number]";
      var regexpTag = "[object RegExp]";
      var setTag = "[object Set]";
      var stringTag = "[object String]";
      var symbolTag = "[object Symbol]";
      var arrayBufferTag = "[object ArrayBuffer]";
      var dataViewTag = "[object DataView]";
      var float32Tag = "[object Float32Array]";
      var float64Tag = "[object Float64Array]";
      var int8Tag = "[object Int8Array]";
      var int16Tag = "[object Int16Array]";
      var int32Tag = "[object Int32Array]";
      var uint8Tag = "[object Uint8Array]";
      var uint8ClampedTag = "[object Uint8ClampedArray]";
      var uint16Tag = "[object Uint16Array]";
      var uint32Tag = "[object Uint32Array]";
      function initCloneByTag(object, tag, isDeep) {
        var Ctor = object.constructor;
        switch (tag) {
          case arrayBufferTag:
            return cloneArrayBuffer(object);
          case boolTag:
          case dateTag:
            return new Ctor(+object);
          case dataViewTag:
            return cloneDataView(object, isDeep);
          case float32Tag:
          case float64Tag:
          case int8Tag:
          case int16Tag:
          case int32Tag:
          case uint8Tag:
          case uint8ClampedTag:
          case uint16Tag:
          case uint32Tag:
            return cloneTypedArray(object, isDeep);
          case mapTag:
            return new Ctor();
          case numberTag:
          case stringTag:
            return new Ctor(object);
          case regexpTag:
            return cloneRegExp(object);
          case setTag:
            return new Ctor();
          case symbolTag:
            return cloneSymbol(object);
        }
      }
      module2.exports = initCloneByTag;
    }
  });

  // node_modules/lodash/_baseCreate.js
  var require_baseCreate = __commonJS({
    "node_modules/lodash/_baseCreate.js"(exports, module2) {
      var isObject2 = require_isObject();
      var objectCreate = Object.create;
      var baseCreate = function() {
        function object() {
        }
        return function(proto) {
          if (!isObject2(proto)) {
            return {};
          }
          if (objectCreate) {
            return objectCreate(proto);
          }
          object.prototype = proto;
          var result = new object();
          object.prototype = void 0;
          return result;
        };
      }();
      module2.exports = baseCreate;
    }
  });

  // node_modules/lodash/_initCloneObject.js
  var require_initCloneObject = __commonJS({
    "node_modules/lodash/_initCloneObject.js"(exports, module2) {
      var baseCreate = require_baseCreate();
      var getPrototype = require_getPrototype();
      var isPrototype = require_isPrototype();
      function initCloneObject(object) {
        return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
      }
      module2.exports = initCloneObject;
    }
  });

  // node_modules/lodash/_baseIsMap.js
  var require_baseIsMap = __commonJS({
    "node_modules/lodash/_baseIsMap.js"(exports, module2) {
      var getTag2 = require_getTag();
      var isObjectLike = require_isObjectLike();
      var mapTag = "[object Map]";
      function baseIsMap(value) {
        return isObjectLike(value) && getTag2(value) == mapTag;
      }
      module2.exports = baseIsMap;
    }
  });

  // node_modules/lodash/isMap.js
  var require_isMap = __commonJS({
    "node_modules/lodash/isMap.js"(exports, module2) {
      var baseIsMap = require_baseIsMap();
      var baseUnary = require_baseUnary();
      var nodeUtil = require_nodeUtil();
      var nodeIsMap = nodeUtil && nodeUtil.isMap;
      var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
      module2.exports = isMap;
    }
  });

  // node_modules/lodash/_baseIsSet.js
  var require_baseIsSet = __commonJS({
    "node_modules/lodash/_baseIsSet.js"(exports, module2) {
      var getTag2 = require_getTag();
      var isObjectLike = require_isObjectLike();
      var setTag = "[object Set]";
      function baseIsSet(value) {
        return isObjectLike(value) && getTag2(value) == setTag;
      }
      module2.exports = baseIsSet;
    }
  });

  // node_modules/lodash/isSet.js
  var require_isSet = __commonJS({
    "node_modules/lodash/isSet.js"(exports, module2) {
      var baseIsSet = require_baseIsSet();
      var baseUnary = require_baseUnary();
      var nodeUtil = require_nodeUtil();
      var nodeIsSet = nodeUtil && nodeUtil.isSet;
      var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
      module2.exports = isSet;
    }
  });

  // node_modules/lodash/_baseClone.js
  var require_baseClone = __commonJS({
    "node_modules/lodash/_baseClone.js"(exports, module2) {
      var Stack = require_Stack();
      var arrayEach = require_arrayEach();
      var assignValue = require_assignValue();
      var baseAssign = require_baseAssign();
      var baseAssignIn = require_baseAssignIn();
      var cloneBuffer = require_cloneBuffer();
      var copyArray = require_copyArray();
      var copySymbols = require_copySymbols();
      var copySymbolsIn = require_copySymbolsIn();
      var getAllKeys = require_getAllKeys();
      var getAllKeysIn = require_getAllKeysIn();
      var getTag2 = require_getTag();
      var initCloneArray = require_initCloneArray();
      var initCloneByTag = require_initCloneByTag();
      var initCloneObject = require_initCloneObject();
      var isArray = require_isArray();
      var isBuffer = require_isBuffer();
      var isMap = require_isMap();
      var isObject2 = require_isObject();
      var isSet = require_isSet();
      var keys = require_keys();
      var keysIn = require_keysIn();
      var CLONE_DEEP_FLAG = 1;
      var CLONE_FLAT_FLAG = 2;
      var CLONE_SYMBOLS_FLAG = 4;
      var argsTag = "[object Arguments]";
      var arrayTag = "[object Array]";
      var boolTag = "[object Boolean]";
      var dateTag = "[object Date]";
      var errorTag = "[object Error]";
      var funcTag = "[object Function]";
      var genTag = "[object GeneratorFunction]";
      var mapTag = "[object Map]";
      var numberTag = "[object Number]";
      var objectTag = "[object Object]";
      var regexpTag = "[object RegExp]";
      var setTag = "[object Set]";
      var stringTag = "[object String]";
      var symbolTag = "[object Symbol]";
      var weakMapTag = "[object WeakMap]";
      var arrayBufferTag = "[object ArrayBuffer]";
      var dataViewTag = "[object DataView]";
      var float32Tag = "[object Float32Array]";
      var float64Tag = "[object Float64Array]";
      var int8Tag = "[object Int8Array]";
      var int16Tag = "[object Int16Array]";
      var int32Tag = "[object Int32Array]";
      var uint8Tag = "[object Uint8Array]";
      var uint8ClampedTag = "[object Uint8ClampedArray]";
      var uint16Tag = "[object Uint16Array]";
      var uint32Tag = "[object Uint32Array]";
      var cloneableTags = {};
      cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
      cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
      function baseClone(value, bitmask, customizer, key, object, stack) {
        var result, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
        if (customizer) {
          result = object ? customizer(value, key, object, stack) : customizer(value);
        }
        if (result !== void 0) {
          return result;
        }
        if (!isObject2(value)) {
          return value;
        }
        var isArr = isArray(value);
        if (isArr) {
          result = initCloneArray(value);
          if (!isDeep) {
            return copyArray(value, result);
          }
        } else {
          var tag = getTag2(value), isFunc = tag == funcTag || tag == genTag;
          if (isBuffer(value)) {
            return cloneBuffer(value, isDeep);
          }
          if (tag == objectTag || tag == argsTag || isFunc && !object) {
            result = isFlat || isFunc ? {} : initCloneObject(value);
            if (!isDeep) {
              return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
            }
          } else {
            if (!cloneableTags[tag]) {
              return object ? value : {};
            }
            result = initCloneByTag(value, tag, isDeep);
          }
        }
        stack || (stack = new Stack());
        var stacked = stack.get(value);
        if (stacked) {
          return stacked;
        }
        stack.set(value, result);
        if (isSet(value)) {
          value.forEach(function(subValue) {
            result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
          });
        } else if (isMap(value)) {
          value.forEach(function(subValue, key2) {
            result.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
          });
        }
        var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
        var props = isArr ? void 0 : keysFunc(value);
        arrayEach(props || value, function(subValue, key2) {
          if (props) {
            key2 = subValue;
            subValue = value[key2];
          }
          assignValue(result, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
        });
        return result;
      }
      module2.exports = baseClone;
    }
  });

  // node_modules/lodash/cloneDeep.js
  var require_cloneDeep = __commonJS({
    "node_modules/lodash/cloneDeep.js"(exports, module2) {
      var baseClone = require_baseClone();
      var CLONE_DEEP_FLAG = 1;
      var CLONE_SYMBOLS_FLAG = 4;
      function cloneDeep2(value) {
        return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
      }
      module2.exports = cloneDeep2;
    }
  });

  // node_modules/fast-copy/dist/fast-copy.js
  var require_fast_copy = __commonJS({
    "node_modules/fast-copy/dist/fast-copy.js"(exports, module2) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module2 !== "undefined" ? module2.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, global2["fast-copy"] = factory());
      })(exports, function() {
        "use strict";
        var toStringFunction = Function.prototype.toString;
        var create = Object.create, defineProperty = Object.defineProperty, getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor, getOwnPropertyNames = Object.getOwnPropertyNames, getOwnPropertySymbols = Object.getOwnPropertySymbols, getPrototypeOf = Object.getPrototypeOf;
        var _a = Object.prototype, hasOwnProperty = _a.hasOwnProperty, propertyIsEnumerable = _a.propertyIsEnumerable;
        var SUPPORTS = {
          SYMBOL_PROPERTIES: typeof getOwnPropertySymbols === "function",
          WEAKMAP: typeof WeakMap === "function"
        };
        var createCache = function() {
          if (SUPPORTS.WEAKMAP) {
            return new WeakMap();
          }
          var object = create({
            has: function(key) {
              return !!~object._keys.indexOf(key);
            },
            set: function(key, value) {
              object._keys.push(key);
              object._values.push(value);
            },
            get: function(key) {
              return object._values[object._keys.indexOf(key)];
            }
          });
          object._keys = [];
          object._values = [];
          return object;
        };
        var getCleanClone = function(object, realm) {
          if (!object.constructor) {
            return create(null);
          }
          var Constructor = object.constructor;
          var prototype = object.__proto__ || getPrototypeOf(object);
          if (Constructor === realm.Object) {
            return prototype === realm.Object.prototype ? {} : create(prototype);
          }
          if (~toStringFunction.call(Constructor).indexOf("[native code]")) {
            try {
              return new Constructor();
            } catch (_a2) {
            }
          }
          return create(prototype);
        };
        var getObjectCloneLoose = function(object, realm, handleCopy, cache) {
          var clone = getCleanClone(object, realm);
          cache.set(object, clone);
          for (var key in object) {
            if (hasOwnProperty.call(object, key)) {
              clone[key] = handleCopy(object[key], cache);
            }
          }
          if (SUPPORTS.SYMBOL_PROPERTIES) {
            var symbols = getOwnPropertySymbols(object);
            var length_1 = symbols.length;
            if (length_1) {
              for (var index = 0, symbol = void 0; index < length_1; index++) {
                symbol = symbols[index];
                if (propertyIsEnumerable.call(object, symbol)) {
                  clone[symbol] = handleCopy(object[symbol], cache);
                }
              }
            }
          }
          return clone;
        };
        var getObjectCloneStrict = function(object, realm, handleCopy, cache) {
          var clone = getCleanClone(object, realm);
          cache.set(object, clone);
          var properties = SUPPORTS.SYMBOL_PROPERTIES ? getOwnPropertyNames(object).concat(getOwnPropertySymbols(object)) : getOwnPropertyNames(object);
          var length = properties.length;
          if (length) {
            for (var index = 0, property = void 0, descriptor = void 0; index < length; index++) {
              property = properties[index];
              if (property !== "callee" && property !== "caller") {
                descriptor = getOwnPropertyDescriptor(object, property);
                if (descriptor) {
                  if (!descriptor.get && !descriptor.set) {
                    descriptor.value = handleCopy(object[property], cache);
                  }
                  try {
                    defineProperty(clone, property, descriptor);
                  } catch (error) {
                    clone[property] = descriptor.value;
                  }
                } else {
                  clone[property] = handleCopy(object[property], cache);
                }
              }
            }
          }
          return clone;
        };
        var getRegExpFlags = function(regExp) {
          var flags = "";
          if (regExp.global) {
            flags += "g";
          }
          if (regExp.ignoreCase) {
            flags += "i";
          }
          if (regExp.multiline) {
            flags += "m";
          }
          if (regExp.unicode) {
            flags += "u";
          }
          if (regExp.sticky) {
            flags += "y";
          }
          return flags;
        };
        var isArray = Array.isArray;
        var GLOBAL_THIS = function() {
          if (typeof self !== "undefined") {
            return self;
          }
          if (typeof window !== "undefined") {
            return window;
          }
          if (typeof global !== "undefined") {
            return global;
          }
          if (console && console.error) {
            console.error('Unable to locate global object, returning "this".');
          }
        }();
        function copy2(object, options) {
          var isStrict = !!(options && options.isStrict);
          var realm = options && options.realm || GLOBAL_THIS;
          var getObjectClone = isStrict ? getObjectCloneStrict : getObjectCloneLoose;
          var handleCopy = function(object2, cache) {
            if (!object2 || typeof object2 !== "object") {
              return object2;
            }
            if (cache.has(object2)) {
              return cache.get(object2);
            }
            var Constructor = object2.constructor;
            if (Constructor === realm.Object) {
              return getObjectClone(object2, realm, handleCopy, cache);
            }
            var clone;
            if (isArray(object2)) {
              if (isStrict) {
                return getObjectCloneStrict(object2, realm, handleCopy, cache);
              }
              var length_1 = object2.length;
              clone = new Constructor();
              cache.set(object2, clone);
              for (var index = 0; index < length_1; index++) {
                clone[index] = handleCopy(object2[index], cache);
              }
              return clone;
            }
            if (object2 instanceof realm.Date) {
              return new Constructor(object2.getTime());
            }
            if (object2 instanceof realm.RegExp) {
              clone = new Constructor(object2.source, object2.flags || getRegExpFlags(object2));
              clone.lastIndex = object2.lastIndex;
              return clone;
            }
            if (realm.Map && object2 instanceof realm.Map) {
              clone = new Constructor();
              cache.set(object2, clone);
              object2.forEach(function(value, key) {
                clone.set(key, handleCopy(value, cache));
              });
              return clone;
            }
            if (realm.Set && object2 instanceof realm.Set) {
              clone = new Constructor();
              cache.set(object2, clone);
              object2.forEach(function(value) {
                clone.add(handleCopy(value, cache));
              });
              return clone;
            }
            if (realm.Blob && object2 instanceof realm.Blob) {
              return object2.slice(0, object2.size, object2.type);
            }
            if (realm.Buffer && realm.Buffer.isBuffer(object2)) {
              clone = realm.Buffer.allocUnsafe ? realm.Buffer.allocUnsafe(object2.length) : new Constructor(object2.length);
              cache.set(object2, clone);
              object2.copy(clone);
              return clone;
            }
            if (realm.ArrayBuffer) {
              if (realm.ArrayBuffer.isView(object2)) {
                clone = new Constructor(object2.buffer.slice(0));
                cache.set(object2, clone);
                return clone;
              }
              if (object2 instanceof realm.ArrayBuffer) {
                clone = object2.slice(0);
                cache.set(object2, clone);
                return clone;
              }
            }
            if (typeof object2.then === "function" || object2 instanceof Error || realm.WeakMap && object2 instanceof realm.WeakMap || realm.WeakSet && object2 instanceof realm.WeakSet) {
              return object2;
            }
            return getObjectClone(object2, realm, handleCopy, cache);
          };
          return handleCopy(object, createCache());
        }
        copy2.default = copy2;
        copy2.strict = function strictCopy(object, options) {
          return copy2(object, {
            isStrict: true,
            realm: options ? options.realm : void 0
          });
        };
        return copy2;
      });
    }
  });

  // node_modules/arweave/web/ar.js
  var require_ar2 = __commonJS({
    "node_modules/arweave/web/ar.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var bignumber_js_1 = require_bignumber();
      var Ar = class {
        constructor() {
          this.BigNum = (value, decimals) => {
            let instance = bignumber_js_1.BigNumber.clone({ DECIMAL_PLACES: decimals });
            return new instance(value);
          };
        }
        winstonToAr(winstonString, { formatted = false, decimals = 12, trim = true } = {}) {
          let number = this.stringToBigNum(winstonString, decimals).shiftedBy(-12);
          return formatted ? number.toFormat(decimals) : number.toFixed(decimals);
        }
        arToWinston(arString, { formatted = false } = {}) {
          let number = this.stringToBigNum(arString).shiftedBy(12);
          return formatted ? number.toFormat() : number.toFixed(0);
        }
        compare(winstonStringA, winstonStringB) {
          let a = this.stringToBigNum(winstonStringA);
          let b = this.stringToBigNum(winstonStringB);
          return a.comparedTo(b);
        }
        isEqual(winstonStringA, winstonStringB) {
          return this.compare(winstonStringA, winstonStringB) === 0;
        }
        isLessThan(winstonStringA, winstonStringB) {
          let a = this.stringToBigNum(winstonStringA);
          let b = this.stringToBigNum(winstonStringB);
          return a.isLessThan(b);
        }
        isGreaterThan(winstonStringA, winstonStringB) {
          let a = this.stringToBigNum(winstonStringA);
          let b = this.stringToBigNum(winstonStringB);
          return a.isGreaterThan(b);
        }
        add(winstonStringA, winstonStringB) {
          let a = this.stringToBigNum(winstonStringA);
          let b = this.stringToBigNum(winstonStringB);
          return a.plus(winstonStringB).toFixed(0);
        }
        sub(winstonStringA, winstonStringB) {
          let a = this.stringToBigNum(winstonStringA);
          let b = this.stringToBigNum(winstonStringB);
          return a.minus(winstonStringB).toFixed(0);
        }
        stringToBigNum(stringValue, decimalPlaces = 12) {
          return this.BigNum(stringValue, decimalPlaces);
        }
      };
      exports.default = Ar;
    }
  });

  // node_modules/arweave/web/lib/api.js
  var require_api2 = __commonJS({
    "node_modules/arweave/web/lib/api.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var axios_1 = require_axios2();
      var Api = class {
        constructor(config2) {
          this.METHOD_GET = "GET";
          this.METHOD_POST = "POST";
          this.applyConfig(config2);
        }
        applyConfig(config2) {
          this.config = this.mergeDefaults(config2);
        }
        getConfig() {
          return this.config;
        }
        mergeDefaults(config2) {
          const protocol = config2.protocol || "http";
          const port = config2.port || (protocol === "https" ? 443 : 80);
          return {
            host: config2.host || "127.0.0.1",
            protocol,
            port,
            timeout: config2.timeout || 2e4,
            logging: config2.logging || false,
            logger: config2.logger || console.log
          };
        }
        async get(endpoint, config2) {
          try {
            return await this.request().get(endpoint, config2);
          } catch (error) {
            if (error.response && error.response.status) {
              return error.response;
            }
            throw error;
          }
        }
        async post(endpoint, body, config2) {
          try {
            return await this.request().post(endpoint, body, config2);
          } catch (error) {
            if (error.response && error.response.status) {
              return error.response;
            }
            throw error;
          }
        }
        request() {
          let instance = axios_1.default.create({
            baseURL: `${this.config.protocol}://${this.config.host}:${this.config.port}`,
            timeout: this.config.timeout,
            maxContentLength: 1024 * 1024 * 512
          });
          if (this.config.logging) {
            instance.interceptors.request.use((request) => {
              this.config.logger(`Requesting: ${request.baseURL}/${request.url}`);
              return request;
            });
            instance.interceptors.response.use((response) => {
              this.config.logger(`Response:   ${response.config.url} - ${response.status}`);
              return response;
            });
          }
          return instance;
        }
      };
      exports.default = Api;
    }
  });

  // node_modules/arweave/web/network.js
  var require_network2 = __commonJS({
    "node_modules/arweave/web/network.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var Network = class {
        constructor(api) {
          this.api = api;
        }
        getInfo() {
          return this.api.get(`info`).then((response) => {
            return response.data;
          });
        }
        getPeers() {
          return this.api.get(`peers`).then((response) => {
            return response.data;
          });
        }
      };
      exports.default = Network;
    }
  });

  // node_modules/arweave/web/lib/error.js
  var require_error2 = __commonJS({
    "node_modules/arweave/web/lib/error.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getError = void 0;
      var ArweaveError = class extends Error {
        constructor(type, optional = {}) {
          if (optional.message) {
            super(optional.message);
          } else {
            super();
          }
          this.type = type;
          this.response = optional.response;
        }
        getType() {
          return this.type;
        }
      };
      exports.default = ArweaveError;
      function getError(resp) {
        let data = resp.data;
        if (typeof resp.data === "string") {
          try {
            data = JSON.parse(resp.data);
          } catch (e) {
          }
        }
        if (resp.data instanceof ArrayBuffer || resp.data instanceof Uint8Array) {
          try {
            data = JSON.parse(data.toString());
          } catch (e) {
          }
        }
        return data ? data.error || data : resp.statusText || "unknown";
      }
      exports.getError = getError;
    }
  });

  // node_modules/arweave/web/lib/utils.js
  var require_utils3 = __commonJS({
    "node_modules/arweave/web/lib/utils.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.b64UrlDecode = exports.b64UrlEncode = exports.bufferTob64Url = exports.bufferTob64 = exports.b64UrlToBuffer = exports.stringToB64Url = exports.stringToBuffer = exports.bufferToString = exports.b64UrlToString = exports.concatBuffers = void 0;
      var B64js = require_base64_js();
      function concatBuffers(buffers) {
        let total_length = 0;
        for (let i = 0; i < buffers.length; i++) {
          total_length += buffers[i].byteLength;
        }
        let temp = new Uint8Array(total_length);
        let offset = 0;
        temp.set(new Uint8Array(buffers[0]), offset);
        offset += buffers[0].byteLength;
        for (let i = 1; i < buffers.length; i++) {
          temp.set(new Uint8Array(buffers[i]), offset);
          offset += buffers[i].byteLength;
        }
        return temp;
      }
      exports.concatBuffers = concatBuffers;
      function b64UrlToString(b64UrlString) {
        let buffer = b64UrlToBuffer(b64UrlString);
        if (typeof TextDecoder == "undefined") {
          const TextDecoder2 = require_util().TextDecoder;
          return new TextDecoder2("utf-8", { fatal: true }).decode(buffer);
        }
        return new TextDecoder("utf-8", { fatal: true }).decode(buffer);
      }
      exports.b64UrlToString = b64UrlToString;
      function bufferToString(buffer) {
        if (typeof TextDecoder == "undefined") {
          const TextDecoder2 = require_util().TextDecoder;
          return new TextDecoder2("utf-8", { fatal: true }).decode(buffer);
        }
        return new TextDecoder("utf-8", { fatal: true }).decode(buffer);
      }
      exports.bufferToString = bufferToString;
      function stringToBuffer(string) {
        if (typeof TextEncoder == "undefined") {
          const TextEncoder2 = require_util().TextEncoder;
          return new TextEncoder2().encode(string);
        }
        return new TextEncoder().encode(string);
      }
      exports.stringToBuffer = stringToBuffer;
      function stringToB64Url(string) {
        return bufferTob64Url(stringToBuffer(string));
      }
      exports.stringToB64Url = stringToB64Url;
      function b64UrlToBuffer(b64UrlString) {
        return new Uint8Array(B64js.toByteArray(b64UrlDecode(b64UrlString)));
      }
      exports.b64UrlToBuffer = b64UrlToBuffer;
      function bufferTob64(buffer) {
        return B64js.fromByteArray(new Uint8Array(buffer));
      }
      exports.bufferTob64 = bufferTob64;
      function bufferTob64Url(buffer) {
        return b64UrlEncode(bufferTob64(buffer));
      }
      exports.bufferTob64Url = bufferTob64Url;
      function b64UrlEncode(b64UrlString) {
        return b64UrlString.replace(/\+/g, "-").replace(/\//g, "_").replace(/\=/g, "");
      }
      exports.b64UrlEncode = b64UrlEncode;
      function b64UrlDecode(b64UrlString) {
        b64UrlString = b64UrlString.replace(/\-/g, "+").replace(/\_/g, "/");
        let padding;
        b64UrlString.length % 4 == 0 ? padding = 0 : padding = 4 - b64UrlString.length % 4;
        return b64UrlString.concat("=".repeat(padding));
      }
      exports.b64UrlDecode = b64UrlDecode;
    }
  });

  // node_modules/arweave/web/lib/deepHash.js
  var require_deepHash2 = __commonJS({
    "node_modules/arweave/web/lib/deepHash.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var common_1 = require_common2();
      async function deepHash(data) {
        if (Array.isArray(data)) {
          const tag2 = common_1.default.utils.concatBuffers([
            common_1.default.utils.stringToBuffer("list"),
            common_1.default.utils.stringToBuffer(data.length.toString())
          ]);
          return await deepHashChunks(data, await common_1.default.crypto.hash(tag2, "SHA-384"));
        }
        const tag = common_1.default.utils.concatBuffers([
          common_1.default.utils.stringToBuffer("blob"),
          common_1.default.utils.stringToBuffer(data.byteLength.toString())
        ]);
        const taggedHash = common_1.default.utils.concatBuffers([
          await common_1.default.crypto.hash(tag, "SHA-384"),
          await common_1.default.crypto.hash(data, "SHA-384")
        ]);
        return await common_1.default.crypto.hash(taggedHash, "SHA-384");
      }
      exports.default = deepHash;
      async function deepHashChunks(chunks, acc) {
        if (chunks.length < 1) {
          return acc;
        }
        const hashPair = common_1.default.utils.concatBuffers([
          acc,
          await deepHash(chunks[0])
        ]);
        const newAcc = await common_1.default.crypto.hash(hashPair, "SHA-384");
        return await deepHashChunks(chunks.slice(1), newAcc);
      }
    }
  });

  // node_modules/arweave/web/lib/merkle.js
  var require_merkle2 = __commonJS({
    "node_modules/arweave/web/lib/merkle.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.debug = exports.validatePath = exports.arrayCompare = exports.bufferToInt = exports.intToBuffer = exports.arrayFlatten = exports.generateProofs = exports.buildLayers = exports.generateTransactionChunks = exports.generateTree = exports.computeRootHash = exports.generateLeaves = exports.chunkData = exports.MIN_CHUNK_SIZE = exports.MAX_CHUNK_SIZE = void 0;
      var common_1 = require_common2();
      var utils_1 = require_utils3();
      exports.MAX_CHUNK_SIZE = 256 * 1024;
      exports.MIN_CHUNK_SIZE = 32 * 1024;
      var NOTE_SIZE = 32;
      var HASH_SIZE = 32;
      async function chunkData(data) {
        let chunks = [];
        let rest = data;
        let cursor = 0;
        while (rest.byteLength >= exports.MAX_CHUNK_SIZE) {
          let chunkSize = exports.MAX_CHUNK_SIZE;
          let nextChunkSize = rest.byteLength - exports.MAX_CHUNK_SIZE;
          if (nextChunkSize > 0 && nextChunkSize < exports.MIN_CHUNK_SIZE) {
            chunkSize = Math.ceil(rest.byteLength / 2);
          }
          const chunk = rest.slice(0, chunkSize);
          const dataHash = await common_1.default.crypto.hash(chunk);
          cursor += chunk.byteLength;
          chunks.push({
            dataHash,
            minByteRange: cursor - chunk.byteLength,
            maxByteRange: cursor
          });
          rest = rest.slice(chunkSize);
        }
        chunks.push({
          dataHash: await common_1.default.crypto.hash(rest),
          minByteRange: cursor,
          maxByteRange: cursor + rest.byteLength
        });
        return chunks;
      }
      exports.chunkData = chunkData;
      async function generateLeaves(chunks) {
        return Promise.all(chunks.map(async ({ dataHash, minByteRange, maxByteRange }) => {
          return {
            type: "leaf",
            id: await hash(await Promise.all([hash(dataHash), hash(intToBuffer(maxByteRange))])),
            dataHash,
            minByteRange,
            maxByteRange
          };
        }));
      }
      exports.generateLeaves = generateLeaves;
      async function computeRootHash(data) {
        const rootNode = await generateTree(data);
        return rootNode.id;
      }
      exports.computeRootHash = computeRootHash;
      async function generateTree(data) {
        const rootNode = await buildLayers(await generateLeaves(await chunkData(data)));
        return rootNode;
      }
      exports.generateTree = generateTree;
      async function generateTransactionChunks(data) {
        const chunks = await chunkData(data);
        const leaves = await generateLeaves(chunks);
        const root = await buildLayers(leaves);
        const proofs = await generateProofs(root);
        const lastChunk = chunks.slice(-1)[0];
        if (lastChunk.maxByteRange - lastChunk.minByteRange === 0) {
          chunks.splice(chunks.length - 1, 1);
          proofs.splice(proofs.length - 1, 1);
        }
        return {
          data_root: root.id,
          chunks,
          proofs
        };
      }
      exports.generateTransactionChunks = generateTransactionChunks;
      async function buildLayers(nodes, level = 0) {
        if (nodes.length < 2) {
          const root = nodes[0];
          return root;
        }
        const nextLayer = [];
        for (let i = 0; i < nodes.length; i += 2) {
          nextLayer.push(await hashBranch(nodes[i], nodes[i + 1]));
        }
        return buildLayers(nextLayer, level + 1);
      }
      exports.buildLayers = buildLayers;
      function generateProofs(root) {
        const proofs = resolveBranchProofs(root);
        if (!Array.isArray(proofs)) {
          return [proofs];
        }
        return arrayFlatten(proofs);
      }
      exports.generateProofs = generateProofs;
      function resolveBranchProofs(node, proof = new Uint8Array(), depth = 0) {
        if (node.type == "leaf") {
          return {
            offset: node.maxByteRange - 1,
            proof: (0, utils_1.concatBuffers)([
              proof,
              node.dataHash,
              intToBuffer(node.maxByteRange)
            ])
          };
        }
        if (node.type == "branch") {
          const partialProof = (0, utils_1.concatBuffers)([
            proof,
            node.leftChild.id,
            node.rightChild.id,
            intToBuffer(node.byteRange)
          ]);
          return [
            resolveBranchProofs(node.leftChild, partialProof, depth + 1),
            resolveBranchProofs(node.rightChild, partialProof, depth + 1)
          ];
        }
        throw new Error(`Unexpected node type`);
      }
      function arrayFlatten(input) {
        const flat = [];
        input.forEach((item) => {
          if (Array.isArray(item)) {
            flat.push(...arrayFlatten(item));
          } else {
            flat.push(item);
          }
        });
        return flat;
      }
      exports.arrayFlatten = arrayFlatten;
      async function hashBranch(left, right) {
        if (!right) {
          return left;
        }
        let branch = {
          type: "branch",
          id: await hash([
            await hash(left.id),
            await hash(right.id),
            await hash(intToBuffer(left.maxByteRange))
          ]),
          byteRange: left.maxByteRange,
          maxByteRange: right.maxByteRange,
          leftChild: left,
          rightChild: right
        };
        return branch;
      }
      async function hash(data) {
        if (Array.isArray(data)) {
          data = common_1.default.utils.concatBuffers(data);
        }
        return new Uint8Array(await common_1.default.crypto.hash(data));
      }
      function intToBuffer(note) {
        const buffer = new Uint8Array(NOTE_SIZE);
        for (var i = buffer.length - 1; i >= 0; i--) {
          var byte = note % 256;
          buffer[i] = byte;
          note = (note - byte) / 256;
        }
        return buffer;
      }
      exports.intToBuffer = intToBuffer;
      function bufferToInt(buffer) {
        let value = 0;
        for (var i = 0; i < buffer.length; i++) {
          value *= 256;
          value += buffer[i];
        }
        return value;
      }
      exports.bufferToInt = bufferToInt;
      var arrayCompare = (a, b) => a.every((value, index) => b[index] === value);
      exports.arrayCompare = arrayCompare;
      async function validatePath(id, dest, leftBound, rightBound, path2) {
        if (rightBound <= 0) {
          return false;
        }
        if (dest >= rightBound) {
          return validatePath(id, 0, rightBound - 1, rightBound, path2);
        }
        if (dest < 0) {
          return validatePath(id, 0, 0, rightBound, path2);
        }
        if (path2.length == HASH_SIZE + NOTE_SIZE) {
          const pathData = path2.slice(0, HASH_SIZE);
          const endOffsetBuffer = path2.slice(pathData.length, pathData.length + NOTE_SIZE);
          const pathDataHash = await hash([
            await hash(pathData),
            await hash(endOffsetBuffer)
          ]);
          let result = (0, exports.arrayCompare)(id, pathDataHash);
          if (result) {
            return {
              offset: rightBound - 1,
              leftBound,
              rightBound,
              chunkSize: rightBound - leftBound
            };
          }
          return false;
        }
        const left = path2.slice(0, HASH_SIZE);
        const right = path2.slice(left.length, left.length + HASH_SIZE);
        const offsetBuffer = path2.slice(left.length + right.length, left.length + right.length + NOTE_SIZE);
        const offset = bufferToInt(offsetBuffer);
        const remainder = path2.slice(left.length + right.length + offsetBuffer.length);
        const pathHash = await hash([
          await hash(left),
          await hash(right),
          await hash(offsetBuffer)
        ]);
        if ((0, exports.arrayCompare)(id, pathHash)) {
          if (dest < offset) {
            return await validatePath(left, dest, leftBound, Math.min(rightBound, offset), remainder);
          }
          return await validatePath(right, dest, Math.max(leftBound, offset), rightBound, remainder);
        }
        return false;
      }
      exports.validatePath = validatePath;
      async function debug(proof, output = "") {
        if (proof.byteLength < 1) {
          return output;
        }
        const left = proof.slice(0, HASH_SIZE);
        const right = proof.slice(left.length, left.length + HASH_SIZE);
        const offsetBuffer = proof.slice(left.length + right.length, left.length + right.length + NOTE_SIZE);
        const offset = bufferToInt(offsetBuffer);
        const remainder = proof.slice(left.length + right.length + offsetBuffer.length);
        const pathHash = await hash([
          await hash(left),
          await hash(right),
          await hash(offsetBuffer)
        ]);
        const updatedOutput = `${output}
${JSON.stringify(Buffer.from(left))},${JSON.stringify(Buffer.from(right))},${offset} => ${JSON.stringify(pathHash)}`;
        return debug(remainder, updatedOutput);
      }
      exports.debug = debug;
    }
  });

  // node_modules/arweave/web/lib/transaction.js
  var require_transaction2 = __commonJS({
    "node_modules/arweave/web/lib/transaction.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Tag = void 0;
      var ArweaveUtils = require_utils3();
      var deepHash_1 = require_deepHash2();
      var merkle_1 = require_merkle2();
      var BaseObject = class {
        get(field, options) {
          if (!Object.getOwnPropertyNames(this).includes(field)) {
            throw new Error(`Field "${field}" is not a property of the Arweave Transaction class.`);
          }
          if (this[field] instanceof Uint8Array) {
            if (options && options.decode && options.string) {
              return ArweaveUtils.bufferToString(this[field]);
            }
            if (options && options.decode && !options.string) {
              return this[field];
            }
            return ArweaveUtils.bufferTob64Url(this[field]);
          }
          if (options && options.decode == true) {
            if (options && options.string) {
              return ArweaveUtils.b64UrlToString(this[field]);
            }
            return ArweaveUtils.b64UrlToBuffer(this[field]);
          }
          return this[field];
        }
      };
      var Tag = class extends BaseObject {
        constructor(name, value, decode = false) {
          super();
          this.name = name;
          this.value = value;
        }
      };
      exports.Tag = Tag;
      var Transaction4 = class extends BaseObject {
        constructor(attributes = {}) {
          super();
          this.format = 2;
          this.id = "";
          this.last_tx = "";
          this.owner = "";
          this.tags = [];
          this.target = "";
          this.quantity = "0";
          this.data_size = "0";
          this.data = new Uint8Array();
          this.data_root = "";
          this.reward = "0";
          this.signature = "";
          Object.assign(this, attributes);
          if (typeof this.data === "string") {
            this.data = ArweaveUtils.b64UrlToBuffer(this.data);
          }
          if (attributes.tags) {
            this.tags = attributes.tags.map((tag) => {
              return new Tag(tag.name, tag.value);
            });
          }
        }
        addTag(name, value) {
          this.tags.push(new Tag(ArweaveUtils.stringToB64Url(name), ArweaveUtils.stringToB64Url(value)));
        }
        toJSON() {
          return {
            format: this.format,
            id: this.id,
            last_tx: this.last_tx,
            owner: this.owner,
            tags: this.tags,
            target: this.target,
            quantity: this.quantity,
            data: ArweaveUtils.bufferTob64Url(this.data),
            data_size: this.data_size,
            data_root: this.data_root,
            data_tree: this.data_tree,
            reward: this.reward,
            signature: this.signature
          };
        }
        setOwner(owner) {
          this.owner = owner;
        }
        setSignature({ id, owner, reward, tags, signature }) {
          this.id = id;
          this.owner = owner;
          if (reward)
            this.reward = reward;
          if (tags)
            this.tags = tags;
          this.signature = signature;
        }
        async prepareChunks(data) {
          if (!this.chunks && data.byteLength > 0) {
            this.chunks = await (0, merkle_1.generateTransactionChunks)(data);
            this.data_root = ArweaveUtils.bufferTob64Url(this.chunks.data_root);
          }
          if (!this.chunks && data.byteLength === 0) {
            this.chunks = {
              chunks: [],
              data_root: new Uint8Array(),
              proofs: []
            };
            this.data_root = "";
          }
        }
        getChunk(idx, data) {
          if (!this.chunks) {
            throw new Error(`Chunks have not been prepared`);
          }
          const proof = this.chunks.proofs[idx];
          const chunk = this.chunks.chunks[idx];
          return {
            data_root: this.data_root,
            data_size: this.data_size,
            data_path: ArweaveUtils.bufferTob64Url(proof.proof),
            offset: proof.offset.toString(),
            chunk: ArweaveUtils.bufferTob64Url(data.slice(chunk.minByteRange, chunk.maxByteRange))
          };
        }
        async getSignatureData() {
          switch (this.format) {
            case 1:
              let tags = this.tags.reduce((accumulator, tag) => {
                return ArweaveUtils.concatBuffers([
                  accumulator,
                  tag.get("name", { decode: true, string: false }),
                  tag.get("value", { decode: true, string: false })
                ]);
              }, new Uint8Array());
              return ArweaveUtils.concatBuffers([
                this.get("owner", { decode: true, string: false }),
                this.get("target", { decode: true, string: false }),
                this.get("data", { decode: true, string: false }),
                ArweaveUtils.stringToBuffer(this.quantity),
                ArweaveUtils.stringToBuffer(this.reward),
                this.get("last_tx", { decode: true, string: false }),
                tags
              ]);
            case 2:
              if (!this.data_root) {
                await this.prepareChunks(this.data);
              }
              const tagList = this.tags.map((tag) => [
                tag.get("name", { decode: true, string: false }),
                tag.get("value", { decode: true, string: false })
              ]);
              return await (0, deepHash_1.default)([
                ArweaveUtils.stringToBuffer(this.format.toString()),
                this.get("owner", { decode: true, string: false }),
                this.get("target", { decode: true, string: false }),
                ArweaveUtils.stringToBuffer(this.quantity),
                ArweaveUtils.stringToBuffer(this.reward),
                this.get("last_tx", { decode: true, string: false }),
                tagList,
                ArweaveUtils.stringToBuffer(this.data_size),
                this.get("data_root", { decode: true, string: false })
              ]);
            default:
              throw new Error(`Unexpected transaction format: ${this.format}`);
          }
        }
      };
      exports.default = Transaction4;
    }
  });

  // node_modules/arweave/web/lib/transaction-uploader.js
  var require_transaction_uploader2 = __commonJS({
    "node_modules/arweave/web/lib/transaction-uploader.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.TransactionUploader = void 0;
      var transaction_1 = require_transaction2();
      var ArweaveUtils = require_utils3();
      var error_1 = require_error2();
      var merkle_1 = require_merkle2();
      var MAX_CHUNKS_IN_BODY = 1;
      var FATAL_CHUNK_UPLOAD_ERRORS = [
        "invalid_json",
        "chunk_too_big",
        "data_path_too_big",
        "offset_too_big",
        "data_size_too_big",
        "chunk_proof_ratio_not_attractive",
        "invalid_proof"
      ];
      var ERROR_DELAY = 1e3 * 40;
      var TransactionUploader = class {
        constructor(api, transaction) {
          this.api = api;
          this.chunkIndex = 0;
          this.txPosted = false;
          this.lastRequestTimeEnd = 0;
          this.totalErrors = 0;
          this.lastResponseStatus = 0;
          this.lastResponseError = "";
          if (!transaction.id) {
            throw new Error(`Transaction is not signed`);
          }
          if (!transaction.chunks) {
            throw new Error(`Transaction chunks not prepared`);
          }
          this.data = transaction.data;
          this.transaction = new transaction_1.default(Object.assign({}, transaction, { data: new Uint8Array(0) }));
        }
        get isComplete() {
          return this.txPosted && this.chunkIndex === this.transaction.chunks.chunks.length;
        }
        get totalChunks() {
          return this.transaction.chunks.chunks.length;
        }
        get uploadedChunks() {
          return this.chunkIndex;
        }
        get pctComplete() {
          return Math.trunc(this.uploadedChunks / this.totalChunks * 100);
        }
        async uploadChunk(chunkIndex_) {
          if (this.isComplete) {
            throw new Error(`Upload is already complete`);
          }
          if (this.lastResponseError !== "") {
            this.totalErrors++;
          } else {
            this.totalErrors = 0;
          }
          if (this.totalErrors === 100) {
            throw new Error(`Unable to complete upload: ${this.lastResponseStatus}: ${this.lastResponseError}`);
          }
          let delay = this.lastResponseError === "" ? 0 : Math.max(this.lastRequestTimeEnd + ERROR_DELAY - Date.now(), ERROR_DELAY);
          if (delay > 0) {
            delay = delay - delay * Math.random() * 0.3;
            await new Promise((res) => setTimeout(res, delay));
          }
          this.lastResponseError = "";
          if (!this.txPosted) {
            await this.postTransaction();
            return;
          }
          if (chunkIndex_) {
            this.chunkIndex = chunkIndex_;
          }
          const chunk = this.transaction.getChunk(chunkIndex_ || this.chunkIndex, this.data);
          const chunkOk = await (0, merkle_1.validatePath)(this.transaction.chunks.data_root, parseInt(chunk.offset), 0, parseInt(chunk.data_size), ArweaveUtils.b64UrlToBuffer(chunk.data_path));
          if (!chunkOk) {
            throw new Error(`Unable to validate chunk ${this.chunkIndex}`);
          }
          const resp = await this.api.post(`chunk`, this.transaction.getChunk(this.chunkIndex, this.data)).catch((e) => {
            console.error(e.message);
            return { status: -1, data: { error: e.message } };
          });
          this.lastRequestTimeEnd = Date.now();
          this.lastResponseStatus = resp.status;
          if (this.lastResponseStatus == 200) {
            this.chunkIndex++;
          } else {
            this.lastResponseError = (0, error_1.getError)(resp);
            if (FATAL_CHUNK_UPLOAD_ERRORS.includes(this.lastResponseError)) {
              throw new Error(`Fatal error uploading chunk ${this.chunkIndex}: ${this.lastResponseError}`);
            }
          }
        }
        static async fromSerialized(api, serialized, data) {
          if (!serialized || typeof serialized.chunkIndex !== "number" || typeof serialized.transaction !== "object") {
            throw new Error(`Serialized object does not match expected format.`);
          }
          var transaction = new transaction_1.default(serialized.transaction);
          if (!transaction.chunks) {
            await transaction.prepareChunks(data);
          }
          const upload = new TransactionUploader(api, transaction);
          upload.chunkIndex = serialized.chunkIndex;
          upload.lastRequestTimeEnd = serialized.lastRequestTimeEnd;
          upload.lastResponseError = serialized.lastResponseError;
          upload.lastResponseStatus = serialized.lastResponseStatus;
          upload.txPosted = serialized.txPosted;
          upload.data = data;
          if (upload.transaction.data_root !== serialized.transaction.data_root) {
            throw new Error(`Data mismatch: Uploader doesn't match provided data.`);
          }
          return upload;
        }
        static async fromTransactionId(api, id) {
          const resp = await api.get(`tx/${id}`);
          if (resp.status !== 200) {
            throw new Error(`Tx ${id} not found: ${resp.status}`);
          }
          const transaction = resp.data;
          transaction.data = new Uint8Array(0);
          const serialized = {
            txPosted: true,
            chunkIndex: 0,
            lastResponseError: "",
            lastRequestTimeEnd: 0,
            lastResponseStatus: 0,
            transaction
          };
          return serialized;
        }
        toJSON() {
          return {
            chunkIndex: this.chunkIndex,
            transaction: this.transaction,
            lastRequestTimeEnd: this.lastRequestTimeEnd,
            lastResponseStatus: this.lastResponseStatus,
            lastResponseError: this.lastResponseError,
            txPosted: this.txPosted
          };
        }
        async postTransaction() {
          const uploadInBody = this.totalChunks <= MAX_CHUNKS_IN_BODY;
          if (uploadInBody) {
            this.transaction.data = this.data;
            const resp2 = await this.api.post(`tx`, this.transaction).catch((e) => {
              console.error(e);
              return { status: -1, data: { error: e.message } };
            });
            this.lastRequestTimeEnd = Date.now();
            this.lastResponseStatus = resp2.status;
            this.transaction.data = new Uint8Array(0);
            if (resp2.status >= 200 && resp2.status < 300) {
              this.txPosted = true;
              this.chunkIndex = MAX_CHUNKS_IN_BODY;
              return;
            }
            this.lastResponseError = (0, error_1.getError)(resp2);
            throw new Error(`Unable to upload transaction: ${resp2.status}, ${this.lastResponseError}`);
          }
          const resp = await this.api.post(`tx`, this.transaction);
          this.lastRequestTimeEnd = Date.now();
          this.lastResponseStatus = resp.status;
          if (!(resp.status >= 200 && resp.status < 300)) {
            this.lastResponseError = (0, error_1.getError)(resp);
            throw new Error(`Unable to upload transaction: ${resp.status}, ${this.lastResponseError}`);
          }
          this.txPosted = true;
        }
      };
      exports.TransactionUploader = TransactionUploader;
    }
  });

  // node_modules/arweave/web/transactions.js
  var require_transactions2 = __commonJS({
    "node_modules/arweave/web/transactions.js"(exports) {
      "use strict";
      var __await = exports && exports.__await || function(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
      };
      var __asyncGenerator = exports && exports.__asyncGenerator || function(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
          return this;
        }, i;
        function verb(n) {
          if (g[n])
            i[n] = function(v) {
              return new Promise(function(a, b) {
                q.push([n, v, a, b]) > 1 || resume(n, v);
              });
            };
        }
        function resume(n, v) {
          try {
            step(g[n](v));
          } catch (e) {
            settle(q[0][3], e);
          }
        }
        function step(r) {
          r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
        }
        function fulfill(value) {
          resume("next", value);
        }
        function reject(value) {
          resume("throw", value);
        }
        function settle(f, v) {
          if (f(v), q.shift(), q.length)
            resume(q[0][0], q[0][1]);
        }
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      var error_1 = require_error2();
      var transaction_1 = require_transaction2();
      var ArweaveUtils = require_utils3();
      var transaction_uploader_1 = require_transaction_uploader2();
      require_arconnect();
      var Transactions = class {
        constructor(api, crypto3, chunks) {
          this.api = api;
          this.crypto = crypto3;
          this.chunks = chunks;
        }
        getTransactionAnchor() {
          return this.api.get(`tx_anchor`, { transformResponse: [] }).then((response) => {
            return response.data;
          });
        }
        getPrice(byteSize, targetAddress) {
          let endpoint = targetAddress ? `price/${byteSize}/${targetAddress}` : `price/${byteSize}`;
          return this.api.get(endpoint, {
            transformResponse: [
              function(data) {
                return data;
              }
            ]
          }).then((response) => {
            return response.data;
          });
        }
        async get(id) {
          const response = await this.api.get(`tx/${id}`);
          if (response.status == 200) {
            const data_size = parseInt(response.data.data_size);
            if (response.data.format >= 2 && data_size > 0 && data_size <= 1024 * 1024 * 12) {
              const data = await this.getData(id);
              return new transaction_1.default(Object.assign(Object.assign({}, response.data), { data }));
            }
            return new transaction_1.default(Object.assign(Object.assign({}, response.data), { format: response.data.format || 1 }));
          }
          if (response.status == 404) {
            throw new error_1.default("TX_NOT_FOUND");
          }
          if (response.status == 410) {
            throw new error_1.default("TX_FAILED");
          }
          throw new error_1.default("TX_INVALID");
        }
        fromRaw(attributes) {
          return new transaction_1.default(attributes);
        }
        async search(tagName, tagValue) {
          return this.api.post(`arql`, {
            op: "equals",
            expr1: tagName,
            expr2: tagValue
          }).then((response) => {
            if (!response.data) {
              return [];
            }
            return response.data;
          });
        }
        getStatus(id) {
          return this.api.get(`tx/${id}/status`).then((response) => {
            if (response.status == 200) {
              return {
                status: 200,
                confirmed: response.data
              };
            }
            return {
              status: response.status,
              confirmed: null
            };
          });
        }
        async getData(id, options) {
          const data = await this.chunks.downloadChunkedData(id);
          if (options && options.decode && !options.string) {
            return data;
          }
          if (options && options.decode && options.string) {
            return ArweaveUtils.bufferToString(data);
          }
          return ArweaveUtils.bufferTob64Url(data);
        }
        async sign(transaction, jwk, options) {
          if (!jwk && (typeof window === "undefined" || !window.arweaveWallet)) {
            throw new Error(`A new Arweave transaction must provide the jwk parameter.`);
          } else if (!jwk || jwk === "use_wallet") {
            try {
              const existingPermissions = await window.arweaveWallet.getPermissions();
              if (!existingPermissions.includes("SIGN_TRANSACTION"))
                await window.arweaveWallet.connect(["SIGN_TRANSACTION"]);
            } catch (_a) {
            }
            const signedTransaction = await window.arweaveWallet.sign(transaction, options);
            transaction.setSignature({
              id: signedTransaction.id,
              owner: signedTransaction.owner,
              reward: signedTransaction.reward,
              tags: signedTransaction.tags,
              signature: signedTransaction.signature
            });
          } else {
            transaction.setOwner(jwk.n);
            let dataToSign = await transaction.getSignatureData();
            let rawSignature = await this.crypto.sign(jwk, dataToSign, options);
            let id = await this.crypto.hash(rawSignature);
            transaction.setSignature({
              id: ArweaveUtils.bufferTob64Url(id),
              owner: jwk.n,
              signature: ArweaveUtils.bufferTob64Url(rawSignature)
            });
          }
        }
        async verify(transaction) {
          const signaturePayload = await transaction.getSignatureData();
          const rawSignature = transaction.get("signature", {
            decode: true,
            string: false
          });
          const expectedId = ArweaveUtils.bufferTob64Url(await this.crypto.hash(rawSignature));
          if (transaction.id !== expectedId) {
            throw new Error(`Invalid transaction signature or ID! The transaction ID doesn't match the expected SHA-256 hash of the signature.`);
          }
          return this.crypto.verify(transaction.owner, signaturePayload, rawSignature);
        }
        async post(transaction) {
          if (typeof transaction === "string") {
            transaction = new transaction_1.default(JSON.parse(transaction));
          } else if (typeof transaction.readInt32BE === "function") {
            transaction = new transaction_1.default(JSON.parse(transaction.toString()));
          } else if (typeof transaction === "object" && !(transaction instanceof transaction_1.default)) {
            transaction = new transaction_1.default(transaction);
          }
          if (!(transaction instanceof transaction_1.default)) {
            throw new Error(`Must be Transaction object`);
          }
          if (!transaction.chunks) {
            await transaction.prepareChunks(transaction.data);
          }
          const uploader = await this.getUploader(transaction, transaction.data);
          try {
            while (!uploader.isComplete) {
              await uploader.uploadChunk();
            }
          } catch (e) {
            if (uploader.lastResponseStatus > 0) {
              return {
                status: uploader.lastResponseStatus,
                statusText: uploader.lastResponseError,
                data: {
                  error: uploader.lastResponseError
                }
              };
            }
            throw e;
          }
          return {
            status: 200,
            statusText: "OK",
            data: {}
          };
        }
        async getUploader(upload, data) {
          let uploader;
          if (data instanceof ArrayBuffer) {
            data = new Uint8Array(data);
          }
          if (upload instanceof transaction_1.default) {
            if (!data) {
              data = upload.data;
            }
            if (!(data instanceof Uint8Array)) {
              throw new Error("Data format is invalid");
            }
            if (!upload.chunks) {
              await upload.prepareChunks(data);
            }
            uploader = new transaction_uploader_1.TransactionUploader(this.api, upload);
            if (!uploader.data || uploader.data.length === 0) {
              uploader.data = data;
            }
          } else {
            if (typeof upload === "string") {
              upload = await transaction_uploader_1.TransactionUploader.fromTransactionId(this.api, upload);
            }
            if (!data || !(data instanceof Uint8Array)) {
              throw new Error(`Must provide data when resuming upload`);
            }
            uploader = await transaction_uploader_1.TransactionUploader.fromSerialized(this.api, upload, data);
          }
          return uploader;
        }
        upload(upload, data) {
          return __asyncGenerator(this, arguments, function* upload_1() {
            const uploader = yield __await(this.getUploader(upload, data));
            while (!uploader.isComplete) {
              yield __await(uploader.uploadChunk());
              yield yield __await(uploader);
            }
            return yield __await(uploader);
          });
        }
      };
      exports.default = Transactions;
    }
  });

  // node_modules/arweave/web/wallets.js
  var require_wallets2 = __commonJS({
    "node_modules/arweave/web/wallets.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var ArweaveUtils = require_utils3();
      require_arconnect();
      var Wallets = class {
        constructor(api, crypto3) {
          this.api = api;
          this.crypto = crypto3;
        }
        getBalance(address) {
          return this.api.get(`wallet/${address}/balance`, {
            transformResponse: [
              function(data) {
                return data;
              }
            ]
          }).then((response) => {
            return response.data;
          });
        }
        getLastTransactionID(address) {
          return this.api.get(`wallet/${address}/last_tx`).then((response) => {
            return response.data;
          });
        }
        generate() {
          return this.crypto.generateJWK();
        }
        async jwkToAddress(jwk) {
          if (!jwk || jwk === "use_wallet") {
            return this.getAddress();
          } else {
            return this.getAddress(jwk);
          }
        }
        async getAddress(jwk) {
          if (!jwk || jwk === "use_wallet") {
            try {
              await window.arweaveWallet.connect(["ACCESS_ADDRESS"]);
            } catch (_a) {
            }
            return window.arweaveWallet.getActiveAddress();
          } else {
            return this.ownerToAddress(jwk.n);
          }
        }
        async ownerToAddress(owner) {
          return ArweaveUtils.bufferTob64Url(await this.crypto.hash(ArweaveUtils.b64UrlToBuffer(owner)));
        }
      };
      exports.default = Wallets;
    }
  });

  // node_modules/arweave/web/silo.js
  var require_silo2 = __commonJS({
    "node_modules/arweave/web/silo.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SiloResource = void 0;
      var ArweaveUtils = require_utils3();
      var Silo = class {
        constructor(api, crypto3, transactions) {
          this.api = api;
          this.crypto = crypto3;
          this.transactions = transactions;
        }
        async get(siloURI) {
          if (!siloURI) {
            throw new Error(`No Silo URI specified`);
          }
          const resource = await this.parseUri(siloURI);
          const ids = await this.transactions.search("Silo-Name", resource.getAccessKey());
          if (ids.length == 0) {
            throw new Error(`No data could be found for the Silo URI: ${siloURI}`);
          }
          const transaction = await this.transactions.get(ids[0]);
          if (!transaction) {
            throw new Error(`No data could be found for the Silo URI: ${siloURI}`);
          }
          const encrypted = transaction.get("data", { decode: true, string: false });
          return this.crypto.decrypt(encrypted, resource.getEncryptionKey());
        }
        async readTransactionData(transaction, siloURI) {
          if (!siloURI) {
            throw new Error(`No Silo URI specified`);
          }
          const resource = await this.parseUri(siloURI);
          const encrypted = transaction.get("data", { decode: true, string: false });
          return this.crypto.decrypt(encrypted, resource.getEncryptionKey());
        }
        async parseUri(siloURI) {
          const parsed = siloURI.match(/^([a-z0-9-_]+)\.([0-9]+)/i);
          if (!parsed) {
            throw new Error(`Invalid Silo name, must be a name in the format of [a-z0-9]+.[0-9]+, e.g. 'bubble.7'`);
          }
          const siloName = parsed[1];
          const hashIterations = Math.pow(2, parseInt(parsed[2]));
          const digest = await this.hash(ArweaveUtils.stringToBuffer(siloName), hashIterations);
          const accessKey = ArweaveUtils.bufferTob64(digest.slice(0, 15));
          const encryptionkey = await this.hash(digest.slice(16, 31), 1);
          return new SiloResource(siloURI, accessKey, encryptionkey);
        }
        async hash(input, iterations) {
          let digest = await this.crypto.hash(input);
          for (let count = 0; count < iterations - 1; count++) {
            digest = await this.crypto.hash(digest);
          }
          return digest;
        }
      };
      exports.default = Silo;
      var SiloResource = class {
        constructor(uri, accessKey, encryptionKey) {
          this.uri = uri;
          this.accessKey = accessKey;
          this.encryptionKey = encryptionKey;
        }
        getUri() {
          return this.uri;
        }
        getAccessKey() {
          return this.accessKey;
        }
        getEncryptionKey() {
          return this.encryptionKey;
        }
      };
      exports.SiloResource = SiloResource;
    }
  });

  // node_modules/arweave/web/chunks.js
  var require_chunks2 = __commonJS({
    "node_modules/arweave/web/chunks.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var error_1 = require_error2();
      var ArweaveUtils = require_utils3();
      var Chunks = class {
        constructor(api) {
          this.api = api;
        }
        async getTransactionOffset(id) {
          const resp = await this.api.get(`tx/${id}/offset`);
          if (resp.status === 200) {
            return resp.data;
          }
          throw new Error(`Unable to get transaction offset: ${(0, error_1.getError)(resp)}`);
        }
        async getChunk(offset) {
          const resp = await this.api.get(`chunk/${offset}`);
          if (resp.status === 200) {
            return resp.data;
          }
          throw new Error(`Unable to get chunk: ${(0, error_1.getError)(resp)}`);
        }
        async getChunkData(offset) {
          const chunk = await this.getChunk(offset);
          const buf = ArweaveUtils.b64UrlToBuffer(chunk.chunk);
          return buf;
        }
        firstChunkOffset(offsetResponse) {
          return parseInt(offsetResponse.offset) - parseInt(offsetResponse.size) + 1;
        }
        async downloadChunkedData(id) {
          const offsetResponse = await this.getTransactionOffset(id);
          const size = parseInt(offsetResponse.size);
          const endOffset = parseInt(offsetResponse.offset);
          const startOffset = endOffset - size + 1;
          const data = new Uint8Array(size);
          let byte = 0;
          while (byte < size) {
            if (this.api.config.logging) {
              console.log(`[chunk] ${byte}/${size}`);
            }
            let chunkData;
            try {
              chunkData = await this.getChunkData(startOffset + byte);
            } catch (error) {
              console.error(`[chunk] Failed to fetch chunk at offset ${startOffset + byte}`);
              console.error(`[chunk] This could indicate that the chunk wasn't uploaded or hasn't yet seeded properly to a particular gatway/node`);
            }
            if (chunkData) {
              data.set(chunkData, byte);
              byte += chunkData.length;
            } else {
              throw new Error(`Coudn't complete data download at ${byte}/${size}`);
            }
          }
          return data;
        }
      };
      exports.default = Chunks;
    }
  });

  // node_modules/arweave/web/blocks.js
  var require_blocks2 = __commonJS({
    "node_modules/arweave/web/blocks.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var error_1 = require_error2();
      require_arconnect();
      var Blocks = class {
        constructor(api, network) {
          this.api = api;
          this.network = network;
        }
        async get(indepHash) {
          const response = await this.api.get(`${Blocks.ENDPOINT}${indepHash}`);
          if (response.status === 200) {
            return response.data;
          } else {
            if (response.status === 404) {
              throw new error_1.default("BLOCK_NOT_FOUND");
            } else {
              throw new Error(`Error while loading block data: ${response}`);
            }
          }
        }
        async getCurrent() {
          const { current } = await this.network.getInfo();
          return await this.get(current);
        }
      };
      exports.default = Blocks;
      Blocks.ENDPOINT = "block/hash/";
    }
  });

  // node_modules/arweave/web/common.js
  var require_common2 = __commonJS({
    "node_modules/arweave/web/common.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var ar_1 = require_ar2();
      var api_1 = require_api2();
      var network_1 = require_network2();
      var transactions_1 = require_transactions2();
      var wallets_1 = require_wallets2();
      var transaction_1 = require_transaction2();
      var ArweaveUtils = require_utils3();
      var silo_1 = require_silo2();
      var chunks_1 = require_chunks2();
      var blocks_1 = require_blocks2();
      var Arweave2 = class {
        constructor(apiConfig) {
          this.api = new api_1.default(apiConfig);
          this.wallets = new wallets_1.default(this.api, Arweave2.crypto);
          this.chunks = new chunks_1.default(this.api);
          this.transactions = new transactions_1.default(this.api, Arweave2.crypto, this.chunks);
          this.silo = new silo_1.default(this.api, this.crypto, this.transactions);
          this.network = new network_1.default(this.api);
          this.blocks = new blocks_1.default(this.api, this.network);
          this.ar = new ar_1.default();
        }
        get crypto() {
          return Arweave2.crypto;
        }
        get utils() {
          return Arweave2.utils;
        }
        getConfig() {
          return {
            api: this.api.getConfig(),
            crypto: null
          };
        }
        async createTransaction(attributes, jwk) {
          const transaction = {};
          Object.assign(transaction, attributes);
          if (!attributes.data && !(attributes.target && attributes.quantity)) {
            throw new Error(`A new Arweave transaction must have a 'data' value, or 'target' and 'quantity' values.`);
          }
          if (attributes.owner == void 0) {
            if (jwk && jwk !== "use_wallet") {
              transaction.owner = jwk.n;
            }
          }
          if (attributes.last_tx == void 0) {
            transaction.last_tx = await this.transactions.getTransactionAnchor();
          }
          if (typeof attributes.data === "string") {
            attributes.data = ArweaveUtils.stringToBuffer(attributes.data);
          }
          if (attributes.data instanceof ArrayBuffer) {
            attributes.data = new Uint8Array(attributes.data);
          }
          if (attributes.data && !(attributes.data instanceof Uint8Array)) {
            throw new Error("Expected data to be a string, Uint8Array or ArrayBuffer");
          }
          if (attributes.reward == void 0) {
            const length = attributes.data ? attributes.data.byteLength : 0;
            transaction.reward = await this.transactions.getPrice(length, transaction.target);
          }
          transaction.data_root = "";
          transaction.data_size = attributes.data ? attributes.data.byteLength.toString() : "0";
          transaction.data = attributes.data || new Uint8Array(0);
          const createdTransaction = new transaction_1.default(transaction);
          await createdTransaction.getSignatureData();
          return createdTransaction;
        }
        async createSiloTransaction(attributes, jwk, siloUri) {
          const transaction = {};
          Object.assign(transaction, attributes);
          if (!attributes.data) {
            throw new Error(`Silo transactions must have a 'data' value`);
          }
          if (!siloUri) {
            throw new Error(`No Silo URI specified.`);
          }
          if (attributes.target || attributes.quantity) {
            throw new Error(`Silo transactions can only be used for storing data, sending AR to other wallets isn't supported.`);
          }
          if (attributes.owner == void 0) {
            if (!jwk || !jwk.n) {
              throw new Error(`A new Arweave transaction must either have an 'owner' attribute, or you must provide the jwk parameter.`);
            }
            transaction.owner = jwk.n;
          }
          if (attributes.last_tx == void 0) {
            transaction.last_tx = await this.transactions.getTransactionAnchor();
          }
          const siloResource = await this.silo.parseUri(siloUri);
          if (typeof attributes.data == "string") {
            const encrypted = await this.crypto.encrypt(ArweaveUtils.stringToBuffer(attributes.data), siloResource.getEncryptionKey());
            transaction.reward = await this.transactions.getPrice(encrypted.byteLength);
            transaction.data = ArweaveUtils.bufferTob64Url(encrypted);
          }
          if (attributes.data instanceof Uint8Array) {
            const encrypted = await this.crypto.encrypt(attributes.data, siloResource.getEncryptionKey());
            transaction.reward = await this.transactions.getPrice(encrypted.byteLength);
            transaction.data = ArweaveUtils.bufferTob64Url(encrypted);
          }
          const siloTransaction = new transaction_1.default(transaction);
          siloTransaction.addTag("Silo-Name", siloResource.getAccessKey());
          siloTransaction.addTag("Silo-Version", `0.1.0`);
          return siloTransaction;
        }
        arql(query) {
          return this.api.post("/arql", query).then((response) => response.data || []);
        }
      };
      exports.default = Arweave2;
      Arweave2.utils = ArweaveUtils;
    }
  });

  // node_modules/arweave/web/lib/crypto/webcrypto-driver.js
  var require_webcrypto_driver = __commonJS({
    "node_modules/arweave/web/lib/crypto/webcrypto-driver.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var ArweaveUtils = require_utils3();
      var WebCryptoDriver = class {
        constructor() {
          this.keyLength = 4096;
          this.publicExponent = 65537;
          this.hashAlgorithm = "sha256";
          if (!this.detectWebCrypto()) {
            throw new Error("SubtleCrypto not available!");
          }
          this.driver = crypto.subtle;
        }
        async generateJWK() {
          let cryptoKey = await this.driver.generateKey({
            name: "RSA-PSS",
            modulusLength: 4096,
            publicExponent: new Uint8Array([1, 0, 1]),
            hash: {
              name: "SHA-256"
            }
          }, true, ["sign"]);
          let jwk = await this.driver.exportKey("jwk", cryptoKey.privateKey);
          return {
            kty: jwk.kty,
            e: jwk.e,
            n: jwk.n,
            d: jwk.d,
            p: jwk.p,
            q: jwk.q,
            dp: jwk.dp,
            dq: jwk.dq,
            qi: jwk.qi
          };
        }
        async sign(jwk, data, { saltLength } = {}) {
          let signature = await this.driver.sign({
            name: "RSA-PSS",
            saltLength: 32
          }, await this.jwkToCryptoKey(jwk), data);
          return new Uint8Array(signature);
        }
        async hash(data, algorithm = "SHA-256") {
          let digest = await this.driver.digest(algorithm, data);
          return new Uint8Array(digest);
        }
        async verify(publicModulus, data, signature) {
          const publicKey = {
            kty: "RSA",
            e: "AQAB",
            n: publicModulus
          };
          const key = await this.jwkToPublicCryptoKey(publicKey);
          const verifyWith32 = this.driver.verify({
            name: "RSA-PSS",
            saltLength: 32
          }, key, signature, data);
          const verifyWith0 = this.driver.verify({
            name: "RSA-PSS",
            saltLength: 0
          }, key, signature, data);
          return verifyWith32 || verifyWith0;
        }
        async jwkToCryptoKey(jwk) {
          return this.driver.importKey("jwk", jwk, {
            name: "RSA-PSS",
            hash: {
              name: "SHA-256"
            }
          }, false, ["sign"]);
        }
        async jwkToPublicCryptoKey(publicJwk) {
          return this.driver.importKey("jwk", publicJwk, {
            name: "RSA-PSS",
            hash: {
              name: "SHA-256"
            }
          }, false, ["verify"]);
        }
        detectWebCrypto() {
          if (typeof crypto === "undefined") {
            return false;
          }
          const subtle = crypto === null || crypto === void 0 ? void 0 : crypto.subtle;
          if (subtle === void 0) {
            return false;
          }
          const names = [
            "generateKey",
            "importKey",
            "exportKey",
            "digest",
            "sign"
          ];
          return names.every((name) => typeof subtle[name] === "function");
        }
        async encrypt(data, key, salt) {
          const initialKey = await this.driver.importKey("raw", typeof key == "string" ? ArweaveUtils.stringToBuffer(key) : key, {
            name: "PBKDF2",
            length: 32
          }, false, ["deriveKey"]);
          const derivedkey = await this.driver.deriveKey({
            name: "PBKDF2",
            salt: salt ? ArweaveUtils.stringToBuffer(salt) : ArweaveUtils.stringToBuffer("salt"),
            iterations: 1e5,
            hash: "SHA-256"
          }, initialKey, {
            name: "AES-CBC",
            length: 256
          }, false, ["encrypt", "decrypt"]);
          const iv = new Uint8Array(16);
          crypto.getRandomValues(iv);
          const encryptedData = await this.driver.encrypt({
            name: "AES-CBC",
            iv
          }, derivedkey, data);
          return ArweaveUtils.concatBuffers([iv, encryptedData]);
        }
        async decrypt(encrypted, key, salt) {
          const initialKey = await this.driver.importKey("raw", typeof key == "string" ? ArweaveUtils.stringToBuffer(key) : key, {
            name: "PBKDF2",
            length: 32
          }, false, ["deriveKey"]);
          const derivedkey = await this.driver.deriveKey({
            name: "PBKDF2",
            salt: salt ? ArweaveUtils.stringToBuffer(salt) : ArweaveUtils.stringToBuffer("salt"),
            iterations: 1e5,
            hash: "SHA-256"
          }, initialKey, {
            name: "AES-CBC",
            length: 256
          }, false, ["encrypt", "decrypt"]);
          const iv = encrypted.slice(0, 16);
          const data = await this.driver.decrypt({
            name: "AES-CBC",
            iv
          }, derivedkey, encrypted.slice(16));
          return ArweaveUtils.concatBuffers([data]);
        }
      };
      exports.default = WebCryptoDriver;
    }
  });

  // node_modules/arweave/web/index.js
  var require_web = __commonJS({
    "node_modules/arweave/web/index.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() {
          return m[k];
        } });
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __exportStar = exports && exports.__exportStar || function(m, exports2) {
        for (var p in m)
          if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
            __createBinding(exports2, m, p);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      var common_1 = require_common2();
      var webcrypto_driver_1 = require_webcrypto_driver();
      common_1.default.crypto = new webcrypto_driver_1.default();
      common_1.default.init = function(apiConfig = {}) {
        function getDefaultConfig() {
          const defaults = {
            host: "arweave.net",
            port: 443,
            protocol: "https"
          };
          if (!window || !window.location || !window.location.protocol || !window.location.hostname) {
            return defaults;
          }
          const currentProtocol = window.location.protocol.replace(":", "");
          const currentHost = window.location.hostname;
          const currentPort = window.location.port ? parseInt(window.location.port) : currentProtocol == "https" ? 443 : 80;
          const isLocal = ["localhost", "127.0.0.1"].includes(currentHost) || currentProtocol == "file";
          if (isLocal) {
            return defaults;
          }
          return {
            host: currentHost,
            port: currentPort,
            protocol: currentProtocol
          };
        }
        const defaultConfig = getDefaultConfig();
        const protocol = apiConfig.protocol || defaultConfig.protocol;
        const host = apiConfig.host || defaultConfig.host;
        const port = apiConfig.port || defaultConfig.port;
        return new common_1.default(Object.assign(Object.assign({}, apiConfig), {
          host,
          protocol,
          port
        }));
      };
      window.Arweave = common_1.default;
      __exportStar(require_common2(), exports);
      exports.default = common_1.default;
    }
  });

  // (disabled):fs
  var require_fs = __commonJS({
    "(disabled):fs"() {
    }
  });

  // (disabled):path
  var require_path = __commonJS({
    "(disabled):path"() {
    }
  });

  // node_modules/safe-stable-stringify/index.js
  var require_safe_stable_stringify = __commonJS({
    "node_modules/safe-stable-stringify/index.js"(exports, module2) {
      "use strict";
      var stringify = configure2();
      stringify.configure = configure2;
      stringify.stringify = stringify;
      stringify.default = stringify;
      exports.stringify = stringify;
      exports.configure = configure2;
      module2.exports = stringify;
      var strEscapeSequencesRegExp = /[\u0000-\u001f\u0022\u005c\ud800-\udfff]|[\ud800-\udbff](?![\udc00-\udfff])|(?:[^\ud800-\udbff]|^)[\udc00-\udfff]/;
      var strEscapeSequencesReplacer = /[\u0000-\u001f\u0022\u005c\ud800-\udfff]|[\ud800-\udbff](?![\udc00-\udfff])|(?:[^\ud800-\udbff]|^)[\udc00-\udfff]/g;
      var meta = [
        "\\u0000",
        "\\u0001",
        "\\u0002",
        "\\u0003",
        "\\u0004",
        "\\u0005",
        "\\u0006",
        "\\u0007",
        "\\b",
        "\\t",
        "\\n",
        "\\u000b",
        "\\f",
        "\\r",
        "\\u000e",
        "\\u000f",
        "\\u0010",
        "\\u0011",
        "\\u0012",
        "\\u0013",
        "\\u0014",
        "\\u0015",
        "\\u0016",
        "\\u0017",
        "\\u0018",
        "\\u0019",
        "\\u001a",
        "\\u001b",
        "\\u001c",
        "\\u001d",
        "\\u001e",
        "\\u001f",
        "",
        "",
        '\\"',
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "\\\\"
      ];
      function escapeFn(str) {
        if (str.length === 2) {
          const charCode2 = str.charCodeAt(1);
          return `${str[0]}\\u${charCode2.toString(16)}`;
        }
        const charCode = str.charCodeAt(0);
        return meta.length > charCode ? meta[charCode] : `\\u${charCode.toString(16)}`;
      }
      function strEscape(str) {
        if (str.length < 5e3 && !strEscapeSequencesRegExp.test(str)) {
          return str;
        }
        if (str.length > 100) {
          return str.replace(strEscapeSequencesReplacer, escapeFn);
        }
        let result = "";
        let last = 0;
        for (let i = 0; i < str.length; i++) {
          const point = str.charCodeAt(i);
          if (point === 34 || point === 92 || point < 32) {
            result += `${str.slice(last, i)}${meta[point]}`;
            last = i + 1;
          } else if (point >= 55296 && point <= 57343) {
            if (point <= 56319 && i + 1 < str.length) {
              const point2 = str.charCodeAt(i + 1);
              if (point2 >= 56320 && point2 <= 57343) {
                i++;
                continue;
              }
            }
            result += `${str.slice(last, i)}${`\\u${point.toString(16)}`}`;
            last = i + 1;
          }
        }
        result += str.slice(last);
        return result;
      }
      function insertSort(array) {
        if (array.length > 200) {
          return array.sort();
        }
        for (let i = 1; i < array.length; i++) {
          const currentValue = array[i];
          let position = i;
          while (position !== 0 && array[position - 1] > currentValue) {
            array[position] = array[position - 1];
            position--;
          }
          array[position] = currentValue;
        }
        return array;
      }
      var typedArrayPrototypeGetSymbolToStringTag = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(Object.getPrototypeOf(new Uint8Array())), Symbol.toStringTag).get;
      function isTypedArrayWithEntries(value) {
        return typedArrayPrototypeGetSymbolToStringTag.call(value) !== void 0 && value.length !== 0;
      }
      function stringifyTypedArray(array, separator, maximumBreadth) {
        if (array.length < maximumBreadth) {
          maximumBreadth = array.length;
        }
        const whitespace = separator === "," ? "" : " ";
        let res = `"0":${whitespace}${array[0]}`;
        for (let i = 1; i < maximumBreadth; i++) {
          res += `${separator}"${i}":${whitespace}${array[i]}`;
        }
        return res;
      }
      function getCircularValueOption(options) {
        if (options && Object.prototype.hasOwnProperty.call(options, "circularValue")) {
          var circularValue = options.circularValue;
          if (typeof circularValue === "string") {
            return `"${circularValue}"`;
          }
          if (circularValue == null) {
            return circularValue;
          }
          if (circularValue === Error || circularValue === TypeError) {
            return {
              toString() {
                throw new TypeError("Converting circular structure to JSON");
              }
            };
          }
          throw new TypeError('The "circularValue" argument must be of type string or the value null or undefined');
        }
        return '"[Circular]"';
      }
      function getBooleanOption(options, key) {
        if (options && Object.prototype.hasOwnProperty.call(options, key)) {
          var value = options[key];
          if (typeof value !== "boolean") {
            throw new TypeError(`The "${key}" argument must be of type boolean`);
          }
        }
        return value === void 0 ? true : value;
      }
      function getPositiveIntegerOption(options, key) {
        if (options && Object.prototype.hasOwnProperty.call(options, key)) {
          var value = options[key];
          if (typeof value !== "number") {
            throw new TypeError(`The "${key}" argument must be of type number`);
          }
          if (!Number.isInteger(value)) {
            throw new TypeError(`The "${key}" argument must be an integer`);
          }
          if (value < 1) {
            throw new RangeError(`The "${key}" argument must be >= 1`);
          }
        }
        return value === void 0 ? Infinity : value;
      }
      function getItemCount(number) {
        if (number === 1) {
          return "1 item";
        }
        return `${number} items`;
      }
      function getUniqueReplacerSet(replacerArray) {
        const replacerSet = new Set();
        for (const value of replacerArray) {
          if (typeof value === "string") {
            replacerSet.add(value);
          } else if (typeof value === "number") {
            replacerSet.add(String(value));
          }
        }
        return replacerSet;
      }
      function configure2(options) {
        const circularValue = getCircularValueOption(options);
        const bigint = getBooleanOption(options, "bigint");
        const deterministic = getBooleanOption(options, "deterministic");
        const maximumDepth = getPositiveIntegerOption(options, "maximumDepth");
        const maximumBreadth = getPositiveIntegerOption(options, "maximumBreadth");
        function stringifyFnReplacer(key, parent, stack, replacer, spacer, indentation) {
          let value = parent[key];
          if (typeof value === "object" && value !== null && typeof value.toJSON === "function") {
            value = value.toJSON(key);
          }
          value = replacer.call(parent, key, value);
          switch (typeof value) {
            case "string":
              return `"${strEscape(value)}"`;
            case "object": {
              if (value === null) {
                return "null";
              }
              if (stack.indexOf(value) !== -1) {
                return circularValue;
              }
              let res = "";
              let join = ",";
              const originalIndentation = indentation;
              if (Array.isArray(value)) {
                if (value.length === 0) {
                  return "[]";
                }
                if (maximumDepth < stack.length + 1) {
                  return '"[Array]"';
                }
                stack.push(value);
                if (spacer !== "") {
                  indentation += spacer;
                  res += `
${indentation}`;
                  join = `,
${indentation}`;
                }
                const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
                let i = 0;
                for (; i < maximumValuesToStringify - 1; i++) {
                  const tmp2 = stringifyFnReplacer(i, value, stack, replacer, spacer, indentation);
                  res += tmp2 !== void 0 ? tmp2 : "null";
                  res += join;
                }
                const tmp = stringifyFnReplacer(i, value, stack, replacer, spacer, indentation);
                res += tmp !== void 0 ? tmp : "null";
                if (value.length - 1 > maximumBreadth) {
                  const removedKeys = value.length - maximumBreadth - 1;
                  res += `${join}"... ${getItemCount(removedKeys)} not stringified"`;
                }
                if (spacer !== "") {
                  res += `
${originalIndentation}`;
                }
                stack.pop();
                return `[${res}]`;
              }
              let keys = Object.keys(value);
              const keyLength = keys.length;
              if (keyLength === 0) {
                return "{}";
              }
              if (maximumDepth < stack.length + 1) {
                return '"[Object]"';
              }
              let whitespace = "";
              let separator = "";
              if (spacer !== "") {
                indentation += spacer;
                join = `,
${indentation}`;
                whitespace = " ";
              }
              let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
              if (isTypedArrayWithEntries(value)) {
                res += stringifyTypedArray(value, join, maximumBreadth);
                keys = keys.slice(value.length);
                maximumPropertiesToStringify -= value.length;
                separator = join;
              }
              if (deterministic) {
                keys = insertSort(keys);
              }
              stack.push(value);
              for (let i = 0; i < maximumPropertiesToStringify; i++) {
                const key2 = keys[i];
                const tmp = stringifyFnReplacer(key2, value, stack, replacer, spacer, indentation);
                if (tmp !== void 0) {
                  res += `${separator}"${strEscape(key2)}":${whitespace}${tmp}`;
                  separator = join;
                }
              }
              if (keyLength > maximumBreadth) {
                const removedKeys = keyLength - maximumBreadth;
                res += `${separator}"...":${whitespace}"${getItemCount(removedKeys)} not stringified"`;
                separator = join;
              }
              if (spacer !== "" && separator.length > 1) {
                res = `
${indentation}${res}
${originalIndentation}`;
              }
              stack.pop();
              return `{${res}}`;
            }
            case "number":
              return isFinite(value) ? String(value) : "null";
            case "boolean":
              return value === true ? "true" : "false";
            case "bigint":
              return bigint ? String(value) : void 0;
          }
        }
        function stringifyArrayReplacer(key, value, stack, replacer, spacer, indentation) {
          if (typeof value === "object" && value !== null && typeof value.toJSON === "function") {
            value = value.toJSON(key);
          }
          switch (typeof value) {
            case "string":
              return `"${strEscape(value)}"`;
            case "object": {
              if (value === null) {
                return "null";
              }
              if (stack.indexOf(value) !== -1) {
                return circularValue;
              }
              const originalIndentation = indentation;
              let res = "";
              let join = ",";
              if (Array.isArray(value)) {
                if (value.length === 0) {
                  return "[]";
                }
                if (maximumDepth < stack.length + 1) {
                  return '"[Array]"';
                }
                stack.push(value);
                if (spacer !== "") {
                  indentation += spacer;
                  res += `
${indentation}`;
                  join = `,
${indentation}`;
                }
                const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
                let i = 0;
                for (; i < maximumValuesToStringify - 1; i++) {
                  const tmp2 = stringifyArrayReplacer(i, value[i], stack, replacer, spacer, indentation);
                  res += tmp2 !== void 0 ? tmp2 : "null";
                  res += join;
                }
                const tmp = stringifyArrayReplacer(i, value[i], stack, replacer, spacer, indentation);
                res += tmp !== void 0 ? tmp : "null";
                if (value.length - 1 > maximumBreadth) {
                  const removedKeys = value.length - maximumBreadth - 1;
                  res += `${join}"... ${getItemCount(removedKeys)} not stringified"`;
                }
                if (spacer !== "") {
                  res += `
${originalIndentation}`;
                }
                stack.pop();
                return `[${res}]`;
              }
              if (replacer.size === 0) {
                return "{}";
              }
              stack.push(value);
              let whitespace = "";
              if (spacer !== "") {
                indentation += spacer;
                join = `,
${indentation}`;
                whitespace = " ";
              }
              let separator = "";
              for (const key2 of replacer) {
                const tmp = stringifyArrayReplacer(key2, value[key2], stack, replacer, spacer, indentation);
                if (tmp !== void 0) {
                  res += `${separator}"${strEscape(key2)}":${whitespace}${tmp}`;
                  separator = join;
                }
              }
              if (spacer !== "" && separator.length > 1) {
                res = `
${indentation}${res}
${originalIndentation}`;
              }
              stack.pop();
              return `{${res}}`;
            }
            case "number":
              return isFinite(value) ? String(value) : "null";
            case "boolean":
              return value === true ? "true" : "false";
            case "bigint":
              return bigint ? String(value) : void 0;
          }
        }
        function stringifyIndent(key, value, stack, spacer, indentation) {
          switch (typeof value) {
            case "string":
              return `"${strEscape(value)}"`;
            case "object": {
              if (value === null) {
                return "null";
              }
              if (typeof value.toJSON === "function") {
                value = value.toJSON(key);
                if (typeof value !== "object") {
                  return stringifyIndent(key, value, stack, spacer, indentation);
                }
                if (value === null) {
                  return "null";
                }
              }
              if (stack.indexOf(value) !== -1) {
                return circularValue;
              }
              const originalIndentation = indentation;
              if (Array.isArray(value)) {
                if (value.length === 0) {
                  return "[]";
                }
                if (maximumDepth < stack.length + 1) {
                  return '"[Array]"';
                }
                stack.push(value);
                indentation += spacer;
                let res2 = `
${indentation}`;
                const join2 = `,
${indentation}`;
                const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
                let i = 0;
                for (; i < maximumValuesToStringify - 1; i++) {
                  const tmp2 = stringifyIndent(i, value[i], stack, spacer, indentation);
                  res2 += tmp2 !== void 0 ? tmp2 : "null";
                  res2 += join2;
                }
                const tmp = stringifyIndent(i, value[i], stack, spacer, indentation);
                res2 += tmp !== void 0 ? tmp : "null";
                if (value.length - 1 > maximumBreadth) {
                  const removedKeys = value.length - maximumBreadth - 1;
                  res2 += `${join2}"... ${getItemCount(removedKeys)} not stringified"`;
                }
                res2 += `
${originalIndentation}`;
                stack.pop();
                return `[${res2}]`;
              }
              let keys = Object.keys(value);
              const keyLength = keys.length;
              if (keyLength === 0) {
                return "{}";
              }
              if (maximumDepth < stack.length + 1) {
                return '"[Object]"';
              }
              indentation += spacer;
              const join = `,
${indentation}`;
              let res = "";
              let separator = "";
              let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
              if (isTypedArrayWithEntries(value)) {
                res += stringifyTypedArray(value, join, maximumBreadth);
                keys = keys.slice(value.length);
                maximumPropertiesToStringify -= value.length;
                separator = join;
              }
              if (deterministic) {
                keys = insertSort(keys);
              }
              stack.push(value);
              for (let i = 0; i < maximumPropertiesToStringify; i++) {
                const key2 = keys[i];
                const tmp = stringifyIndent(key2, value[key2], stack, spacer, indentation);
                if (tmp !== void 0) {
                  res += `${separator}"${strEscape(key2)}": ${tmp}`;
                  separator = join;
                }
              }
              if (keyLength > maximumBreadth) {
                const removedKeys = keyLength - maximumBreadth;
                res += `${separator}"...": "${getItemCount(removedKeys)} not stringified"`;
                separator = join;
              }
              if (separator !== "") {
                res = `
${indentation}${res}
${originalIndentation}`;
              }
              stack.pop();
              return `{${res}}`;
            }
            case "number":
              return isFinite(value) ? String(value) : "null";
            case "boolean":
              return value === true ? "true" : "false";
            case "bigint":
              return bigint ? String(value) : void 0;
          }
        }
        function stringifySimple(key, value, stack) {
          switch (typeof value) {
            case "string":
              return `"${strEscape(value)}"`;
            case "object": {
              if (value === null) {
                return "null";
              }
              if (typeof value.toJSON === "function") {
                value = value.toJSON(key);
                if (typeof value !== "object") {
                  return stringifySimple(key, value, stack);
                }
                if (value === null) {
                  return "null";
                }
              }
              if (stack.indexOf(value) !== -1) {
                return circularValue;
              }
              let res = "";
              if (Array.isArray(value)) {
                if (value.length === 0) {
                  return "[]";
                }
                if (maximumDepth < stack.length + 1) {
                  return '"[Array]"';
                }
                stack.push(value);
                const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
                let i = 0;
                for (; i < maximumValuesToStringify - 1; i++) {
                  const tmp2 = stringifySimple(i, value[i], stack);
                  res += tmp2 !== void 0 ? tmp2 : "null";
                  res += ",";
                }
                const tmp = stringifySimple(i, value[i], stack);
                res += tmp !== void 0 ? tmp : "null";
                if (value.length - 1 > maximumBreadth) {
                  const removedKeys = value.length - maximumBreadth - 1;
                  res += `,"... ${getItemCount(removedKeys)} not stringified"`;
                }
                stack.pop();
                return `[${res}]`;
              }
              let keys = Object.keys(value);
              const keyLength = keys.length;
              if (keyLength === 0) {
                return "{}";
              }
              if (maximumDepth < stack.length + 1) {
                return '"[Object]"';
              }
              let separator = "";
              let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
              if (isTypedArrayWithEntries(value)) {
                res += stringifyTypedArray(value, ",", maximumBreadth);
                keys = keys.slice(value.length);
                maximumPropertiesToStringify -= value.length;
                separator = ",";
              }
              if (deterministic) {
                keys = insertSort(keys);
              }
              stack.push(value);
              for (let i = 0; i < maximumPropertiesToStringify; i++) {
                const key2 = keys[i];
                const tmp = stringifySimple(key2, value[key2], stack);
                if (tmp !== void 0) {
                  res += `${separator}"${strEscape(key2)}":${tmp}`;
                  separator = ",";
                }
              }
              if (keyLength > maximumBreadth) {
                const removedKeys = keyLength - maximumBreadth;
                res += `${separator}"...":"${getItemCount(removedKeys)} not stringified"`;
              }
              stack.pop();
              return `{${res}}`;
            }
            case "number":
              return isFinite(value) ? String(value) : "null";
            case "boolean":
              return value === true ? "true" : "false";
            case "bigint":
              return bigint ? String(value) : void 0;
          }
        }
        function stringify2(value, replacer, space) {
          if (arguments.length > 1) {
            let spacer = "";
            if (typeof space === "number") {
              spacer = " ".repeat(Math.min(space, 10));
            } else if (typeof space === "string") {
              spacer = space.slice(0, 10);
            }
            if (replacer != null) {
              if (typeof replacer === "function") {
                return stringifyFnReplacer("", { "": value }, [], replacer, spacer, "");
              }
              if (Array.isArray(replacer)) {
                return stringifyArrayReplacer("", value, [], getUniqueReplacerSet(replacer), spacer, "");
              }
            }
            if (spacer.length !== 0) {
              return stringifyIndent("", value, [], spacer, "");
            }
          }
          return stringifySimple("", value, []);
        }
        return stringify2;
      }
    }
  });

  // (disabled):node_modules/buffer/index.js
  var require_buffer2 = __commonJS({
    "(disabled):node_modules/buffer/index.js"() {
    }
  });

  // node_modules/bn.js/lib/bn.js
  var require_bn = __commonJS({
    "node_modules/bn.js/lib/bn.js"(exports, module2) {
      (function(module3, exports2) {
        "use strict";
        function assert(val, msg) {
          if (!val)
            throw new Error(msg || "Assertion failed");
        }
        function inherits(ctor, superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
        function BN(number, base, endian) {
          if (BN.isBN(number)) {
            return number;
          }
          this.negative = 0;
          this.words = null;
          this.length = 0;
          this.red = null;
          if (number !== null) {
            if (base === "le" || base === "be") {
              endian = base;
              base = 10;
            }
            this._init(number || 0, base || 10, endian || "be");
          }
        }
        if (typeof module3 === "object") {
          module3.exports = BN;
        } else {
          exports2.BN = BN;
        }
        BN.BN = BN;
        BN.wordSize = 26;
        var Buffer3;
        try {
          if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
            Buffer3 = window.Buffer;
          } else {
            Buffer3 = require_buffer2().Buffer;
          }
        } catch (e) {
        }
        BN.isBN = function isBN(num) {
          if (num instanceof BN) {
            return true;
          }
          return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
        };
        BN.max = function max(left, right) {
          if (left.cmp(right) > 0)
            return left;
          return right;
        };
        BN.min = function min(left, right) {
          if (left.cmp(right) < 0)
            return left;
          return right;
        };
        BN.prototype._init = function init(number, base, endian) {
          if (typeof number === "number") {
            return this._initNumber(number, base, endian);
          }
          if (typeof number === "object") {
            return this._initArray(number, base, endian);
          }
          if (base === "hex") {
            base = 16;
          }
          assert(base === (base | 0) && base >= 2 && base <= 36);
          number = number.toString().replace(/\s+/g, "");
          var start = 0;
          if (number[0] === "-") {
            start++;
            this.negative = 1;
          }
          if (start < number.length) {
            if (base === 16) {
              this._parseHex(number, start, endian);
            } else {
              this._parseBase(number, base, start);
              if (endian === "le") {
                this._initArray(this.toArray(), base, endian);
              }
            }
          }
        };
        BN.prototype._initNumber = function _initNumber(number, base, endian) {
          if (number < 0) {
            this.negative = 1;
            number = -number;
          }
          if (number < 67108864) {
            this.words = [number & 67108863];
            this.length = 1;
          } else if (number < 4503599627370496) {
            this.words = [
              number & 67108863,
              number / 67108864 & 67108863
            ];
            this.length = 2;
          } else {
            assert(number < 9007199254740992);
            this.words = [
              number & 67108863,
              number / 67108864 & 67108863,
              1
            ];
            this.length = 3;
          }
          if (endian !== "le")
            return;
          this._initArray(this.toArray(), base, endian);
        };
        BN.prototype._initArray = function _initArray(number, base, endian) {
          assert(typeof number.length === "number");
          if (number.length <= 0) {
            this.words = [0];
            this.length = 1;
            return this;
          }
          this.length = Math.ceil(number.length / 3);
          this.words = new Array(this.length);
          for (var i = 0; i < this.length; i++) {
            this.words[i] = 0;
          }
          var j, w;
          var off = 0;
          if (endian === "be") {
            for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
              w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
              this.words[j] |= w << off & 67108863;
              this.words[j + 1] = w >>> 26 - off & 67108863;
              off += 24;
              if (off >= 26) {
                off -= 26;
                j++;
              }
            }
          } else if (endian === "le") {
            for (i = 0, j = 0; i < number.length; i += 3) {
              w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
              this.words[j] |= w << off & 67108863;
              this.words[j + 1] = w >>> 26 - off & 67108863;
              off += 24;
              if (off >= 26) {
                off -= 26;
                j++;
              }
            }
          }
          return this.strip();
        };
        function parseHex4Bits(string, index) {
          var c = string.charCodeAt(index);
          if (c >= 65 && c <= 70) {
            return c - 55;
          } else if (c >= 97 && c <= 102) {
            return c - 87;
          } else {
            return c - 48 & 15;
          }
        }
        function parseHexByte(string, lowerBound, index) {
          var r = parseHex4Bits(string, index);
          if (index - 1 >= lowerBound) {
            r |= parseHex4Bits(string, index - 1) << 4;
          }
          return r;
        }
        BN.prototype._parseHex = function _parseHex(number, start, endian) {
          this.length = Math.ceil((number.length - start) / 6);
          this.words = new Array(this.length);
          for (var i = 0; i < this.length; i++) {
            this.words[i] = 0;
          }
          var off = 0;
          var j = 0;
          var w;
          if (endian === "be") {
            for (i = number.length - 1; i >= start; i -= 2) {
              w = parseHexByte(number, start, i) << off;
              this.words[j] |= w & 67108863;
              if (off >= 18) {
                off -= 18;
                j += 1;
                this.words[j] |= w >>> 26;
              } else {
                off += 8;
              }
            }
          } else {
            var parseLength = number.length - start;
            for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
              w = parseHexByte(number, start, i) << off;
              this.words[j] |= w & 67108863;
              if (off >= 18) {
                off -= 18;
                j += 1;
                this.words[j] |= w >>> 26;
              } else {
                off += 8;
              }
            }
          }
          this.strip();
        };
        function parseBase(str, start, end, mul) {
          var r = 0;
          var len = Math.min(str.length, end);
          for (var i = start; i < len; i++) {
            var c = str.charCodeAt(i) - 48;
            r *= mul;
            if (c >= 49) {
              r += c - 49 + 10;
            } else if (c >= 17) {
              r += c - 17 + 10;
            } else {
              r += c;
            }
          }
          return r;
        }
        BN.prototype._parseBase = function _parseBase(number, base, start) {
          this.words = [0];
          this.length = 1;
          for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base) {
            limbLen++;
          }
          limbLen--;
          limbPow = limbPow / base | 0;
          var total = number.length - start;
          var mod = total % limbLen;
          var end = Math.min(total, total - mod) + start;
          var word = 0;
          for (var i = start; i < end; i += limbLen) {
            word = parseBase(number, i, i + limbLen, base);
            this.imuln(limbPow);
            if (this.words[0] + word < 67108864) {
              this.words[0] += word;
            } else {
              this._iaddn(word);
            }
          }
          if (mod !== 0) {
            var pow = 1;
            word = parseBase(number, i, number.length, base);
            for (i = 0; i < mod; i++) {
              pow *= base;
            }
            this.imuln(pow);
            if (this.words[0] + word < 67108864) {
              this.words[0] += word;
            } else {
              this._iaddn(word);
            }
          }
          this.strip();
        };
        BN.prototype.copy = function copy2(dest) {
          dest.words = new Array(this.length);
          for (var i = 0; i < this.length; i++) {
            dest.words[i] = this.words[i];
          }
          dest.length = this.length;
          dest.negative = this.negative;
          dest.red = this.red;
        };
        BN.prototype.clone = function clone() {
          var r = new BN(null);
          this.copy(r);
          return r;
        };
        BN.prototype._expand = function _expand(size) {
          while (this.length < size) {
            this.words[this.length++] = 0;
          }
          return this;
        };
        BN.prototype.strip = function strip() {
          while (this.length > 1 && this.words[this.length - 1] === 0) {
            this.length--;
          }
          return this._normSign();
        };
        BN.prototype._normSign = function _normSign() {
          if (this.length === 1 && this.words[0] === 0) {
            this.negative = 0;
          }
          return this;
        };
        BN.prototype.inspect = function inspect() {
          return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
        };
        var zeros = [
          "",
          "0",
          "00",
          "000",
          "0000",
          "00000",
          "000000",
          "0000000",
          "00000000",
          "000000000",
          "0000000000",
          "00000000000",
          "000000000000",
          "0000000000000",
          "00000000000000",
          "000000000000000",
          "0000000000000000",
          "00000000000000000",
          "000000000000000000",
          "0000000000000000000",
          "00000000000000000000",
          "000000000000000000000",
          "0000000000000000000000",
          "00000000000000000000000",
          "000000000000000000000000",
          "0000000000000000000000000"
        ];
        var groupSizes = [
          0,
          0,
          25,
          16,
          12,
          11,
          10,
          9,
          8,
          8,
          7,
          7,
          7,
          7,
          6,
          6,
          6,
          6,
          6,
          6,
          6,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5
        ];
        var groupBases = [
          0,
          0,
          33554432,
          43046721,
          16777216,
          48828125,
          60466176,
          40353607,
          16777216,
          43046721,
          1e7,
          19487171,
          35831808,
          62748517,
          7529536,
          11390625,
          16777216,
          24137569,
          34012224,
          47045881,
          64e6,
          4084101,
          5153632,
          6436343,
          7962624,
          9765625,
          11881376,
          14348907,
          17210368,
          20511149,
          243e5,
          28629151,
          33554432,
          39135393,
          45435424,
          52521875,
          60466176
        ];
        BN.prototype.toString = function toString2(base, padding) {
          base = base || 10;
          padding = padding | 0 || 1;
          var out;
          if (base === 16 || base === "hex") {
            out = "";
            var off = 0;
            var carry = 0;
            for (var i = 0; i < this.length; i++) {
              var w = this.words[i];
              var word = ((w << off | carry) & 16777215).toString(16);
              carry = w >>> 24 - off & 16777215;
              if (carry !== 0 || i !== this.length - 1) {
                out = zeros[6 - word.length] + word + out;
              } else {
                out = word + out;
              }
              off += 2;
              if (off >= 26) {
                off -= 26;
                i--;
              }
            }
            if (carry !== 0) {
              out = carry.toString(16) + out;
            }
            while (out.length % padding !== 0) {
              out = "0" + out;
            }
            if (this.negative !== 0) {
              out = "-" + out;
            }
            return out;
          }
          if (base === (base | 0) && base >= 2 && base <= 36) {
            var groupSize = groupSizes[base];
            var groupBase = groupBases[base];
            out = "";
            var c = this.clone();
            c.negative = 0;
            while (!c.isZero()) {
              var r = c.modn(groupBase).toString(base);
              c = c.idivn(groupBase);
              if (!c.isZero()) {
                out = zeros[groupSize - r.length] + r + out;
              } else {
                out = r + out;
              }
            }
            if (this.isZero()) {
              out = "0" + out;
            }
            while (out.length % padding !== 0) {
              out = "0" + out;
            }
            if (this.negative !== 0) {
              out = "-" + out;
            }
            return out;
          }
          assert(false, "Base should be between 2 and 36");
        };
        BN.prototype.toNumber = function toNumber() {
          var ret = this.words[0];
          if (this.length === 2) {
            ret += this.words[1] * 67108864;
          } else if (this.length === 3 && this.words[2] === 1) {
            ret += 4503599627370496 + this.words[1] * 67108864;
          } else if (this.length > 2) {
            assert(false, "Number can only safely store up to 53 bits");
          }
          return this.negative !== 0 ? -ret : ret;
        };
        BN.prototype.toJSON = function toJSON() {
          return this.toString(16);
        };
        BN.prototype.toBuffer = function toBuffer(endian, length) {
          assert(typeof Buffer3 !== "undefined");
          return this.toArrayLike(Buffer3, endian, length);
        };
        BN.prototype.toArray = function toArray(endian, length) {
          return this.toArrayLike(Array, endian, length);
        };
        BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
          var byteLength = this.byteLength();
          var reqLength = length || Math.max(1, byteLength);
          assert(byteLength <= reqLength, "byte array longer than desired length");
          assert(reqLength > 0, "Requested array length <= 0");
          this.strip();
          var littleEndian = endian === "le";
          var res = new ArrayType(reqLength);
          var b, i;
          var q = this.clone();
          if (!littleEndian) {
            for (i = 0; i < reqLength - byteLength; i++) {
              res[i] = 0;
            }
            for (i = 0; !q.isZero(); i++) {
              b = q.andln(255);
              q.iushrn(8);
              res[reqLength - i - 1] = b;
            }
          } else {
            for (i = 0; !q.isZero(); i++) {
              b = q.andln(255);
              q.iushrn(8);
              res[i] = b;
            }
            for (; i < reqLength; i++) {
              res[i] = 0;
            }
          }
          return res;
        };
        if (Math.clz32) {
          BN.prototype._countBits = function _countBits(w) {
            return 32 - Math.clz32(w);
          };
        } else {
          BN.prototype._countBits = function _countBits(w) {
            var t = w;
            var r = 0;
            if (t >= 4096) {
              r += 13;
              t >>>= 13;
            }
            if (t >= 64) {
              r += 7;
              t >>>= 7;
            }
            if (t >= 8) {
              r += 4;
              t >>>= 4;
            }
            if (t >= 2) {
              r += 2;
              t >>>= 2;
            }
            return r + t;
          };
        }
        BN.prototype._zeroBits = function _zeroBits(w) {
          if (w === 0)
            return 26;
          var t = w;
          var r = 0;
          if ((t & 8191) === 0) {
            r += 13;
            t >>>= 13;
          }
          if ((t & 127) === 0) {
            r += 7;
            t >>>= 7;
          }
          if ((t & 15) === 0) {
            r += 4;
            t >>>= 4;
          }
          if ((t & 3) === 0) {
            r += 2;
            t >>>= 2;
          }
          if ((t & 1) === 0) {
            r++;
          }
          return r;
        };
        BN.prototype.bitLength = function bitLength() {
          var w = this.words[this.length - 1];
          var hi = this._countBits(w);
          return (this.length - 1) * 26 + hi;
        };
        function toBitArray(num) {
          var w = new Array(num.bitLength());
          for (var bit = 0; bit < w.length; bit++) {
            var off = bit / 26 | 0;
            var wbit = bit % 26;
            w[bit] = (num.words[off] & 1 << wbit) >>> wbit;
          }
          return w;
        }
        BN.prototype.zeroBits = function zeroBits() {
          if (this.isZero())
            return 0;
          var r = 0;
          for (var i = 0; i < this.length; i++) {
            var b = this._zeroBits(this.words[i]);
            r += b;
            if (b !== 26)
              break;
          }
          return r;
        };
        BN.prototype.byteLength = function byteLength() {
          return Math.ceil(this.bitLength() / 8);
        };
        BN.prototype.toTwos = function toTwos(width) {
          if (this.negative !== 0) {
            return this.abs().inotn(width).iaddn(1);
          }
          return this.clone();
        };
        BN.prototype.fromTwos = function fromTwos(width) {
          if (this.testn(width - 1)) {
            return this.notn(width).iaddn(1).ineg();
          }
          return this.clone();
        };
        BN.prototype.isNeg = function isNeg() {
          return this.negative !== 0;
        };
        BN.prototype.neg = function neg() {
          return this.clone().ineg();
        };
        BN.prototype.ineg = function ineg() {
          if (!this.isZero()) {
            this.negative ^= 1;
          }
          return this;
        };
        BN.prototype.iuor = function iuor(num) {
          while (this.length < num.length) {
            this.words[this.length++] = 0;
          }
          for (var i = 0; i < num.length; i++) {
            this.words[i] = this.words[i] | num.words[i];
          }
          return this.strip();
        };
        BN.prototype.ior = function ior(num) {
          assert((this.negative | num.negative) === 0);
          return this.iuor(num);
        };
        BN.prototype.or = function or(num) {
          if (this.length > num.length)
            return this.clone().ior(num);
          return num.clone().ior(this);
        };
        BN.prototype.uor = function uor(num) {
          if (this.length > num.length)
            return this.clone().iuor(num);
          return num.clone().iuor(this);
        };
        BN.prototype.iuand = function iuand(num) {
          var b;
          if (this.length > num.length) {
            b = num;
          } else {
            b = this;
          }
          for (var i = 0; i < b.length; i++) {
            this.words[i] = this.words[i] & num.words[i];
          }
          this.length = b.length;
          return this.strip();
        };
        BN.prototype.iand = function iand(num) {
          assert((this.negative | num.negative) === 0);
          return this.iuand(num);
        };
        BN.prototype.and = function and(num) {
          if (this.length > num.length)
            return this.clone().iand(num);
          return num.clone().iand(this);
        };
        BN.prototype.uand = function uand(num) {
          if (this.length > num.length)
            return this.clone().iuand(num);
          return num.clone().iuand(this);
        };
        BN.prototype.iuxor = function iuxor(num) {
          var a;
          var b;
          if (this.length > num.length) {
            a = this;
            b = num;
          } else {
            a = num;
            b = this;
          }
          for (var i = 0; i < b.length; i++) {
            this.words[i] = a.words[i] ^ b.words[i];
          }
          if (this !== a) {
            for (; i < a.length; i++) {
              this.words[i] = a.words[i];
            }
          }
          this.length = a.length;
          return this.strip();
        };
        BN.prototype.ixor = function ixor(num) {
          assert((this.negative | num.negative) === 0);
          return this.iuxor(num);
        };
        BN.prototype.xor = function xor(num) {
          if (this.length > num.length)
            return this.clone().ixor(num);
          return num.clone().ixor(this);
        };
        BN.prototype.uxor = function uxor(num) {
          if (this.length > num.length)
            return this.clone().iuxor(num);
          return num.clone().iuxor(this);
        };
        BN.prototype.inotn = function inotn(width) {
          assert(typeof width === "number" && width >= 0);
          var bytesNeeded = Math.ceil(width / 26) | 0;
          var bitsLeft = width % 26;
          this._expand(bytesNeeded);
          if (bitsLeft > 0) {
            bytesNeeded--;
          }
          for (var i = 0; i < bytesNeeded; i++) {
            this.words[i] = ~this.words[i] & 67108863;
          }
          if (bitsLeft > 0) {
            this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft;
          }
          return this.strip();
        };
        BN.prototype.notn = function notn(width) {
          return this.clone().inotn(width);
        };
        BN.prototype.setn = function setn(bit, val) {
          assert(typeof bit === "number" && bit >= 0);
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          this._expand(off + 1);
          if (val) {
            this.words[off] = this.words[off] | 1 << wbit;
          } else {
            this.words[off] = this.words[off] & ~(1 << wbit);
          }
          return this.strip();
        };
        BN.prototype.iadd = function iadd(num) {
          var r;
          if (this.negative !== 0 && num.negative === 0) {
            this.negative = 0;
            r = this.isub(num);
            this.negative ^= 1;
            return this._normSign();
          } else if (this.negative === 0 && num.negative !== 0) {
            num.negative = 0;
            r = this.isub(num);
            num.negative = 1;
            return r._normSign();
          }
          var a, b;
          if (this.length > num.length) {
            a = this;
            b = num;
          } else {
            a = num;
            b = this;
          }
          var carry = 0;
          for (var i = 0; i < b.length; i++) {
            r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
            this.words[i] = r & 67108863;
            carry = r >>> 26;
          }
          for (; carry !== 0 && i < a.length; i++) {
            r = (a.words[i] | 0) + carry;
            this.words[i] = r & 67108863;
            carry = r >>> 26;
          }
          this.length = a.length;
          if (carry !== 0) {
            this.words[this.length] = carry;
            this.length++;
          } else if (a !== this) {
            for (; i < a.length; i++) {
              this.words[i] = a.words[i];
            }
          }
          return this;
        };
        BN.prototype.add = function add(num) {
          var res;
          if (num.negative !== 0 && this.negative === 0) {
            num.negative = 0;
            res = this.sub(num);
            num.negative ^= 1;
            return res;
          } else if (num.negative === 0 && this.negative !== 0) {
            this.negative = 0;
            res = num.sub(this);
            this.negative = 1;
            return res;
          }
          if (this.length > num.length)
            return this.clone().iadd(num);
          return num.clone().iadd(this);
        };
        BN.prototype.isub = function isub(num) {
          if (num.negative !== 0) {
            num.negative = 0;
            var r = this.iadd(num);
            num.negative = 1;
            return r._normSign();
          } else if (this.negative !== 0) {
            this.negative = 0;
            this.iadd(num);
            this.negative = 1;
            return this._normSign();
          }
          var cmp = this.cmp(num);
          if (cmp === 0) {
            this.negative = 0;
            this.length = 1;
            this.words[0] = 0;
            return this;
          }
          var a, b;
          if (cmp > 0) {
            a = this;
            b = num;
          } else {
            a = num;
            b = this;
          }
          var carry = 0;
          for (var i = 0; i < b.length; i++) {
            r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
            carry = r >> 26;
            this.words[i] = r & 67108863;
          }
          for (; carry !== 0 && i < a.length; i++) {
            r = (a.words[i] | 0) + carry;
            carry = r >> 26;
            this.words[i] = r & 67108863;
          }
          if (carry === 0 && i < a.length && a !== this) {
            for (; i < a.length; i++) {
              this.words[i] = a.words[i];
            }
          }
          this.length = Math.max(this.length, i);
          if (a !== this) {
            this.negative = 1;
          }
          return this.strip();
        };
        BN.prototype.sub = function sub(num) {
          return this.clone().isub(num);
        };
        function smallMulTo(self2, num, out) {
          out.negative = num.negative ^ self2.negative;
          var len = self2.length + num.length | 0;
          out.length = len;
          len = len - 1 | 0;
          var a = self2.words[0] | 0;
          var b = num.words[0] | 0;
          var r = a * b;
          var lo = r & 67108863;
          var carry = r / 67108864 | 0;
          out.words[0] = lo;
          for (var k = 1; k < len; k++) {
            var ncarry = carry >>> 26;
            var rword = carry & 67108863;
            var maxJ = Math.min(k, num.length - 1);
            for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
              var i = k - j | 0;
              a = self2.words[i] | 0;
              b = num.words[j] | 0;
              r = a * b + rword;
              ncarry += r / 67108864 | 0;
              rword = r & 67108863;
            }
            out.words[k] = rword | 0;
            carry = ncarry | 0;
          }
          if (carry !== 0) {
            out.words[k] = carry | 0;
          } else {
            out.length--;
          }
          return out.strip();
        }
        var comb10MulTo = function comb10MulTo2(self2, num, out) {
          var a = self2.words;
          var b = num.words;
          var o = out.words;
          var c = 0;
          var lo;
          var mid;
          var hi;
          var a0 = a[0] | 0;
          var al0 = a0 & 8191;
          var ah0 = a0 >>> 13;
          var a1 = a[1] | 0;
          var al1 = a1 & 8191;
          var ah1 = a1 >>> 13;
          var a2 = a[2] | 0;
          var al2 = a2 & 8191;
          var ah2 = a2 >>> 13;
          var a3 = a[3] | 0;
          var al3 = a3 & 8191;
          var ah3 = a3 >>> 13;
          var a4 = a[4] | 0;
          var al4 = a4 & 8191;
          var ah4 = a4 >>> 13;
          var a5 = a[5] | 0;
          var al5 = a5 & 8191;
          var ah5 = a5 >>> 13;
          var a6 = a[6] | 0;
          var al6 = a6 & 8191;
          var ah6 = a6 >>> 13;
          var a7 = a[7] | 0;
          var al7 = a7 & 8191;
          var ah7 = a7 >>> 13;
          var a8 = a[8] | 0;
          var al8 = a8 & 8191;
          var ah8 = a8 >>> 13;
          var a9 = a[9] | 0;
          var al9 = a9 & 8191;
          var ah9 = a9 >>> 13;
          var b0 = b[0] | 0;
          var bl0 = b0 & 8191;
          var bh0 = b0 >>> 13;
          var b1 = b[1] | 0;
          var bl1 = b1 & 8191;
          var bh1 = b1 >>> 13;
          var b2 = b[2] | 0;
          var bl2 = b2 & 8191;
          var bh2 = b2 >>> 13;
          var b3 = b[3] | 0;
          var bl3 = b3 & 8191;
          var bh3 = b3 >>> 13;
          var b4 = b[4] | 0;
          var bl4 = b4 & 8191;
          var bh4 = b4 >>> 13;
          var b5 = b[5] | 0;
          var bl5 = b5 & 8191;
          var bh5 = b5 >>> 13;
          var b6 = b[6] | 0;
          var bl6 = b6 & 8191;
          var bh6 = b6 >>> 13;
          var b7 = b[7] | 0;
          var bl7 = b7 & 8191;
          var bh7 = b7 >>> 13;
          var b8 = b[8] | 0;
          var bl8 = b8 & 8191;
          var bh8 = b8 >>> 13;
          var b9 = b[9] | 0;
          var bl9 = b9 & 8191;
          var bh9 = b9 >>> 13;
          out.negative = self2.negative ^ num.negative;
          out.length = 19;
          lo = Math.imul(al0, bl0);
          mid = Math.imul(al0, bh0);
          mid = mid + Math.imul(ah0, bl0) | 0;
          hi = Math.imul(ah0, bh0);
          var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
          w0 &= 67108863;
          lo = Math.imul(al1, bl0);
          mid = Math.imul(al1, bh0);
          mid = mid + Math.imul(ah1, bl0) | 0;
          hi = Math.imul(ah1, bh0);
          lo = lo + Math.imul(al0, bl1) | 0;
          mid = mid + Math.imul(al0, bh1) | 0;
          mid = mid + Math.imul(ah0, bl1) | 0;
          hi = hi + Math.imul(ah0, bh1) | 0;
          var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
          w1 &= 67108863;
          lo = Math.imul(al2, bl0);
          mid = Math.imul(al2, bh0);
          mid = mid + Math.imul(ah2, bl0) | 0;
          hi = Math.imul(ah2, bh0);
          lo = lo + Math.imul(al1, bl1) | 0;
          mid = mid + Math.imul(al1, bh1) | 0;
          mid = mid + Math.imul(ah1, bl1) | 0;
          hi = hi + Math.imul(ah1, bh1) | 0;
          lo = lo + Math.imul(al0, bl2) | 0;
          mid = mid + Math.imul(al0, bh2) | 0;
          mid = mid + Math.imul(ah0, bl2) | 0;
          hi = hi + Math.imul(ah0, bh2) | 0;
          var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
          w2 &= 67108863;
          lo = Math.imul(al3, bl0);
          mid = Math.imul(al3, bh0);
          mid = mid + Math.imul(ah3, bl0) | 0;
          hi = Math.imul(ah3, bh0);
          lo = lo + Math.imul(al2, bl1) | 0;
          mid = mid + Math.imul(al2, bh1) | 0;
          mid = mid + Math.imul(ah2, bl1) | 0;
          hi = hi + Math.imul(ah2, bh1) | 0;
          lo = lo + Math.imul(al1, bl2) | 0;
          mid = mid + Math.imul(al1, bh2) | 0;
          mid = mid + Math.imul(ah1, bl2) | 0;
          hi = hi + Math.imul(ah1, bh2) | 0;
          lo = lo + Math.imul(al0, bl3) | 0;
          mid = mid + Math.imul(al0, bh3) | 0;
          mid = mid + Math.imul(ah0, bl3) | 0;
          hi = hi + Math.imul(ah0, bh3) | 0;
          var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
          w3 &= 67108863;
          lo = Math.imul(al4, bl0);
          mid = Math.imul(al4, bh0);
          mid = mid + Math.imul(ah4, bl0) | 0;
          hi = Math.imul(ah4, bh0);
          lo = lo + Math.imul(al3, bl1) | 0;
          mid = mid + Math.imul(al3, bh1) | 0;
          mid = mid + Math.imul(ah3, bl1) | 0;
          hi = hi + Math.imul(ah3, bh1) | 0;
          lo = lo + Math.imul(al2, bl2) | 0;
          mid = mid + Math.imul(al2, bh2) | 0;
          mid = mid + Math.imul(ah2, bl2) | 0;
          hi = hi + Math.imul(ah2, bh2) | 0;
          lo = lo + Math.imul(al1, bl3) | 0;
          mid = mid + Math.imul(al1, bh3) | 0;
          mid = mid + Math.imul(ah1, bl3) | 0;
          hi = hi + Math.imul(ah1, bh3) | 0;
          lo = lo + Math.imul(al0, bl4) | 0;
          mid = mid + Math.imul(al0, bh4) | 0;
          mid = mid + Math.imul(ah0, bl4) | 0;
          hi = hi + Math.imul(ah0, bh4) | 0;
          var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
          w4 &= 67108863;
          lo = Math.imul(al5, bl0);
          mid = Math.imul(al5, bh0);
          mid = mid + Math.imul(ah5, bl0) | 0;
          hi = Math.imul(ah5, bh0);
          lo = lo + Math.imul(al4, bl1) | 0;
          mid = mid + Math.imul(al4, bh1) | 0;
          mid = mid + Math.imul(ah4, bl1) | 0;
          hi = hi + Math.imul(ah4, bh1) | 0;
          lo = lo + Math.imul(al3, bl2) | 0;
          mid = mid + Math.imul(al3, bh2) | 0;
          mid = mid + Math.imul(ah3, bl2) | 0;
          hi = hi + Math.imul(ah3, bh2) | 0;
          lo = lo + Math.imul(al2, bl3) | 0;
          mid = mid + Math.imul(al2, bh3) | 0;
          mid = mid + Math.imul(ah2, bl3) | 0;
          hi = hi + Math.imul(ah2, bh3) | 0;
          lo = lo + Math.imul(al1, bl4) | 0;
          mid = mid + Math.imul(al1, bh4) | 0;
          mid = mid + Math.imul(ah1, bl4) | 0;
          hi = hi + Math.imul(ah1, bh4) | 0;
          lo = lo + Math.imul(al0, bl5) | 0;
          mid = mid + Math.imul(al0, bh5) | 0;
          mid = mid + Math.imul(ah0, bl5) | 0;
          hi = hi + Math.imul(ah0, bh5) | 0;
          var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
          w5 &= 67108863;
          lo = Math.imul(al6, bl0);
          mid = Math.imul(al6, bh0);
          mid = mid + Math.imul(ah6, bl0) | 0;
          hi = Math.imul(ah6, bh0);
          lo = lo + Math.imul(al5, bl1) | 0;
          mid = mid + Math.imul(al5, bh1) | 0;
          mid = mid + Math.imul(ah5, bl1) | 0;
          hi = hi + Math.imul(ah5, bh1) | 0;
          lo = lo + Math.imul(al4, bl2) | 0;
          mid = mid + Math.imul(al4, bh2) | 0;
          mid = mid + Math.imul(ah4, bl2) | 0;
          hi = hi + Math.imul(ah4, bh2) | 0;
          lo = lo + Math.imul(al3, bl3) | 0;
          mid = mid + Math.imul(al3, bh3) | 0;
          mid = mid + Math.imul(ah3, bl3) | 0;
          hi = hi + Math.imul(ah3, bh3) | 0;
          lo = lo + Math.imul(al2, bl4) | 0;
          mid = mid + Math.imul(al2, bh4) | 0;
          mid = mid + Math.imul(ah2, bl4) | 0;
          hi = hi + Math.imul(ah2, bh4) | 0;
          lo = lo + Math.imul(al1, bl5) | 0;
          mid = mid + Math.imul(al1, bh5) | 0;
          mid = mid + Math.imul(ah1, bl5) | 0;
          hi = hi + Math.imul(ah1, bh5) | 0;
          lo = lo + Math.imul(al0, bl6) | 0;
          mid = mid + Math.imul(al0, bh6) | 0;
          mid = mid + Math.imul(ah0, bl6) | 0;
          hi = hi + Math.imul(ah0, bh6) | 0;
          var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
          w6 &= 67108863;
          lo = Math.imul(al7, bl0);
          mid = Math.imul(al7, bh0);
          mid = mid + Math.imul(ah7, bl0) | 0;
          hi = Math.imul(ah7, bh0);
          lo = lo + Math.imul(al6, bl1) | 0;
          mid = mid + Math.imul(al6, bh1) | 0;
          mid = mid + Math.imul(ah6, bl1) | 0;
          hi = hi + Math.imul(ah6, bh1) | 0;
          lo = lo + Math.imul(al5, bl2) | 0;
          mid = mid + Math.imul(al5, bh2) | 0;
          mid = mid + Math.imul(ah5, bl2) | 0;
          hi = hi + Math.imul(ah5, bh2) | 0;
          lo = lo + Math.imul(al4, bl3) | 0;
          mid = mid + Math.imul(al4, bh3) | 0;
          mid = mid + Math.imul(ah4, bl3) | 0;
          hi = hi + Math.imul(ah4, bh3) | 0;
          lo = lo + Math.imul(al3, bl4) | 0;
          mid = mid + Math.imul(al3, bh4) | 0;
          mid = mid + Math.imul(ah3, bl4) | 0;
          hi = hi + Math.imul(ah3, bh4) | 0;
          lo = lo + Math.imul(al2, bl5) | 0;
          mid = mid + Math.imul(al2, bh5) | 0;
          mid = mid + Math.imul(ah2, bl5) | 0;
          hi = hi + Math.imul(ah2, bh5) | 0;
          lo = lo + Math.imul(al1, bl6) | 0;
          mid = mid + Math.imul(al1, bh6) | 0;
          mid = mid + Math.imul(ah1, bl6) | 0;
          hi = hi + Math.imul(ah1, bh6) | 0;
          lo = lo + Math.imul(al0, bl7) | 0;
          mid = mid + Math.imul(al0, bh7) | 0;
          mid = mid + Math.imul(ah0, bl7) | 0;
          hi = hi + Math.imul(ah0, bh7) | 0;
          var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
          w7 &= 67108863;
          lo = Math.imul(al8, bl0);
          mid = Math.imul(al8, bh0);
          mid = mid + Math.imul(ah8, bl0) | 0;
          hi = Math.imul(ah8, bh0);
          lo = lo + Math.imul(al7, bl1) | 0;
          mid = mid + Math.imul(al7, bh1) | 0;
          mid = mid + Math.imul(ah7, bl1) | 0;
          hi = hi + Math.imul(ah7, bh1) | 0;
          lo = lo + Math.imul(al6, bl2) | 0;
          mid = mid + Math.imul(al6, bh2) | 0;
          mid = mid + Math.imul(ah6, bl2) | 0;
          hi = hi + Math.imul(ah6, bh2) | 0;
          lo = lo + Math.imul(al5, bl3) | 0;
          mid = mid + Math.imul(al5, bh3) | 0;
          mid = mid + Math.imul(ah5, bl3) | 0;
          hi = hi + Math.imul(ah5, bh3) | 0;
          lo = lo + Math.imul(al4, bl4) | 0;
          mid = mid + Math.imul(al4, bh4) | 0;
          mid = mid + Math.imul(ah4, bl4) | 0;
          hi = hi + Math.imul(ah4, bh4) | 0;
          lo = lo + Math.imul(al3, bl5) | 0;
          mid = mid + Math.imul(al3, bh5) | 0;
          mid = mid + Math.imul(ah3, bl5) | 0;
          hi = hi + Math.imul(ah3, bh5) | 0;
          lo = lo + Math.imul(al2, bl6) | 0;
          mid = mid + Math.imul(al2, bh6) | 0;
          mid = mid + Math.imul(ah2, bl6) | 0;
          hi = hi + Math.imul(ah2, bh6) | 0;
          lo = lo + Math.imul(al1, bl7) | 0;
          mid = mid + Math.imul(al1, bh7) | 0;
          mid = mid + Math.imul(ah1, bl7) | 0;
          hi = hi + Math.imul(ah1, bh7) | 0;
          lo = lo + Math.imul(al0, bl8) | 0;
          mid = mid + Math.imul(al0, bh8) | 0;
          mid = mid + Math.imul(ah0, bl8) | 0;
          hi = hi + Math.imul(ah0, bh8) | 0;
          var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
          w8 &= 67108863;
          lo = Math.imul(al9, bl0);
          mid = Math.imul(al9, bh0);
          mid = mid + Math.imul(ah9, bl0) | 0;
          hi = Math.imul(ah9, bh0);
          lo = lo + Math.imul(al8, bl1) | 0;
          mid = mid + Math.imul(al8, bh1) | 0;
          mid = mid + Math.imul(ah8, bl1) | 0;
          hi = hi + Math.imul(ah8, bh1) | 0;
          lo = lo + Math.imul(al7, bl2) | 0;
          mid = mid + Math.imul(al7, bh2) | 0;
          mid = mid + Math.imul(ah7, bl2) | 0;
          hi = hi + Math.imul(ah7, bh2) | 0;
          lo = lo + Math.imul(al6, bl3) | 0;
          mid = mid + Math.imul(al6, bh3) | 0;
          mid = mid + Math.imul(ah6, bl3) | 0;
          hi = hi + Math.imul(ah6, bh3) | 0;
          lo = lo + Math.imul(al5, bl4) | 0;
          mid = mid + Math.imul(al5, bh4) | 0;
          mid = mid + Math.imul(ah5, bl4) | 0;
          hi = hi + Math.imul(ah5, bh4) | 0;
          lo = lo + Math.imul(al4, bl5) | 0;
          mid = mid + Math.imul(al4, bh5) | 0;
          mid = mid + Math.imul(ah4, bl5) | 0;
          hi = hi + Math.imul(ah4, bh5) | 0;
          lo = lo + Math.imul(al3, bl6) | 0;
          mid = mid + Math.imul(al3, bh6) | 0;
          mid = mid + Math.imul(ah3, bl6) | 0;
          hi = hi + Math.imul(ah3, bh6) | 0;
          lo = lo + Math.imul(al2, bl7) | 0;
          mid = mid + Math.imul(al2, bh7) | 0;
          mid = mid + Math.imul(ah2, bl7) | 0;
          hi = hi + Math.imul(ah2, bh7) | 0;
          lo = lo + Math.imul(al1, bl8) | 0;
          mid = mid + Math.imul(al1, bh8) | 0;
          mid = mid + Math.imul(ah1, bl8) | 0;
          hi = hi + Math.imul(ah1, bh8) | 0;
          lo = lo + Math.imul(al0, bl9) | 0;
          mid = mid + Math.imul(al0, bh9) | 0;
          mid = mid + Math.imul(ah0, bl9) | 0;
          hi = hi + Math.imul(ah0, bh9) | 0;
          var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
          w9 &= 67108863;
          lo = Math.imul(al9, bl1);
          mid = Math.imul(al9, bh1);
          mid = mid + Math.imul(ah9, bl1) | 0;
          hi = Math.imul(ah9, bh1);
          lo = lo + Math.imul(al8, bl2) | 0;
          mid = mid + Math.imul(al8, bh2) | 0;
          mid = mid + Math.imul(ah8, bl2) | 0;
          hi = hi + Math.imul(ah8, bh2) | 0;
          lo = lo + Math.imul(al7, bl3) | 0;
          mid = mid + Math.imul(al7, bh3) | 0;
          mid = mid + Math.imul(ah7, bl3) | 0;
          hi = hi + Math.imul(ah7, bh3) | 0;
          lo = lo + Math.imul(al6, bl4) | 0;
          mid = mid + Math.imul(al6, bh4) | 0;
          mid = mid + Math.imul(ah6, bl4) | 0;
          hi = hi + Math.imul(ah6, bh4) | 0;
          lo = lo + Math.imul(al5, bl5) | 0;
          mid = mid + Math.imul(al5, bh5) | 0;
          mid = mid + Math.imul(ah5, bl5) | 0;
          hi = hi + Math.imul(ah5, bh5) | 0;
          lo = lo + Math.imul(al4, bl6) | 0;
          mid = mid + Math.imul(al4, bh6) | 0;
          mid = mid + Math.imul(ah4, bl6) | 0;
          hi = hi + Math.imul(ah4, bh6) | 0;
          lo = lo + Math.imul(al3, bl7) | 0;
          mid = mid + Math.imul(al3, bh7) | 0;
          mid = mid + Math.imul(ah3, bl7) | 0;
          hi = hi + Math.imul(ah3, bh7) | 0;
          lo = lo + Math.imul(al2, bl8) | 0;
          mid = mid + Math.imul(al2, bh8) | 0;
          mid = mid + Math.imul(ah2, bl8) | 0;
          hi = hi + Math.imul(ah2, bh8) | 0;
          lo = lo + Math.imul(al1, bl9) | 0;
          mid = mid + Math.imul(al1, bh9) | 0;
          mid = mid + Math.imul(ah1, bl9) | 0;
          hi = hi + Math.imul(ah1, bh9) | 0;
          var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
          w10 &= 67108863;
          lo = Math.imul(al9, bl2);
          mid = Math.imul(al9, bh2);
          mid = mid + Math.imul(ah9, bl2) | 0;
          hi = Math.imul(ah9, bh2);
          lo = lo + Math.imul(al8, bl3) | 0;
          mid = mid + Math.imul(al8, bh3) | 0;
          mid = mid + Math.imul(ah8, bl3) | 0;
          hi = hi + Math.imul(ah8, bh3) | 0;
          lo = lo + Math.imul(al7, bl4) | 0;
          mid = mid + Math.imul(al7, bh4) | 0;
          mid = mid + Math.imul(ah7, bl4) | 0;
          hi = hi + Math.imul(ah7, bh4) | 0;
          lo = lo + Math.imul(al6, bl5) | 0;
          mid = mid + Math.imul(al6, bh5) | 0;
          mid = mid + Math.imul(ah6, bl5) | 0;
          hi = hi + Math.imul(ah6, bh5) | 0;
          lo = lo + Math.imul(al5, bl6) | 0;
          mid = mid + Math.imul(al5, bh6) | 0;
          mid = mid + Math.imul(ah5, bl6) | 0;
          hi = hi + Math.imul(ah5, bh6) | 0;
          lo = lo + Math.imul(al4, bl7) | 0;
          mid = mid + Math.imul(al4, bh7) | 0;
          mid = mid + Math.imul(ah4, bl7) | 0;
          hi = hi + Math.imul(ah4, bh7) | 0;
          lo = lo + Math.imul(al3, bl8) | 0;
          mid = mid + Math.imul(al3, bh8) | 0;
          mid = mid + Math.imul(ah3, bl8) | 0;
          hi = hi + Math.imul(ah3, bh8) | 0;
          lo = lo + Math.imul(al2, bl9) | 0;
          mid = mid + Math.imul(al2, bh9) | 0;
          mid = mid + Math.imul(ah2, bl9) | 0;
          hi = hi + Math.imul(ah2, bh9) | 0;
          var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
          w11 &= 67108863;
          lo = Math.imul(al9, bl3);
          mid = Math.imul(al9, bh3);
          mid = mid + Math.imul(ah9, bl3) | 0;
          hi = Math.imul(ah9, bh3);
          lo = lo + Math.imul(al8, bl4) | 0;
          mid = mid + Math.imul(al8, bh4) | 0;
          mid = mid + Math.imul(ah8, bl4) | 0;
          hi = hi + Math.imul(ah8, bh4) | 0;
          lo = lo + Math.imul(al7, bl5) | 0;
          mid = mid + Math.imul(al7, bh5) | 0;
          mid = mid + Math.imul(ah7, bl5) | 0;
          hi = hi + Math.imul(ah7, bh5) | 0;
          lo = lo + Math.imul(al6, bl6) | 0;
          mid = mid + Math.imul(al6, bh6) | 0;
          mid = mid + Math.imul(ah6, bl6) | 0;
          hi = hi + Math.imul(ah6, bh6) | 0;
          lo = lo + Math.imul(al5, bl7) | 0;
          mid = mid + Math.imul(al5, bh7) | 0;
          mid = mid + Math.imul(ah5, bl7) | 0;
          hi = hi + Math.imul(ah5, bh7) | 0;
          lo = lo + Math.imul(al4, bl8) | 0;
          mid = mid + Math.imul(al4, bh8) | 0;
          mid = mid + Math.imul(ah4, bl8) | 0;
          hi = hi + Math.imul(ah4, bh8) | 0;
          lo = lo + Math.imul(al3, bl9) | 0;
          mid = mid + Math.imul(al3, bh9) | 0;
          mid = mid + Math.imul(ah3, bl9) | 0;
          hi = hi + Math.imul(ah3, bh9) | 0;
          var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
          w12 &= 67108863;
          lo = Math.imul(al9, bl4);
          mid = Math.imul(al9, bh4);
          mid = mid + Math.imul(ah9, bl4) | 0;
          hi = Math.imul(ah9, bh4);
          lo = lo + Math.imul(al8, bl5) | 0;
          mid = mid + Math.imul(al8, bh5) | 0;
          mid = mid + Math.imul(ah8, bl5) | 0;
          hi = hi + Math.imul(ah8, bh5) | 0;
          lo = lo + Math.imul(al7, bl6) | 0;
          mid = mid + Math.imul(al7, bh6) | 0;
          mid = mid + Math.imul(ah7, bl6) | 0;
          hi = hi + Math.imul(ah7, bh6) | 0;
          lo = lo + Math.imul(al6, bl7) | 0;
          mid = mid + Math.imul(al6, bh7) | 0;
          mid = mid + Math.imul(ah6, bl7) | 0;
          hi = hi + Math.imul(ah6, bh7) | 0;
          lo = lo + Math.imul(al5, bl8) | 0;
          mid = mid + Math.imul(al5, bh8) | 0;
          mid = mid + Math.imul(ah5, bl8) | 0;
          hi = hi + Math.imul(ah5, bh8) | 0;
          lo = lo + Math.imul(al4, bl9) | 0;
          mid = mid + Math.imul(al4, bh9) | 0;
          mid = mid + Math.imul(ah4, bl9) | 0;
          hi = hi + Math.imul(ah4, bh9) | 0;
          var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
          w13 &= 67108863;
          lo = Math.imul(al9, bl5);
          mid = Math.imul(al9, bh5);
          mid = mid + Math.imul(ah9, bl5) | 0;
          hi = Math.imul(ah9, bh5);
          lo = lo + Math.imul(al8, bl6) | 0;
          mid = mid + Math.imul(al8, bh6) | 0;
          mid = mid + Math.imul(ah8, bl6) | 0;
          hi = hi + Math.imul(ah8, bh6) | 0;
          lo = lo + Math.imul(al7, bl7) | 0;
          mid = mid + Math.imul(al7, bh7) | 0;
          mid = mid + Math.imul(ah7, bl7) | 0;
          hi = hi + Math.imul(ah7, bh7) | 0;
          lo = lo + Math.imul(al6, bl8) | 0;
          mid = mid + Math.imul(al6, bh8) | 0;
          mid = mid + Math.imul(ah6, bl8) | 0;
          hi = hi + Math.imul(ah6, bh8) | 0;
          lo = lo + Math.imul(al5, bl9) | 0;
          mid = mid + Math.imul(al5, bh9) | 0;
          mid = mid + Math.imul(ah5, bl9) | 0;
          hi = hi + Math.imul(ah5, bh9) | 0;
          var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
          w14 &= 67108863;
          lo = Math.imul(al9, bl6);
          mid = Math.imul(al9, bh6);
          mid = mid + Math.imul(ah9, bl6) | 0;
          hi = Math.imul(ah9, bh6);
          lo = lo + Math.imul(al8, bl7) | 0;
          mid = mid + Math.imul(al8, bh7) | 0;
          mid = mid + Math.imul(ah8, bl7) | 0;
          hi = hi + Math.imul(ah8, bh7) | 0;
          lo = lo + Math.imul(al7, bl8) | 0;
          mid = mid + Math.imul(al7, bh8) | 0;
          mid = mid + Math.imul(ah7, bl8) | 0;
          hi = hi + Math.imul(ah7, bh8) | 0;
          lo = lo + Math.imul(al6, bl9) | 0;
          mid = mid + Math.imul(al6, bh9) | 0;
          mid = mid + Math.imul(ah6, bl9) | 0;
          hi = hi + Math.imul(ah6, bh9) | 0;
          var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
          w15 &= 67108863;
          lo = Math.imul(al9, bl7);
          mid = Math.imul(al9, bh7);
          mid = mid + Math.imul(ah9, bl7) | 0;
          hi = Math.imul(ah9, bh7);
          lo = lo + Math.imul(al8, bl8) | 0;
          mid = mid + Math.imul(al8, bh8) | 0;
          mid = mid + Math.imul(ah8, bl8) | 0;
          hi = hi + Math.imul(ah8, bh8) | 0;
          lo = lo + Math.imul(al7, bl9) | 0;
          mid = mid + Math.imul(al7, bh9) | 0;
          mid = mid + Math.imul(ah7, bl9) | 0;
          hi = hi + Math.imul(ah7, bh9) | 0;
          var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
          w16 &= 67108863;
          lo = Math.imul(al9, bl8);
          mid = Math.imul(al9, bh8);
          mid = mid + Math.imul(ah9, bl8) | 0;
          hi = Math.imul(ah9, bh8);
          lo = lo + Math.imul(al8, bl9) | 0;
          mid = mid + Math.imul(al8, bh9) | 0;
          mid = mid + Math.imul(ah8, bl9) | 0;
          hi = hi + Math.imul(ah8, bh9) | 0;
          var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
          w17 &= 67108863;
          lo = Math.imul(al9, bl9);
          mid = Math.imul(al9, bh9);
          mid = mid + Math.imul(ah9, bl9) | 0;
          hi = Math.imul(ah9, bh9);
          var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
          w18 &= 67108863;
          o[0] = w0;
          o[1] = w1;
          o[2] = w2;
          o[3] = w3;
          o[4] = w4;
          o[5] = w5;
          o[6] = w6;
          o[7] = w7;
          o[8] = w8;
          o[9] = w9;
          o[10] = w10;
          o[11] = w11;
          o[12] = w12;
          o[13] = w13;
          o[14] = w14;
          o[15] = w15;
          o[16] = w16;
          o[17] = w17;
          o[18] = w18;
          if (c !== 0) {
            o[19] = c;
            out.length++;
          }
          return out;
        };
        if (!Math.imul) {
          comb10MulTo = smallMulTo;
        }
        function bigMulTo(self2, num, out) {
          out.negative = num.negative ^ self2.negative;
          out.length = self2.length + num.length;
          var carry = 0;
          var hncarry = 0;
          for (var k = 0; k < out.length - 1; k++) {
            var ncarry = hncarry;
            hncarry = 0;
            var rword = carry & 67108863;
            var maxJ = Math.min(k, num.length - 1);
            for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
              var i = k - j;
              var a = self2.words[i] | 0;
              var b = num.words[j] | 0;
              var r = a * b;
              var lo = r & 67108863;
              ncarry = ncarry + (r / 67108864 | 0) | 0;
              lo = lo + rword | 0;
              rword = lo & 67108863;
              ncarry = ncarry + (lo >>> 26) | 0;
              hncarry += ncarry >>> 26;
              ncarry &= 67108863;
            }
            out.words[k] = rword;
            carry = ncarry;
            ncarry = hncarry;
          }
          if (carry !== 0) {
            out.words[k] = carry;
          } else {
            out.length--;
          }
          return out.strip();
        }
        function jumboMulTo(self2, num, out) {
          var fftm = new FFTM();
          return fftm.mulp(self2, num, out);
        }
        BN.prototype.mulTo = function mulTo(num, out) {
          var res;
          var len = this.length + num.length;
          if (this.length === 10 && num.length === 10) {
            res = comb10MulTo(this, num, out);
          } else if (len < 63) {
            res = smallMulTo(this, num, out);
          } else if (len < 1024) {
            res = bigMulTo(this, num, out);
          } else {
            res = jumboMulTo(this, num, out);
          }
          return res;
        };
        function FFTM(x, y) {
          this.x = x;
          this.y = y;
        }
        FFTM.prototype.makeRBT = function makeRBT(N) {
          var t = new Array(N);
          var l = BN.prototype._countBits(N) - 1;
          for (var i = 0; i < N; i++) {
            t[i] = this.revBin(i, l, N);
          }
          return t;
        };
        FFTM.prototype.revBin = function revBin(x, l, N) {
          if (x === 0 || x === N - 1)
            return x;
          var rb = 0;
          for (var i = 0; i < l; i++) {
            rb |= (x & 1) << l - i - 1;
            x >>= 1;
          }
          return rb;
        };
        FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
          for (var i = 0; i < N; i++) {
            rtws[i] = rws[rbt[i]];
            itws[i] = iws[rbt[i]];
          }
        };
        FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
          this.permute(rbt, rws, iws, rtws, itws, N);
          for (var s = 1; s < N; s <<= 1) {
            var l = s << 1;
            var rtwdf = Math.cos(2 * Math.PI / l);
            var itwdf = Math.sin(2 * Math.PI / l);
            for (var p = 0; p < N; p += l) {
              var rtwdf_ = rtwdf;
              var itwdf_ = itwdf;
              for (var j = 0; j < s; j++) {
                var re = rtws[p + j];
                var ie = itws[p + j];
                var ro = rtws[p + j + s];
                var io = itws[p + j + s];
                var rx = rtwdf_ * ro - itwdf_ * io;
                io = rtwdf_ * io + itwdf_ * ro;
                ro = rx;
                rtws[p + j] = re + ro;
                itws[p + j] = ie + io;
                rtws[p + j + s] = re - ro;
                itws[p + j + s] = ie - io;
                if (j !== l) {
                  rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                  itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                  rtwdf_ = rx;
                }
              }
            }
          }
        };
        FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
          var N = Math.max(m, n) | 1;
          var odd = N & 1;
          var i = 0;
          for (N = N / 2 | 0; N; N = N >>> 1) {
            i++;
          }
          return 1 << i + 1 + odd;
        };
        FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
          if (N <= 1)
            return;
          for (var i = 0; i < N / 2; i++) {
            var t = rws[i];
            rws[i] = rws[N - i - 1];
            rws[N - i - 1] = t;
            t = iws[i];
            iws[i] = -iws[N - i - 1];
            iws[N - i - 1] = -t;
          }
        };
        FFTM.prototype.normalize13b = function normalize13b(ws, N) {
          var carry = 0;
          for (var i = 0; i < N / 2; i++) {
            var w = Math.round(ws[2 * i + 1] / N) * 8192 + Math.round(ws[2 * i] / N) + carry;
            ws[i] = w & 67108863;
            if (w < 67108864) {
              carry = 0;
            } else {
              carry = w / 67108864 | 0;
            }
          }
          return ws;
        };
        FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
          var carry = 0;
          for (var i = 0; i < len; i++) {
            carry = carry + (ws[i] | 0);
            rws[2 * i] = carry & 8191;
            carry = carry >>> 13;
            rws[2 * i + 1] = carry & 8191;
            carry = carry >>> 13;
          }
          for (i = 2 * len; i < N; ++i) {
            rws[i] = 0;
          }
          assert(carry === 0);
          assert((carry & ~8191) === 0);
        };
        FFTM.prototype.stub = function stub(N) {
          var ph = new Array(N);
          for (var i = 0; i < N; i++) {
            ph[i] = 0;
          }
          return ph;
        };
        FFTM.prototype.mulp = function mulp(x, y, out) {
          var N = 2 * this.guessLen13b(x.length, y.length);
          var rbt = this.makeRBT(N);
          var _ = this.stub(N);
          var rws = new Array(N);
          var rwst = new Array(N);
          var iwst = new Array(N);
          var nrws = new Array(N);
          var nrwst = new Array(N);
          var niwst = new Array(N);
          var rmws = out.words;
          rmws.length = N;
          this.convert13b(x.words, x.length, rws, N);
          this.convert13b(y.words, y.length, nrws, N);
          this.transform(rws, _, rwst, iwst, N, rbt);
          this.transform(nrws, _, nrwst, niwst, N, rbt);
          for (var i = 0; i < N; i++) {
            var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
            iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
            rwst[i] = rx;
          }
          this.conjugate(rwst, iwst, N);
          this.transform(rwst, iwst, rmws, _, N, rbt);
          this.conjugate(rmws, _, N);
          this.normalize13b(rmws, N);
          out.negative = x.negative ^ y.negative;
          out.length = x.length + y.length;
          return out.strip();
        };
        BN.prototype.mul = function mul(num) {
          var out = new BN(null);
          out.words = new Array(this.length + num.length);
          return this.mulTo(num, out);
        };
        BN.prototype.mulf = function mulf(num) {
          var out = new BN(null);
          out.words = new Array(this.length + num.length);
          return jumboMulTo(this, num, out);
        };
        BN.prototype.imul = function imul(num) {
          return this.clone().mulTo(num, this);
        };
        BN.prototype.imuln = function imuln(num) {
          assert(typeof num === "number");
          assert(num < 67108864);
          var carry = 0;
          for (var i = 0; i < this.length; i++) {
            var w = (this.words[i] | 0) * num;
            var lo = (w & 67108863) + (carry & 67108863);
            carry >>= 26;
            carry += w / 67108864 | 0;
            carry += lo >>> 26;
            this.words[i] = lo & 67108863;
          }
          if (carry !== 0) {
            this.words[i] = carry;
            this.length++;
          }
          return this;
        };
        BN.prototype.muln = function muln(num) {
          return this.clone().imuln(num);
        };
        BN.prototype.sqr = function sqr() {
          return this.mul(this);
        };
        BN.prototype.isqr = function isqr() {
          return this.imul(this.clone());
        };
        BN.prototype.pow = function pow(num) {
          var w = toBitArray(num);
          if (w.length === 0)
            return new BN(1);
          var res = this;
          for (var i = 0; i < w.length; i++, res = res.sqr()) {
            if (w[i] !== 0)
              break;
          }
          if (++i < w.length) {
            for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
              if (w[i] === 0)
                continue;
              res = res.mul(q);
            }
          }
          return res;
        };
        BN.prototype.iushln = function iushln(bits) {
          assert(typeof bits === "number" && bits >= 0);
          var r = bits % 26;
          var s = (bits - r) / 26;
          var carryMask = 67108863 >>> 26 - r << 26 - r;
          var i;
          if (r !== 0) {
            var carry = 0;
            for (i = 0; i < this.length; i++) {
              var newCarry = this.words[i] & carryMask;
              var c = (this.words[i] | 0) - newCarry << r;
              this.words[i] = c | carry;
              carry = newCarry >>> 26 - r;
            }
            if (carry) {
              this.words[i] = carry;
              this.length++;
            }
          }
          if (s !== 0) {
            for (i = this.length - 1; i >= 0; i--) {
              this.words[i + s] = this.words[i];
            }
            for (i = 0; i < s; i++) {
              this.words[i] = 0;
            }
            this.length += s;
          }
          return this.strip();
        };
        BN.prototype.ishln = function ishln(bits) {
          assert(this.negative === 0);
          return this.iushln(bits);
        };
        BN.prototype.iushrn = function iushrn(bits, hint, extended) {
          assert(typeof bits === "number" && bits >= 0);
          var h;
          if (hint) {
            h = (hint - hint % 26) / 26;
          } else {
            h = 0;
          }
          var r = bits % 26;
          var s = Math.min((bits - r) / 26, this.length);
          var mask = 67108863 ^ 67108863 >>> r << r;
          var maskedWords = extended;
          h -= s;
          h = Math.max(0, h);
          if (maskedWords) {
            for (var i = 0; i < s; i++) {
              maskedWords.words[i] = this.words[i];
            }
            maskedWords.length = s;
          }
          if (s === 0) {
          } else if (this.length > s) {
            this.length -= s;
            for (i = 0; i < this.length; i++) {
              this.words[i] = this.words[i + s];
            }
          } else {
            this.words[0] = 0;
            this.length = 1;
          }
          var carry = 0;
          for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
            var word = this.words[i] | 0;
            this.words[i] = carry << 26 - r | word >>> r;
            carry = word & mask;
          }
          if (maskedWords && carry !== 0) {
            maskedWords.words[maskedWords.length++] = carry;
          }
          if (this.length === 0) {
            this.words[0] = 0;
            this.length = 1;
          }
          return this.strip();
        };
        BN.prototype.ishrn = function ishrn(bits, hint, extended) {
          assert(this.negative === 0);
          return this.iushrn(bits, hint, extended);
        };
        BN.prototype.shln = function shln(bits) {
          return this.clone().ishln(bits);
        };
        BN.prototype.ushln = function ushln(bits) {
          return this.clone().iushln(bits);
        };
        BN.prototype.shrn = function shrn(bits) {
          return this.clone().ishrn(bits);
        };
        BN.prototype.ushrn = function ushrn(bits) {
          return this.clone().iushrn(bits);
        };
        BN.prototype.testn = function testn(bit) {
          assert(typeof bit === "number" && bit >= 0);
          var r = bit % 26;
          var s = (bit - r) / 26;
          var q = 1 << r;
          if (this.length <= s)
            return false;
          var w = this.words[s];
          return !!(w & q);
        };
        BN.prototype.imaskn = function imaskn(bits) {
          assert(typeof bits === "number" && bits >= 0);
          var r = bits % 26;
          var s = (bits - r) / 26;
          assert(this.negative === 0, "imaskn works only with positive numbers");
          if (this.length <= s) {
            return this;
          }
          if (r !== 0) {
            s++;
          }
          this.length = Math.min(s, this.length);
          if (r !== 0) {
            var mask = 67108863 ^ 67108863 >>> r << r;
            this.words[this.length - 1] &= mask;
          }
          return this.strip();
        };
        BN.prototype.maskn = function maskn(bits) {
          return this.clone().imaskn(bits);
        };
        BN.prototype.iaddn = function iaddn(num) {
          assert(typeof num === "number");
          assert(num < 67108864);
          if (num < 0)
            return this.isubn(-num);
          if (this.negative !== 0) {
            if (this.length === 1 && (this.words[0] | 0) < num) {
              this.words[0] = num - (this.words[0] | 0);
              this.negative = 0;
              return this;
            }
            this.negative = 0;
            this.isubn(num);
            this.negative = 1;
            return this;
          }
          return this._iaddn(num);
        };
        BN.prototype._iaddn = function _iaddn(num) {
          this.words[0] += num;
          for (var i = 0; i < this.length && this.words[i] >= 67108864; i++) {
            this.words[i] -= 67108864;
            if (i === this.length - 1) {
              this.words[i + 1] = 1;
            } else {
              this.words[i + 1]++;
            }
          }
          this.length = Math.max(this.length, i + 1);
          return this;
        };
        BN.prototype.isubn = function isubn(num) {
          assert(typeof num === "number");
          assert(num < 67108864);
          if (num < 0)
            return this.iaddn(-num);
          if (this.negative !== 0) {
            this.negative = 0;
            this.iaddn(num);
            this.negative = 1;
            return this;
          }
          this.words[0] -= num;
          if (this.length === 1 && this.words[0] < 0) {
            this.words[0] = -this.words[0];
            this.negative = 1;
          } else {
            for (var i = 0; i < this.length && this.words[i] < 0; i++) {
              this.words[i] += 67108864;
              this.words[i + 1] -= 1;
            }
          }
          return this.strip();
        };
        BN.prototype.addn = function addn(num) {
          return this.clone().iaddn(num);
        };
        BN.prototype.subn = function subn(num) {
          return this.clone().isubn(num);
        };
        BN.prototype.iabs = function iabs() {
          this.negative = 0;
          return this;
        };
        BN.prototype.abs = function abs() {
          return this.clone().iabs();
        };
        BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
          var len = num.length + shift;
          var i;
          this._expand(len);
          var w;
          var carry = 0;
          for (i = 0; i < num.length; i++) {
            w = (this.words[i + shift] | 0) + carry;
            var right = (num.words[i] | 0) * mul;
            w -= right & 67108863;
            carry = (w >> 26) - (right / 67108864 | 0);
            this.words[i + shift] = w & 67108863;
          }
          for (; i < this.length - shift; i++) {
            w = (this.words[i + shift] | 0) + carry;
            carry = w >> 26;
            this.words[i + shift] = w & 67108863;
          }
          if (carry === 0)
            return this.strip();
          assert(carry === -1);
          carry = 0;
          for (i = 0; i < this.length; i++) {
            w = -(this.words[i] | 0) + carry;
            carry = w >> 26;
            this.words[i] = w & 67108863;
          }
          this.negative = 1;
          return this.strip();
        };
        BN.prototype._wordDiv = function _wordDiv(num, mode) {
          var shift = this.length - num.length;
          var a = this.clone();
          var b = num;
          var bhi = b.words[b.length - 1] | 0;
          var bhiBits = this._countBits(bhi);
          shift = 26 - bhiBits;
          if (shift !== 0) {
            b = b.ushln(shift);
            a.iushln(shift);
            bhi = b.words[b.length - 1] | 0;
          }
          var m = a.length - b.length;
          var q;
          if (mode !== "mod") {
            q = new BN(null);
            q.length = m + 1;
            q.words = new Array(q.length);
            for (var i = 0; i < q.length; i++) {
              q.words[i] = 0;
            }
          }
          var diff = a.clone()._ishlnsubmul(b, 1, m);
          if (diff.negative === 0) {
            a = diff;
            if (q) {
              q.words[m] = 1;
            }
          }
          for (var j = m - 1; j >= 0; j--) {
            var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
            qj = Math.min(qj / bhi | 0, 67108863);
            a._ishlnsubmul(b, qj, j);
            while (a.negative !== 0) {
              qj--;
              a.negative = 0;
              a._ishlnsubmul(b, 1, j);
              if (!a.isZero()) {
                a.negative ^= 1;
              }
            }
            if (q) {
              q.words[j] = qj;
            }
          }
          if (q) {
            q.strip();
          }
          a.strip();
          if (mode !== "div" && shift !== 0) {
            a.iushrn(shift);
          }
          return {
            div: q || null,
            mod: a
          };
        };
        BN.prototype.divmod = function divmod(num, mode, positive) {
          assert(!num.isZero());
          if (this.isZero()) {
            return {
              div: new BN(0),
              mod: new BN(0)
            };
          }
          var div, mod, res;
          if (this.negative !== 0 && num.negative === 0) {
            res = this.neg().divmod(num, mode);
            if (mode !== "mod") {
              div = res.div.neg();
            }
            if (mode !== "div") {
              mod = res.mod.neg();
              if (positive && mod.negative !== 0) {
                mod.iadd(num);
              }
            }
            return {
              div,
              mod
            };
          }
          if (this.negative === 0 && num.negative !== 0) {
            res = this.divmod(num.neg(), mode);
            if (mode !== "mod") {
              div = res.div.neg();
            }
            return {
              div,
              mod: res.mod
            };
          }
          if ((this.negative & num.negative) !== 0) {
            res = this.neg().divmod(num.neg(), mode);
            if (mode !== "div") {
              mod = res.mod.neg();
              if (positive && mod.negative !== 0) {
                mod.isub(num);
              }
            }
            return {
              div: res.div,
              mod
            };
          }
          if (num.length > this.length || this.cmp(num) < 0) {
            return {
              div: new BN(0),
              mod: this
            };
          }
          if (num.length === 1) {
            if (mode === "div") {
              return {
                div: this.divn(num.words[0]),
                mod: null
              };
            }
            if (mode === "mod") {
              return {
                div: null,
                mod: new BN(this.modn(num.words[0]))
              };
            }
            return {
              div: this.divn(num.words[0]),
              mod: new BN(this.modn(num.words[0]))
            };
          }
          return this._wordDiv(num, mode);
        };
        BN.prototype.div = function div(num) {
          return this.divmod(num, "div", false).div;
        };
        BN.prototype.mod = function mod(num) {
          return this.divmod(num, "mod", false).mod;
        };
        BN.prototype.umod = function umod(num) {
          return this.divmod(num, "mod", true).mod;
        };
        BN.prototype.divRound = function divRound(num) {
          var dm = this.divmod(num);
          if (dm.mod.isZero())
            return dm.div;
          var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
          var half = num.ushrn(1);
          var r2 = num.andln(1);
          var cmp = mod.cmp(half);
          if (cmp < 0 || r2 === 1 && cmp === 0)
            return dm.div;
          return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
        };
        BN.prototype.modn = function modn(num) {
          assert(num <= 67108863);
          var p = (1 << 26) % num;
          var acc = 0;
          for (var i = this.length - 1; i >= 0; i--) {
            acc = (p * acc + (this.words[i] | 0)) % num;
          }
          return acc;
        };
        BN.prototype.idivn = function idivn(num) {
          assert(num <= 67108863);
          var carry = 0;
          for (var i = this.length - 1; i >= 0; i--) {
            var w = (this.words[i] | 0) + carry * 67108864;
            this.words[i] = w / num | 0;
            carry = w % num;
          }
          return this.strip();
        };
        BN.prototype.divn = function divn(num) {
          return this.clone().idivn(num);
        };
        BN.prototype.egcd = function egcd(p) {
          assert(p.negative === 0);
          assert(!p.isZero());
          var x = this;
          var y = p.clone();
          if (x.negative !== 0) {
            x = x.umod(p);
          } else {
            x = x.clone();
          }
          var A = new BN(1);
          var B = new BN(0);
          var C = new BN(0);
          var D = new BN(1);
          var g = 0;
          while (x.isEven() && y.isEven()) {
            x.iushrn(1);
            y.iushrn(1);
            ++g;
          }
          var yp = y.clone();
          var xp = x.clone();
          while (!x.isZero()) {
            for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
              ;
            if (i > 0) {
              x.iushrn(i);
              while (i-- > 0) {
                if (A.isOdd() || B.isOdd()) {
                  A.iadd(yp);
                  B.isub(xp);
                }
                A.iushrn(1);
                B.iushrn(1);
              }
            }
            for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
              ;
            if (j > 0) {
              y.iushrn(j);
              while (j-- > 0) {
                if (C.isOdd() || D.isOdd()) {
                  C.iadd(yp);
                  D.isub(xp);
                }
                C.iushrn(1);
                D.iushrn(1);
              }
            }
            if (x.cmp(y) >= 0) {
              x.isub(y);
              A.isub(C);
              B.isub(D);
            } else {
              y.isub(x);
              C.isub(A);
              D.isub(B);
            }
          }
          return {
            a: C,
            b: D,
            gcd: y.iushln(g)
          };
        };
        BN.prototype._invmp = function _invmp(p) {
          assert(p.negative === 0);
          assert(!p.isZero());
          var a = this;
          var b = p.clone();
          if (a.negative !== 0) {
            a = a.umod(p);
          } else {
            a = a.clone();
          }
          var x1 = new BN(1);
          var x2 = new BN(0);
          var delta = b.clone();
          while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
            for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
              ;
            if (i > 0) {
              a.iushrn(i);
              while (i-- > 0) {
                if (x1.isOdd()) {
                  x1.iadd(delta);
                }
                x1.iushrn(1);
              }
            }
            for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
              ;
            if (j > 0) {
              b.iushrn(j);
              while (j-- > 0) {
                if (x2.isOdd()) {
                  x2.iadd(delta);
                }
                x2.iushrn(1);
              }
            }
            if (a.cmp(b) >= 0) {
              a.isub(b);
              x1.isub(x2);
            } else {
              b.isub(a);
              x2.isub(x1);
            }
          }
          var res;
          if (a.cmpn(1) === 0) {
            res = x1;
          } else {
            res = x2;
          }
          if (res.cmpn(0) < 0) {
            res.iadd(p);
          }
          return res;
        };
        BN.prototype.gcd = function gcd(num) {
          if (this.isZero())
            return num.abs();
          if (num.isZero())
            return this.abs();
          var a = this.clone();
          var b = num.clone();
          a.negative = 0;
          b.negative = 0;
          for (var shift = 0; a.isEven() && b.isEven(); shift++) {
            a.iushrn(1);
            b.iushrn(1);
          }
          do {
            while (a.isEven()) {
              a.iushrn(1);
            }
            while (b.isEven()) {
              b.iushrn(1);
            }
            var r = a.cmp(b);
            if (r < 0) {
              var t = a;
              a = b;
              b = t;
            } else if (r === 0 || b.cmpn(1) === 0) {
              break;
            }
            a.isub(b);
          } while (true);
          return b.iushln(shift);
        };
        BN.prototype.invm = function invm(num) {
          return this.egcd(num).a.umod(num);
        };
        BN.prototype.isEven = function isEven() {
          return (this.words[0] & 1) === 0;
        };
        BN.prototype.isOdd = function isOdd() {
          return (this.words[0] & 1) === 1;
        };
        BN.prototype.andln = function andln(num) {
          return this.words[0] & num;
        };
        BN.prototype.bincn = function bincn(bit) {
          assert(typeof bit === "number");
          var r = bit % 26;
          var s = (bit - r) / 26;
          var q = 1 << r;
          if (this.length <= s) {
            this._expand(s + 1);
            this.words[s] |= q;
            return this;
          }
          var carry = q;
          for (var i = s; carry !== 0 && i < this.length; i++) {
            var w = this.words[i] | 0;
            w += carry;
            carry = w >>> 26;
            w &= 67108863;
            this.words[i] = w;
          }
          if (carry !== 0) {
            this.words[i] = carry;
            this.length++;
          }
          return this;
        };
        BN.prototype.isZero = function isZero() {
          return this.length === 1 && this.words[0] === 0;
        };
        BN.prototype.cmpn = function cmpn(num) {
          var negative = num < 0;
          if (this.negative !== 0 && !negative)
            return -1;
          if (this.negative === 0 && negative)
            return 1;
          this.strip();
          var res;
          if (this.length > 1) {
            res = 1;
          } else {
            if (negative) {
              num = -num;
            }
            assert(num <= 67108863, "Number is too big");
            var w = this.words[0] | 0;
            res = w === num ? 0 : w < num ? -1 : 1;
          }
          if (this.negative !== 0)
            return -res | 0;
          return res;
        };
        BN.prototype.cmp = function cmp(num) {
          if (this.negative !== 0 && num.negative === 0)
            return -1;
          if (this.negative === 0 && num.negative !== 0)
            return 1;
          var res = this.ucmp(num);
          if (this.negative !== 0)
            return -res | 0;
          return res;
        };
        BN.prototype.ucmp = function ucmp(num) {
          if (this.length > num.length)
            return 1;
          if (this.length < num.length)
            return -1;
          var res = 0;
          for (var i = this.length - 1; i >= 0; i--) {
            var a = this.words[i] | 0;
            var b = num.words[i] | 0;
            if (a === b)
              continue;
            if (a < b) {
              res = -1;
            } else if (a > b) {
              res = 1;
            }
            break;
          }
          return res;
        };
        BN.prototype.gtn = function gtn(num) {
          return this.cmpn(num) === 1;
        };
        BN.prototype.gt = function gt(num) {
          return this.cmp(num) === 1;
        };
        BN.prototype.gten = function gten(num) {
          return this.cmpn(num) >= 0;
        };
        BN.prototype.gte = function gte(num) {
          return this.cmp(num) >= 0;
        };
        BN.prototype.ltn = function ltn(num) {
          return this.cmpn(num) === -1;
        };
        BN.prototype.lt = function lt(num) {
          return this.cmp(num) === -1;
        };
        BN.prototype.lten = function lten(num) {
          return this.cmpn(num) <= 0;
        };
        BN.prototype.lte = function lte(num) {
          return this.cmp(num) <= 0;
        };
        BN.prototype.eqn = function eqn(num) {
          return this.cmpn(num) === 0;
        };
        BN.prototype.eq = function eq(num) {
          return this.cmp(num) === 0;
        };
        BN.red = function red(num) {
          return new Red(num);
        };
        BN.prototype.toRed = function toRed(ctx) {
          assert(!this.red, "Already a number in reduction context");
          assert(this.negative === 0, "red works only with positives");
          return ctx.convertTo(this)._forceRed(ctx);
        };
        BN.prototype.fromRed = function fromRed() {
          assert(this.red, "fromRed works only with numbers in reduction context");
          return this.red.convertFrom(this);
        };
        BN.prototype._forceRed = function _forceRed(ctx) {
          this.red = ctx;
          return this;
        };
        BN.prototype.forceRed = function forceRed(ctx) {
          assert(!this.red, "Already a number in reduction context");
          return this._forceRed(ctx);
        };
        BN.prototype.redAdd = function redAdd(num) {
          assert(this.red, "redAdd works only with red numbers");
          return this.red.add(this, num);
        };
        BN.prototype.redIAdd = function redIAdd(num) {
          assert(this.red, "redIAdd works only with red numbers");
          return this.red.iadd(this, num);
        };
        BN.prototype.redSub = function redSub(num) {
          assert(this.red, "redSub works only with red numbers");
          return this.red.sub(this, num);
        };
        BN.prototype.redISub = function redISub(num) {
          assert(this.red, "redISub works only with red numbers");
          return this.red.isub(this, num);
        };
        BN.prototype.redShl = function redShl(num) {
          assert(this.red, "redShl works only with red numbers");
          return this.red.shl(this, num);
        };
        BN.prototype.redMul = function redMul(num) {
          assert(this.red, "redMul works only with red numbers");
          this.red._verify2(this, num);
          return this.red.mul(this, num);
        };
        BN.prototype.redIMul = function redIMul(num) {
          assert(this.red, "redMul works only with red numbers");
          this.red._verify2(this, num);
          return this.red.imul(this, num);
        };
        BN.prototype.redSqr = function redSqr() {
          assert(this.red, "redSqr works only with red numbers");
          this.red._verify1(this);
          return this.red.sqr(this);
        };
        BN.prototype.redISqr = function redISqr() {
          assert(this.red, "redISqr works only with red numbers");
          this.red._verify1(this);
          return this.red.isqr(this);
        };
        BN.prototype.redSqrt = function redSqrt() {
          assert(this.red, "redSqrt works only with red numbers");
          this.red._verify1(this);
          return this.red.sqrt(this);
        };
        BN.prototype.redInvm = function redInvm() {
          assert(this.red, "redInvm works only with red numbers");
          this.red._verify1(this);
          return this.red.invm(this);
        };
        BN.prototype.redNeg = function redNeg() {
          assert(this.red, "redNeg works only with red numbers");
          this.red._verify1(this);
          return this.red.neg(this);
        };
        BN.prototype.redPow = function redPow(num) {
          assert(this.red && !num.red, "redPow(normalNum)");
          this.red._verify1(this);
          return this.red.pow(this, num);
        };
        var primes = {
          k256: null,
          p224: null,
          p192: null,
          p25519: null
        };
        function MPrime(name, p) {
          this.name = name;
          this.p = new BN(p, 16);
          this.n = this.p.bitLength();
          this.k = new BN(1).iushln(this.n).isub(this.p);
          this.tmp = this._tmp();
        }
        MPrime.prototype._tmp = function _tmp() {
          var tmp = new BN(null);
          tmp.words = new Array(Math.ceil(this.n / 13));
          return tmp;
        };
        MPrime.prototype.ireduce = function ireduce(num) {
          var r = num;
          var rlen;
          do {
            this.split(r, this.tmp);
            r = this.imulK(r);
            r = r.iadd(this.tmp);
            rlen = r.bitLength();
          } while (rlen > this.n);
          var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
          if (cmp === 0) {
            r.words[0] = 0;
            r.length = 1;
          } else if (cmp > 0) {
            r.isub(this.p);
          } else {
            if (r.strip !== void 0) {
              r.strip();
            } else {
              r._strip();
            }
          }
          return r;
        };
        MPrime.prototype.split = function split(input, out) {
          input.iushrn(this.n, 0, out);
        };
        MPrime.prototype.imulK = function imulK(num) {
          return num.imul(this.k);
        };
        function K256() {
          MPrime.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
        }
        inherits(K256, MPrime);
        K256.prototype.split = function split(input, output) {
          var mask = 4194303;
          var outLen = Math.min(input.length, 9);
          for (var i = 0; i < outLen; i++) {
            output.words[i] = input.words[i];
          }
          output.length = outLen;
          if (input.length <= 9) {
            input.words[0] = 0;
            input.length = 1;
            return;
          }
          var prev = input.words[9];
          output.words[output.length++] = prev & mask;
          for (i = 10; i < input.length; i++) {
            var next = input.words[i] | 0;
            input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
            prev = next;
          }
          prev >>>= 22;
          input.words[i - 10] = prev;
          if (prev === 0 && input.length > 10) {
            input.length -= 10;
          } else {
            input.length -= 9;
          }
        };
        K256.prototype.imulK = function imulK(num) {
          num.words[num.length] = 0;
          num.words[num.length + 1] = 0;
          num.length += 2;
          var lo = 0;
          for (var i = 0; i < num.length; i++) {
            var w = num.words[i] | 0;
            lo += w * 977;
            num.words[i] = lo & 67108863;
            lo = w * 64 + (lo / 67108864 | 0);
          }
          if (num.words[num.length - 1] === 0) {
            num.length--;
            if (num.words[num.length - 1] === 0) {
              num.length--;
            }
          }
          return num;
        };
        function P224() {
          MPrime.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
        }
        inherits(P224, MPrime);
        function P192() {
          MPrime.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
        }
        inherits(P192, MPrime);
        function P25519() {
          MPrime.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
        }
        inherits(P25519, MPrime);
        P25519.prototype.imulK = function imulK(num) {
          var carry = 0;
          for (var i = 0; i < num.length; i++) {
            var hi = (num.words[i] | 0) * 19 + carry;
            var lo = hi & 67108863;
            hi >>>= 26;
            num.words[i] = lo;
            carry = hi;
          }
          if (carry !== 0) {
            num.words[num.length++] = carry;
          }
          return num;
        };
        BN._prime = function prime(name) {
          if (primes[name])
            return primes[name];
          var prime2;
          if (name === "k256") {
            prime2 = new K256();
          } else if (name === "p224") {
            prime2 = new P224();
          } else if (name === "p192") {
            prime2 = new P192();
          } else if (name === "p25519") {
            prime2 = new P25519();
          } else {
            throw new Error("Unknown prime " + name);
          }
          primes[name] = prime2;
          return prime2;
        };
        function Red(m) {
          if (typeof m === "string") {
            var prime = BN._prime(m);
            this.m = prime.p;
            this.prime = prime;
          } else {
            assert(m.gtn(1), "modulus must be greater than 1");
            this.m = m;
            this.prime = null;
          }
        }
        Red.prototype._verify1 = function _verify1(a) {
          assert(a.negative === 0, "red works only with positives");
          assert(a.red, "red works only with red numbers");
        };
        Red.prototype._verify2 = function _verify2(a, b) {
          assert((a.negative | b.negative) === 0, "red works only with positives");
          assert(a.red && a.red === b.red, "red works only with red numbers");
        };
        Red.prototype.imod = function imod(a) {
          if (this.prime)
            return this.prime.ireduce(a)._forceRed(this);
          return a.umod(this.m)._forceRed(this);
        };
        Red.prototype.neg = function neg(a) {
          if (a.isZero()) {
            return a.clone();
          }
          return this.m.sub(a)._forceRed(this);
        };
        Red.prototype.add = function add(a, b) {
          this._verify2(a, b);
          var res = a.add(b);
          if (res.cmp(this.m) >= 0) {
            res.isub(this.m);
          }
          return res._forceRed(this);
        };
        Red.prototype.iadd = function iadd(a, b) {
          this._verify2(a, b);
          var res = a.iadd(b);
          if (res.cmp(this.m) >= 0) {
            res.isub(this.m);
          }
          return res;
        };
        Red.prototype.sub = function sub(a, b) {
          this._verify2(a, b);
          var res = a.sub(b);
          if (res.cmpn(0) < 0) {
            res.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Red.prototype.isub = function isub(a, b) {
          this._verify2(a, b);
          var res = a.isub(b);
          if (res.cmpn(0) < 0) {
            res.iadd(this.m);
          }
          return res;
        };
        Red.prototype.shl = function shl(a, num) {
          this._verify1(a);
          return this.imod(a.ushln(num));
        };
        Red.prototype.imul = function imul(a, b) {
          this._verify2(a, b);
          return this.imod(a.imul(b));
        };
        Red.prototype.mul = function mul(a, b) {
          this._verify2(a, b);
          return this.imod(a.mul(b));
        };
        Red.prototype.isqr = function isqr(a) {
          return this.imul(a, a.clone());
        };
        Red.prototype.sqr = function sqr(a) {
          return this.mul(a, a);
        };
        Red.prototype.sqrt = function sqrt(a) {
          if (a.isZero())
            return a.clone();
          var mod3 = this.m.andln(3);
          assert(mod3 % 2 === 1);
          if (mod3 === 3) {
            var pow = this.m.add(new BN(1)).iushrn(2);
            return this.pow(a, pow);
          }
          var q = this.m.subn(1);
          var s = 0;
          while (!q.isZero() && q.andln(1) === 0) {
            s++;
            q.iushrn(1);
          }
          assert(!q.isZero());
          var one = new BN(1).toRed(this);
          var nOne = one.redNeg();
          var lpow = this.m.subn(1).iushrn(1);
          var z = this.m.bitLength();
          z = new BN(2 * z * z).toRed(this);
          while (this.pow(z, lpow).cmp(nOne) !== 0) {
            z.redIAdd(nOne);
          }
          var c = this.pow(z, q);
          var r = this.pow(a, q.addn(1).iushrn(1));
          var t = this.pow(a, q);
          var m = s;
          while (t.cmp(one) !== 0) {
            var tmp = t;
            for (var i = 0; tmp.cmp(one) !== 0; i++) {
              tmp = tmp.redSqr();
            }
            assert(i < m);
            var b = this.pow(c, new BN(1).iushln(m - i - 1));
            r = r.redMul(b);
            c = b.redSqr();
            t = t.redMul(c);
            m = i;
          }
          return r;
        };
        Red.prototype.invm = function invm(a) {
          var inv = a._invmp(this.m);
          if (inv.negative !== 0) {
            inv.negative = 0;
            return this.imod(inv).redNeg();
          } else {
            return this.imod(inv);
          }
        };
        Red.prototype.pow = function pow(a, num) {
          if (num.isZero())
            return new BN(1).toRed(this);
          if (num.cmpn(1) === 0)
            return a.clone();
          var windowSize = 4;
          var wnd = new Array(1 << windowSize);
          wnd[0] = new BN(1).toRed(this);
          wnd[1] = a;
          for (var i = 2; i < wnd.length; i++) {
            wnd[i] = this.mul(wnd[i - 1], a);
          }
          var res = wnd[0];
          var current = 0;
          var currentLen = 0;
          var start = num.bitLength() % 26;
          if (start === 0) {
            start = 26;
          }
          for (i = num.length - 1; i >= 0; i--) {
            var word = num.words[i];
            for (var j = start - 1; j >= 0; j--) {
              var bit = word >> j & 1;
              if (res !== wnd[0]) {
                res = this.sqr(res);
              }
              if (bit === 0 && current === 0) {
                currentLen = 0;
                continue;
              }
              current <<= 1;
              current |= bit;
              currentLen++;
              if (currentLen !== windowSize && (i !== 0 || j !== 0))
                continue;
              res = this.mul(res, wnd[current]);
              currentLen = 0;
              current = 0;
            }
            start = 26;
          }
          return res;
        };
        Red.prototype.convertTo = function convertTo(num) {
          var r = num.umod(this.m);
          return r === num ? r.clone() : r;
        };
        Red.prototype.convertFrom = function convertFrom(num) {
          var res = num.clone();
          res.red = null;
          return res;
        };
        BN.mont = function mont(num) {
          return new Mont(num);
        };
        function Mont(m) {
          Red.call(this, m);
          this.shift = this.m.bitLength();
          if (this.shift % 26 !== 0) {
            this.shift += 26 - this.shift % 26;
          }
          this.r = new BN(1).iushln(this.shift);
          this.r2 = this.imod(this.r.sqr());
          this.rinv = this.r._invmp(this.m);
          this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
          this.minv = this.minv.umod(this.r);
          this.minv = this.r.sub(this.minv);
        }
        inherits(Mont, Red);
        Mont.prototype.convertTo = function convertTo(num) {
          return this.imod(num.ushln(this.shift));
        };
        Mont.prototype.convertFrom = function convertFrom(num) {
          var r = this.imod(num.mul(this.rinv));
          r.red = null;
          return r;
        };
        Mont.prototype.imul = function imul(a, b) {
          if (a.isZero() || b.isZero()) {
            a.words[0] = 0;
            a.length = 1;
            return a;
          }
          var t = a.imul(b);
          var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
          var u = t.isub(c).iushrn(this.shift);
          var res = u;
          if (u.cmp(this.m) >= 0) {
            res = u.isub(this.m);
          } else if (u.cmpn(0) < 0) {
            res = u.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Mont.prototype.mul = function mul(a, b) {
          if (a.isZero() || b.isZero())
            return new BN(0)._forceRed(this);
          var t = a.mul(b);
          var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
          var u = t.isub(c).iushrn(this.shift);
          var res = u;
          if (u.cmp(this.m) >= 0) {
            res = u.isub(this.m);
          } else if (u.cmpn(0) < 0) {
            res = u.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Mont.prototype.invm = function invm(a) {
          var res = this.imod(a._invmp(this.m).mul(this.r2));
          return res._forceRed(this);
        };
      })(typeof module2 === "undefined" || module2, exports);
    }
  });

  // node_modules/safe-buffer/index.js
  var require_safe_buffer = __commonJS({
    "node_modules/safe-buffer/index.js"(exports, module2) {
      var buffer = require_buffer();
      var Buffer3 = buffer.Buffer;
      function copyProps(src, dst) {
        for (var key in src) {
          dst[key] = src[key];
        }
      }
      if (Buffer3.from && Buffer3.alloc && Buffer3.allocUnsafe && Buffer3.allocUnsafeSlow) {
        module2.exports = buffer;
      } else {
        copyProps(buffer, exports);
        exports.Buffer = SafeBuffer;
      }
      function SafeBuffer(arg, encodingOrOffset, length) {
        return Buffer3(arg, encodingOrOffset, length);
      }
      SafeBuffer.prototype = Object.create(Buffer3.prototype);
      copyProps(Buffer3, SafeBuffer);
      SafeBuffer.from = function(arg, encodingOrOffset, length) {
        if (typeof arg === "number") {
          throw new TypeError("Argument must not be a number");
        }
        return Buffer3(arg, encodingOrOffset, length);
      };
      SafeBuffer.alloc = function(size, fill, encoding) {
        if (typeof size !== "number") {
          throw new TypeError("Argument must be a number");
        }
        var buf = Buffer3(size);
        if (fill !== void 0) {
          if (typeof encoding === "string") {
            buf.fill(fill, encoding);
          } else {
            buf.fill(fill);
          }
        } else {
          buf.fill(0);
        }
        return buf;
      };
      SafeBuffer.allocUnsafe = function(size) {
        if (typeof size !== "number") {
          throw new TypeError("Argument must be a number");
        }
        return Buffer3(size);
      };
      SafeBuffer.allocUnsafeSlow = function(size) {
        if (typeof size !== "number") {
          throw new TypeError("Argument must be a number");
        }
        return buffer.SlowBuffer(size);
      };
    }
  });

  // node_modules/buffer-pipe/index.js
  var require_buffer_pipe = __commonJS({
    "node_modules/buffer-pipe/index.js"(exports, module2) {
      var Buffer3 = require_safe_buffer().Buffer;
      module2.exports = class BufferPipe {
        constructor(buf = Buffer3.from([])) {
          this.buffer = buf;
        }
        read(num) {
          const data = this.buffer.subarray(0, num);
          this.buffer = this.buffer.subarray(num);
          return data;
        }
        write(buf) {
          buf = Buffer3.from(buf);
          this.buffer = Buffer3.concat([this.buffer, buf]);
        }
      };
    }
  });

  // node_modules/leb128/unsigned.js
  var require_unsigned = __commonJS({
    "node_modules/leb128/unsigned.js"(exports, module2) {
      var Bn = require_bn();
      var Pipe = require_buffer_pipe();
      module2.exports = {
        encode,
        decode,
        read,
        readBn,
        write
      };
      function read(stream) {
        return readBn(stream).toString();
      }
      function readBn(stream) {
        const num = new Bn(0);
        let shift = 0;
        let byt;
        while (true) {
          byt = stream.read(1)[0];
          num.ior(new Bn(byt & 127).shln(shift));
          if (byt >> 7 === 0) {
            break;
          } else {
            shift += 7;
          }
        }
        return num;
      }
      function write(number, stream) {
        const num = new Bn(number);
        while (true) {
          const i = num.maskn(7).toNumber();
          num.ishrn(7);
          if (num.isZero()) {
            stream.write([i]);
            break;
          } else {
            stream.write([i | 128]);
          }
        }
      }
      function encode(num) {
        const stream = new Pipe();
        write(num, stream);
        return stream.buffer;
      }
      function decode(buffer) {
        const stream = new Pipe(buffer);
        return read(stream);
      }
    }
  });

  // node_modules/leb128/signed.js
  var require_signed = __commonJS({
    "node_modules/leb128/signed.js"(exports, module2) {
      var Bn = require_bn();
      var Pipe = require_buffer_pipe();
      module2.exports = {
        encode,
        decode,
        write,
        read,
        readBn
      };
      function read(stream) {
        return readBn(stream).toString();
      }
      function readBn(stream) {
        const num = new Bn(0);
        let shift = 0;
        let byt;
        while (true) {
          byt = stream.read(1)[0];
          num.ior(new Bn(byt & 127).shln(shift));
          shift += 7;
          if (byt >> 7 === 0) {
            break;
          }
        }
        if (byt & 64) {
          num.setn(shift);
        }
        return num.fromTwos(shift);
      }
      function write(number, stream) {
        let num = new Bn(number);
        const isNeg = num.isNeg();
        if (isNeg) {
          num = num.toTwos(num.bitLength() + 8);
        }
        while (true) {
          const i = num.maskn(7).toNumber();
          num.ishrn(7);
          if (isNegOne(num) && (i & 64) !== 0 || num.isZero() && (i & 64) === 0) {
            stream.write([i]);
            break;
          } else {
            stream.write([i | 128]);
          }
        }
        function isNegOne(num2) {
          return isNeg && num2.toString(2).indexOf("0") < 0;
        }
      }
      function encode(num) {
        const stream = new Pipe();
        write(num, stream);
        return stream.buffer;
      }
      function decode(buffer) {
        const stream = new Pipe(buffer);
        return read(stream);
      }
    }
  });

  // node_modules/leb128/index.js
  var require_leb128 = __commonJS({
    "node_modules/leb128/index.js"(exports) {
      exports.unsigned = require_unsigned();
      exports.signed = require_signed();
    }
  });

  // node_modules/redstone-wasm-json-toolkit/node_modules/buffer-pipe/index.js
  var require_buffer_pipe2 = __commonJS({
    "node_modules/redstone-wasm-json-toolkit/node_modules/buffer-pipe/index.js"(exports, module2) {
      var Buffer3 = require_safe_buffer().Buffer;
      module2.exports = class BufferPipe {
        constructor(buf = Buffer3.from([])) {
          this.buffer = buf;
          this._bytesRead = 0;
          this._bytesWrote = 0;
        }
        read(num) {
          this._bytesRead += num;
          const data = this.buffer.slice(0, num);
          this.buffer = this.buffer.slice(num);
          return data;
        }
        write(buf) {
          buf = Buffer3.from(buf);
          this._bytesWrote += buf.length;
          this.buffer = Buffer3.concat([this.buffer, buf]);
        }
        get end() {
          return !this.buffer.length;
        }
        get bytesRead() {
          return this._bytesRead;
        }
        get bytesWrote() {
          return this._bytesWrote;
        }
      };
    }
  });

  // node_modules/redstone-wasm-json-toolkit/immediates.json
  var require_immediates = __commonJS({
    "node_modules/redstone-wasm-json-toolkit/immediates.json"(exports, module2) {
      module2.exports = {
        block: "block_type",
        loop: "block_type",
        if: "block_type",
        br: "varuint32",
        br_if: "varuint32",
        br_table: "br_table",
        call: "varuint32",
        call_indirect: "call_indirect",
        get_local: "varuint32",
        set_local: "varuint32",
        tee_local: "varuint32",
        get_global: "varuint32",
        set_global: "varuint32",
        load: "memory_immediate",
        load8_s: "memory_immediate",
        load8_u: "memory_immediate",
        load16_s: "memory_immediate",
        load16_u: "memory_immediate",
        load32_s: "memory_immediate",
        load32_u: "memory_immediate",
        store: "memory_immediate",
        store8: "memory_immediate",
        store16: "memory_immediate",
        store32: "memory_immediate",
        current_memory: "varuint1",
        grow_memory: "varuint1",
        i32: "varint32",
        i64: "varint64",
        f32: "uint32",
        f64: "uint64"
      };
    }
  });

  // node_modules/redstone-wasm-json-toolkit/wasm2json.js
  var require_wasm2json = __commonJS({
    "node_modules/redstone-wasm-json-toolkit/wasm2json.js"(exports, module2) {
      var leb = require_leb128();
      var Stream = require_buffer_pipe2();
      var OP_IMMEDIATES = require_immediates();
      var _exports = module2.exports = (buf, filter) => {
        const stream = new Stream(buf);
        return _exports.parse(stream, filter);
      };
      var LANGUAGE_TYPES = _exports.LANGUAGE_TYPES = {
        127: "i32",
        126: "i64",
        125: "f32",
        124: "f64",
        112: "anyFunc",
        96: "func",
        64: "block_type"
      };
      var EXTERNAL_KIND = _exports.EXTERNAL_KIND = {
        0: "function",
        1: "table",
        2: "memory",
        3: "global"
      };
      _exports.parsePreramble = (stream) => {
        const obj = {};
        obj.name = "preramble";
        obj.magic = [...stream.read(4)];
        obj.version = [...stream.read(4)];
        return obj;
      };
      _exports.parseSectionHeader = (stream) => {
        const id = stream.read(1)[0];
        const size = leb.unsigned.readBn(stream).toNumber();
        return {
          id,
          name: SECTION_IDS[id],
          size
        };
      };
      var OPCODES = _exports.OPCODES = {
        0: "unreachable",
        1: "nop",
        2: "block",
        3: "loop",
        4: "if",
        5: "else",
        11: "end",
        12: "br",
        13: "br_if",
        14: "br_table",
        15: "return",
        16: "call",
        17: "call_indirect",
        26: "drop",
        27: "select",
        32: "get_local",
        33: "set_local",
        34: "tee_local",
        35: "get_global",
        36: "set_global",
        40: "i32.load",
        41: "i64.load",
        42: "f32.load",
        43: "f64.load",
        44: "i32.load8_s",
        45: "i32.load8_u",
        46: "i32.load16_s",
        47: "i32.load16_u",
        48: "i64.load8_s",
        49: "i64.load8_u",
        50: "i64.load16_s",
        51: "i64.load16_u",
        52: "i64.load32_s",
        53: "i64.load32_u",
        54: "i32.store",
        55: "i64.store",
        56: "f32.store",
        57: "f64.store",
        58: "i32.store8",
        59: "i32.store16",
        60: "i64.store8",
        61: "i64.store16",
        62: "i64.store32",
        63: "current_memory",
        64: "grow_memory",
        65: "i32.const",
        66: "i64.const",
        67: "f32.const",
        68: "f64.const",
        69: "i32.eqz",
        70: "i32.eq",
        71: "i32.ne",
        72: "i32.lt_s",
        73: "i32.lt_u",
        74: "i32.gt_s",
        75: "i32.gt_u",
        76: "i32.le_s",
        77: "i32.le_u",
        78: "i32.ge_s",
        79: "i32.ge_u",
        80: "i64.eqz",
        81: "i64.eq",
        82: "i64.ne",
        83: "i64.lt_s",
        84: "i64.lt_u",
        85: "i64.gt_s",
        86: "i64.gt_u",
        87: "i64.le_s",
        88: "i64.le_u",
        89: "i64.ge_s",
        90: "i64.ge_u",
        91: "f32.eq",
        92: "f32.ne",
        93: "f32.lt",
        94: "f32.gt",
        95: "f32.le",
        96: "f32.ge",
        97: "f64.eq",
        98: "f64.ne",
        99: "f64.lt",
        100: "f64.gt",
        101: "f64.le",
        102: "f64.ge",
        103: "i32.clz",
        104: "i32.ctz",
        105: "i32.popcnt",
        106: "i32.add",
        107: "i32.sub",
        108: "i32.mul",
        109: "i32.div_s",
        110: "i32.div_u",
        111: "i32.rem_s",
        112: "i32.rem_u",
        113: "i32.and",
        114: "i32.or",
        115: "i32.xor",
        116: "i32.shl",
        117: "i32.shr_s",
        118: "i32.shr_u",
        119: "i32.rotl",
        120: "i32.rotr",
        121: "i64.clz",
        122: "i64.ctz",
        123: "i64.popcnt",
        124: "i64.add",
        125: "i64.sub",
        126: "i64.mul",
        127: "i64.div_s",
        128: "i64.div_u",
        129: "i64.rem_s",
        130: "i64.rem_u",
        131: "i64.and",
        132: "i64.or",
        133: "i64.xor",
        134: "i64.shl",
        135: "i64.shr_s",
        136: "i64.shr_u",
        137: "i64.rotl",
        138: "i64.rotr",
        139: "f32.abs",
        140: "f32.neg",
        141: "f32.ceil",
        142: "f32.floor",
        143: "f32.trunc",
        144: "f32.nearest",
        145: "f32.sqrt",
        146: "f32.add",
        147: "f32.sub",
        148: "f32.mul",
        149: "f32.div",
        150: "f32.min",
        151: "f32.max",
        152: "f32.copysign",
        153: "f64.abs",
        154: "f64.neg",
        155: "f64.ceil",
        156: "f64.floor",
        157: "f64.trunc",
        158: "f64.nearest",
        159: "f64.sqrt",
        160: "f64.add",
        161: "f64.sub",
        162: "f64.mul",
        163: "f64.div",
        164: "f64.min",
        165: "f64.max",
        166: "f64.copysign",
        167: "i32.wrap/i64",
        168: "i32.trunc_s/f32",
        169: "i32.trunc_u/f32",
        170: "i32.trunc_s/f64",
        171: "i32.trunc_u/f64",
        172: "i64.extend_s/i32",
        173: "i64.extend_u/i32",
        174: "i64.trunc_s/f32",
        175: "i64.trunc_u/f32",
        176: "i64.trunc_s/f64",
        177: "i64.trunc_u/f64",
        178: "f32.convert_s/i32",
        179: "f32.convert_u/i32",
        180: "f32.convert_s/i64",
        181: "f32.convert_u/i64",
        182: "f32.demote/f64",
        183: "f64.convert_s/i32",
        184: "f64.convert_u/i32",
        185: "f64.convert_s/i64",
        186: "f64.convert_u/i64",
        187: "f64.promote/f32",
        188: "i32.reinterpret/f32",
        189: "i64.reinterpret/f64",
        190: "f32.reinterpret/i32",
        191: "f64.reinterpret/i64"
      };
      var SECTION_IDS = _exports.SECTION_IDS = {
        0: "custom",
        1: "type",
        2: "import",
        3: "function",
        4: "table",
        5: "memory",
        6: "global",
        7: "export",
        8: "start",
        9: "element",
        10: "code",
        11: "data"
      };
      _exports.immediataryParsers = {
        "varuint1": (stream) => {
          const int1 = stream.read(1)[0];
          return int1;
        },
        "varuint32": (stream) => {
          const int32 = leb.unsigned.read(stream);
          return int32;
        },
        "varint32": (stream) => {
          const int32 = leb.signed.read(stream);
          return int32;
        },
        "varint64": (stream) => {
          const int64 = leb.signed.read(stream);
          return int64;
        },
        "uint32": (stream) => {
          return [...stream.read(4)];
        },
        "uint64": (stream) => {
          return [...stream.read(8)];
        },
        "block_type": (stream) => {
          const type = stream.read(1)[0];
          return LANGUAGE_TYPES[type];
        },
        "br_table": (stream) => {
          const json = {
            targets: []
          };
          const num = leb.unsigned.readBn(stream).toNumber();
          for (let i = 0; i < num; i++) {
            const target = leb.unsigned.readBn(stream).toNumber();
            json.targets.push(target);
          }
          json.defaultTarget = leb.unsigned.readBn(stream).toNumber();
          return json;
        },
        "call_indirect": (stream) => {
          const json = {};
          json.index = leb.unsigned.readBn(stream).toNumber();
          json.reserved = stream.read(1)[0];
          return json;
        },
        "memory_immediate": (stream) => {
          const json = {};
          json.flags = leb.unsigned.readBn(stream).toNumber();
          json.offset = leb.unsigned.readBn(stream).toNumber();
          return json;
        }
      };
      _exports.typeParsers = {
        "function": (stream) => {
          return leb.unsigned.readBn(stream).toNumber();
        },
        table: (stream) => {
          const entry = {};
          const type = stream.read(1)[0];
          entry.elementType = LANGUAGE_TYPES[type];
          entry.limits = _exports.typeParsers.memory(stream);
          return entry;
        },
        global: (stream) => {
          const global2 = {};
          let type = stream.read(1)[0];
          global2.contentType = LANGUAGE_TYPES[type];
          global2.mutability = stream.read(1)[0];
          return global2;
        },
        memory: (stream) => {
          const limits = {};
          limits.flags = leb.unsigned.readBn(stream).toNumber();
          limits.intial = leb.unsigned.readBn(stream).toNumber();
          if (limits.flags === 1) {
            limits.maximum = leb.unsigned.readBn(stream).toNumber();
          }
          return limits;
        },
        initExpr: (stream) => {
          const op = _exports.parseOp(stream);
          stream.read(1);
          return op;
        }
      };
      var sectionParsers = _exports.sectionParsers = {
        "custom": (stream, header) => {
          const json = {
            name: "custom"
          };
          const section = new Stream(stream.read(header.size));
          const nameLen = leb.unsigned.readBn(section).toNumber();
          const name = section.read(nameLen);
          json.sectionName = Buffer.from(name).toString();
          json.payload = [...section.buffer];
          return json;
        },
        "type": (stream) => {
          const numberOfEntries = leb.unsigned.readBn(stream).toNumber();
          const json = {
            name: "type",
            entries: []
          };
          for (let i = 0; i < numberOfEntries; i++) {
            let type = stream.read(1)[0];
            const entry = {
              form: LANGUAGE_TYPES[type],
              params: []
            };
            const paramCount = leb.unsigned.readBn(stream).toNumber();
            for (let q = 0; q < paramCount; q++) {
              const type2 = stream.read(1)[0];
              entry.params.push(LANGUAGE_TYPES[type2]);
            }
            const numOfReturns = leb.unsigned.readBn(stream).toNumber();
            if (numOfReturns) {
              type = stream.read(1)[0];
              entry.return_type = LANGUAGE_TYPES[type];
            }
            json.entries.push(entry);
          }
          return json;
        },
        "import": (stream) => {
          const numberOfEntries = leb.unsigned.readBn(stream).toNumber();
          const json = {
            name: "import",
            entries: []
          };
          for (let i = 0; i < numberOfEntries; i++) {
            const entry = {};
            const moduleLen = leb.unsigned.readBn(stream).toNumber();
            entry.moduleStr = Buffer.from(stream.read(moduleLen)).toString();
            const fieldLen = leb.unsigned.readBn(stream).toNumber();
            entry.fieldStr = Buffer.from(stream.read(fieldLen)).toString();
            const kind = stream.read(1)[0];
            entry.kind = EXTERNAL_KIND[kind];
            entry.type = _exports.typeParsers[entry.kind](stream);
            json.entries.push(entry);
          }
          return json;
        },
        "function": (stream) => {
          const numberOfEntries = leb.unsigned.readBn(stream).toNumber();
          const json = {
            name: "function",
            entries: []
          };
          for (let i = 0; i < numberOfEntries; i++) {
            const entry = leb.unsigned.readBn(stream).toNumber();
            json.entries.push(entry);
          }
          return json;
        },
        "table": (stream) => {
          const numberOfEntries = leb.unsigned.readBn(stream).toNumber();
          const json = {
            name: "table",
            entries: []
          };
          for (let i = 0; i < numberOfEntries; i++) {
            const entry = _exports.typeParsers.table(stream);
            json.entries.push(entry);
          }
          return json;
        },
        "memory": (stream) => {
          const numberOfEntries = leb.unsigned.readBn(stream).toNumber();
          const json = {
            name: "memory",
            entries: []
          };
          for (let i = 0; i < numberOfEntries; i++) {
            const entry = _exports.typeParsers.memory(stream);
            json.entries.push(entry);
          }
          return json;
        },
        "global": (stream) => {
          const numberOfEntries = leb.unsigned.readBn(stream).toNumber();
          const json = {
            name: "global",
            entries: []
          };
          for (let i = 0; i < numberOfEntries; i++) {
            const entry = {};
            entry.type = _exports.typeParsers.global(stream);
            entry.init = _exports.typeParsers.initExpr(stream);
            json.entries.push(entry);
          }
          return json;
        },
        "export": (stream) => {
          const numberOfEntries = leb.unsigned.readBn(stream).toNumber();
          const json = {
            name: "export",
            entries: []
          };
          for (let i = 0; i < numberOfEntries; i++) {
            const strLength = leb.unsigned.readBn(stream).toNumber();
            const entry = {};
            entry.field_str = Buffer.from(stream.read(strLength)).toString();
            const kind = stream.read(1)[0];
            entry.kind = EXTERNAL_KIND[kind];
            entry.index = leb.unsigned.readBn(stream).toNumber();
            json.entries.push(entry);
          }
          return json;
        },
        "start": (stream) => {
          const json = {
            name: "start"
          };
          json.index = leb.unsigned.readBn(stream).toNumber();
          return json;
        },
        "element": (stream) => {
          const numberOfEntries = leb.unsigned.readBn(stream).toNumber();
          const json = {
            name: "element",
            entries: []
          };
          for (let i = 0; i < numberOfEntries; i++) {
            const entry = {
              elements: []
            };
            entry.index = leb.unsigned.readBn(stream).toNumber();
            entry.offset = _exports.typeParsers.initExpr(stream);
            const numElem = leb.unsigned.readBn(stream).toNumber();
            for (let i2 = 0; i2 < numElem; i2++) {
              const elem = leb.unsigned.readBn(stream).toNumber();
              entry.elements.push(elem);
            }
            json.entries.push(entry);
          }
          return json;
        },
        "code": (stream) => {
          const numberOfEntries = leb.unsigned.readBn(stream).toNumber();
          const json = {
            name: "code",
            entries: []
          };
          for (let i = 0; i < numberOfEntries; i++) {
            const codeBody = {
              locals: [],
              code: []
            };
            let bodySize = leb.unsigned.readBn(stream).toNumber();
            const endBytes = stream.bytesRead + bodySize;
            const localCount = leb.unsigned.readBn(stream).toNumber();
            for (let q = 0; q < localCount; q++) {
              const local = {};
              local.count = leb.unsigned.readBn(stream).toNumber();
              const type = stream.read(1)[0];
              local.type = LANGUAGE_TYPES[type];
              codeBody.locals.push(local);
            }
            while (stream.bytesRead < endBytes) {
              const op = _exports.parseOp(stream);
              codeBody.code.push(op);
            }
            json.entries.push(codeBody);
          }
          return json;
        },
        "data": (stream) => {
          const numberOfEntries = leb.unsigned.readBn(stream).toNumber();
          const json = {
            name: "data",
            entries: []
          };
          for (let i = 0; i < numberOfEntries; i++) {
            const entry = {};
            entry.index = leb.unsigned.readBn(stream).toNumber();
            entry.offset = _exports.typeParsers.initExpr(stream);
            const segmentSize = leb.unsigned.readBn(stream).toNumber();
            entry.data = [...stream.read(segmentSize)];
            json.entries.push(entry);
          }
          return json;
        }
      };
      _exports.parseOp = (stream) => {
        const json = {};
        const op = stream.read(1)[0];
        const fullName = OPCODES[op];
        let [type, name] = fullName.split(".");
        if (name === void 0) {
          name = type;
        } else {
          json.return_type = type;
        }
        json.name = name;
        const immediates = OP_IMMEDIATES[name === "const" ? type : name];
        if (immediates) {
          json.immediates = _exports.immediataryParsers[immediates](stream);
        }
        return json;
      };
      _exports.parse = (stream, filter) => {
        const preramble = _exports.parsePreramble(stream);
        const json = [preramble];
        while (!stream.end) {
          const header = _exports.parseSectionHeader(stream);
          json.push(sectionParsers[header.name](stream, header));
        }
        return json;
      };
    }
  });

  // node_modules/redstone-wasm-json-toolkit/node_modules/redstone-isomorphic/npm-browser.js
  var require_npm_browser2 = __commonJS({
    "node_modules/redstone-wasm-json-toolkit/node_modules/redstone-isomorphic/npm-browser.js"(exports, module2) {
      window.global = window;
      global.fetch = window.fetch;
      module2.exports.Buffer = require_buffer().Buffer;
    }
  });

  // node_modules/redstone-wasm-json-toolkit/json2wasm.js
  var require_json2wasm = __commonJS({
    "node_modules/redstone-wasm-json-toolkit/json2wasm.js"(exports, module2) {
      var Buffer3 = require_npm_browser2().Buffer;
      var leb = require_leb128();
      var Stream = require_buffer_pipe2();
      var OP_IMMEDIATES = require_immediates();
      var _exports = module2.exports = (json) => {
        return _exports.generate(json).buffer;
      };
      var LANGUAGE_TYPES = _exports.LANGUAGE_TYPES = {
        i32: 127,
        i64: 126,
        f32: 125,
        f64: 124,
        anyFunc: 112,
        func: 96,
        block_type: 64
      };
      var EXTERNAL_KIND = _exports.EXTERNAL_KIND = {
        function: 0,
        table: 1,
        memory: 2,
        global: 3
      };
      var SECTION_IDS = _exports.SECTION_IDS = {
        custom: 0,
        type: 1,
        import: 2,
        function: 3,
        table: 4,
        memory: 5,
        global: 6,
        export: 7,
        start: 8,
        element: 9,
        code: 10,
        data: 11
      };
      var OPCODES = _exports.OPCODES = {
        unreachable: 0,
        nop: 1,
        block: 2,
        loop: 3,
        if: 4,
        else: 5,
        end: 11,
        br: 12,
        br_if: 13,
        br_table: 14,
        return: 15,
        call: 16,
        call_indirect: 17,
        drop: 26,
        select: 27,
        get_local: 32,
        set_local: 33,
        tee_local: 34,
        get_global: 35,
        set_global: 36,
        "i32.load": 40,
        "i64.load": 41,
        "f32.load": 42,
        "f64.load": 43,
        "i32.load8_s": 44,
        "i32.load8_u": 45,
        "i32.load16_s": 46,
        "i32.load16_u": 47,
        "i64.load8_s": 48,
        "i64.load8_u": 49,
        "i64.load16_s": 50,
        "i64.load16_u": 51,
        "i64.load32_s": 52,
        "i64.load32_u": 53,
        "i32.store": 54,
        "i64.store": 55,
        "f32.store": 56,
        "f64.store": 57,
        "i32.store8": 58,
        "i32.store16": 59,
        "i64.store8": 60,
        "i64.store16": 61,
        "i64.store32": 62,
        current_memory: 63,
        grow_memory: 64,
        "i32.const": 65,
        "i64.const": 66,
        "f32.const": 67,
        "f64.const": 68,
        "i32.eqz": 69,
        "i32.eq": 70,
        "i32.ne": 71,
        "i32.lt_s": 72,
        "i32.lt_u": 73,
        "i32.gt_s": 74,
        "i32.gt_u": 75,
        "i32.le_s": 76,
        "i32.le_u": 77,
        "i32.ge_s": 78,
        "i32.ge_u": 79,
        "i64.eqz": 80,
        "i64.eq": 81,
        "i64.ne": 82,
        "i64.lt_s": 83,
        "i64.lt_u": 84,
        "i64.gt_s": 85,
        "i64.gt_u": 86,
        "i64.le_s": 87,
        "i64.le_u": 88,
        "i64.ge_s": 89,
        "i64.ge_u": 90,
        "f32.eq": 91,
        "f32.ne": 92,
        "f32.lt": 93,
        "f32.gt": 94,
        "f32.le": 95,
        "f32.ge": 96,
        "f64.eq": 97,
        "f64.ne": 98,
        "f64.lt": 99,
        "f64.gt": 100,
        "f64.le": 101,
        "f64.ge": 102,
        "i32.clz": 103,
        "i32.ctz": 104,
        "i32.popcnt": 105,
        "i32.add": 106,
        "i32.sub": 107,
        "i32.mul": 108,
        "i32.div_s": 109,
        "i32.div_u": 110,
        "i32.rem_s": 111,
        "i32.rem_u": 112,
        "i32.and": 113,
        "i32.or": 114,
        "i32.xor": 115,
        "i32.shl": 116,
        "i32.shr_s": 117,
        "i32.shr_u": 118,
        "i32.rotl": 119,
        "i32.rotr": 120,
        "i64.clz": 121,
        "i64.ctz": 122,
        "i64.popcnt": 123,
        "i64.add": 124,
        "i64.sub": 125,
        "i64.mul": 126,
        "i64.div_s": 127,
        "i64.div_u": 128,
        "i64.rem_s": 129,
        "i64.rem_u": 130,
        "i64.and": 131,
        "i64.or": 132,
        "i64.xor": 133,
        "i64.shl": 134,
        "i64.shr_s": 135,
        "i64.shr_u": 136,
        "i64.rotl": 137,
        "i64.rotr": 138,
        "f32.abs": 139,
        "f32.neg": 140,
        "f32.ceil": 141,
        "f32.floor": 142,
        "f32.trunc": 143,
        "f32.nearest": 144,
        "f32.sqrt": 145,
        "f32.add": 146,
        "f32.sub": 147,
        "f32.mul": 148,
        "f32.div": 149,
        "f32.min": 150,
        "f32.max": 151,
        "f32.copysign": 152,
        "f64.abs": 153,
        "f64.neg": 154,
        "f64.ceil": 155,
        "f64.floor": 156,
        "f64.trunc": 157,
        "f64.nearest": 158,
        "f64.sqrt": 159,
        "f64.add": 160,
        "f64.sub": 161,
        "f64.mul": 162,
        "f64.div": 163,
        "f64.min": 164,
        "f64.max": 165,
        "f64.copysign": 166,
        "i32.wrap/i64": 167,
        "i32.trunc_s/f32": 168,
        "i32.trunc_u/f32": 169,
        "i32.trunc_s/f64": 170,
        "i32.trunc_u/f64": 171,
        "i64.extend_s/i32": 172,
        "i64.extend_u/i32": 173,
        "i64.trunc_s/f32": 174,
        "i64.trunc_u/f32": 175,
        "i64.trunc_s/f64": 176,
        "i64.trunc_u/f64": 177,
        "f32.convert_s/i32": 178,
        "f32.convert_u/i32": 179,
        "f32.convert_s/i64": 180,
        "f32.convert_u/i64": 181,
        "f32.demote/f64": 182,
        "f64.convert_s/i32": 183,
        "f64.convert_u/i32": 184,
        "f64.convert_s/i64": 185,
        "f64.convert_u/i64": 186,
        "f64.promote/f32": 187,
        "i32.reinterpret/f32": 188,
        "i64.reinterpret/f64": 189,
        "f32.reinterpret/i32": 190,
        "f64.reinterpret/i64": 191
      };
      _exports.typeGenerators = {
        function: (json, stream) => {
          leb.unsigned.write(json, stream);
        },
        table: (json, stream) => {
          stream.write([LANGUAGE_TYPES[json.elementType]]);
          _exports.typeGenerators.memory(json.limits, stream);
        },
        global: (json, stream) => {
          stream.write([LANGUAGE_TYPES[json.contentType]]);
          stream.write([json.mutability]);
        },
        memory: (json, stream) => {
          leb.unsigned.write(Number(json.maximum !== void 0), stream);
          leb.unsigned.write(json.intial, stream);
          if (json.maximum !== void 0) {
            leb.unsigned.write(json.maximum, stream);
          }
        },
        initExpr: (json, stream) => {
          _exports.generateOp(json, stream);
          _exports.generateOp({ name: "end", type: "void" }, stream);
        }
      };
      _exports.immediataryGenerators = {
        varuint1: (json, stream) => {
          stream.write([json]);
          return stream;
        },
        varuint32: (json, stream) => {
          leb.unsigned.write(json, stream);
          return stream;
        },
        varint32: (json, stream) => {
          leb.signed.write(json, stream);
          return stream;
        },
        varint64: (json, stream) => {
          leb.signed.write(json, stream);
          return stream;
        },
        uint32: (json, stream) => {
          stream.write(json);
          return stream;
        },
        uint64: (json, stream) => {
          stream.write(json);
          return stream;
        },
        block_type: (json, stream) => {
          stream.write([LANGUAGE_TYPES[json]]);
          return stream;
        },
        br_table: (json, stream) => {
          leb.unsigned.write(json.targets.length, stream);
          for (let target of json.targets) {
            leb.unsigned.write(target, stream);
          }
          leb.unsigned.write(json.defaultTarget, stream);
          return stream;
        },
        call_indirect: (json, stream) => {
          leb.unsigned.write(json.index, stream);
          stream.write([json.reserved]);
          return stream;
        },
        memory_immediate: (json, stream) => {
          leb.unsigned.write(json.flags, stream);
          leb.unsigned.write(json.offset, stream);
          return stream;
        }
      };
      var entryGenerators = {
        type: (entry, stream = new Stream()) => {
          stream.write([LANGUAGE_TYPES[entry.form]]);
          const len = entry.params.length;
          leb.unsigned.write(len, stream);
          if (len !== 0) {
            stream.write(entry.params.map((type) => LANGUAGE_TYPES[type]));
          }
          stream.write([entry.return_type ? 1 : 0]);
          if (entry.return_type) {
            stream.write([LANGUAGE_TYPES[entry.return_type]]);
          }
          return stream.buffer;
        },
        import: (entry, stream = new Stream()) => {
          leb.unsigned.write(entry.moduleStr.length, stream);
          stream.write(entry.moduleStr);
          leb.unsigned.write(entry.fieldStr.length, stream);
          stream.write(entry.fieldStr);
          stream.write([EXTERNAL_KIND[entry.kind]]);
          _exports.typeGenerators[entry.kind](entry.type, stream);
        },
        function: (entry, stream = new Stream()) => {
          leb.unsigned.write(entry, stream);
          return stream.buffer;
        },
        table: _exports.typeGenerators.table,
        global: (entry, stream = new Stream()) => {
          _exports.typeGenerators.global(entry.type, stream);
          _exports.typeGenerators.initExpr(entry.init, stream);
          return stream;
        },
        memory: _exports.typeGenerators.memory,
        export: (entry, stream = new Stream()) => {
          const fieldStr = Buffer3.from(entry.field_str);
          const strLen = fieldStr.length;
          leb.unsigned.write(strLen, stream);
          stream.write(fieldStr);
          stream.write([EXTERNAL_KIND[entry.kind]]);
          leb.unsigned.write(entry.index, stream);
          return stream;
        },
        element: (entry, stream = new Stream()) => {
          leb.unsigned.write(entry.index, stream);
          _exports.typeGenerators.initExpr(entry.offset, stream);
          leb.unsigned.write(entry.elements.length, stream);
          for (let elem of entry.elements) {
            leb.unsigned.write(elem, stream);
          }
          return stream;
        },
        code: (entry, stream = new Stream()) => {
          let codeStream = new Stream();
          leb.unsigned.write(entry.locals.length, codeStream);
          for (let local of entry.locals) {
            leb.unsigned.write(local.count, codeStream);
            codeStream.write([LANGUAGE_TYPES[local.type]]);
          }
          for (let op of entry.code) {
            _exports.generateOp(op, codeStream);
          }
          leb.unsigned.write(codeStream.bytesWrote, stream);
          stream.write(codeStream.buffer);
          return stream;
        },
        data: (entry, stream = new Stream()) => {
          leb.unsigned.write(entry.index, stream);
          _exports.typeGenerators.initExpr(entry.offset, stream);
          leb.unsigned.write(entry.data.length, stream);
          stream.write(entry.data);
          return stream;
        }
      };
      _exports.entryGenerators = entryGenerators;
      _exports.generateSection = function(json, stream = new Stream()) {
        const name = json.name;
        const payload = new Stream();
        stream.write([SECTION_IDS[name]]);
        if (name === "custom") {
          leb.unsigned.write(json.sectionName.length, payload);
          payload.write(json.sectionName);
          payload.write(json.payload);
        } else if (name === "start") {
          leb.unsigned.write(json.index, payload);
        } else {
          leb.unsigned.write(json.entries.length, payload);
          for (let entry of json.entries) {
            entryGenerators[name](entry, payload);
          }
        }
        leb.unsigned.write(payload.bytesWrote, stream);
        stream.write(payload.buffer);
        return stream;
      };
      _exports.generate = (json, stream = new Stream()) => {
        const [preamble, ...rest] = json;
        _exports.generatePreramble(preamble, stream);
        for (let item of rest) {
          _exports.generateSection(item, stream);
        }
        return stream;
      };
      _exports.generatePreramble = (json, stream = new Stream()) => {
        stream.write(json.magic);
        stream.write(json.version);
        return stream;
      };
      _exports.generateOp = (json, stream = new Stream()) => {
        let name = json.name;
        if (json.return_type !== void 0) {
          name = json.return_type + "." + name;
        }
        stream.write([OPCODES[name]]);
        const immediates = OP_IMMEDIATES[json.name === "const" ? json.return_type : json.name];
        if (immediates) {
          _exports.immediataryGenerators[immediates](json.immediates, stream);
        }
        return stream;
      };
    }
  });

  // node_modules/redstone-wasm-json-toolkit/text2json.js
  var require_text2json = __commonJS({
    "node_modules/redstone-wasm-json-toolkit/text2json.js"(exports, module2) {
      var immediates = require_immediates();
      module2.exports = (text) => {
        const json = [];
        const textArray = text.split(/\s|\n/);
        while (textArray.length) {
          const textOp = textArray.shift();
          const jsonOp = {};
          let [type, name] = textOp.split(".");
          if (name === void 0) {
            name = type;
          } else {
            jsonOp.return_type = type;
          }
          jsonOp.name = name;
          const immediate = immediates[jsonOp.name === "const" ? jsonOp.return_type : jsonOp.name];
          if (immediate) {
            jsonOp.immediates = immediataryParser(immediate, textArray);
          }
          json.push(jsonOp);
        }
        return json;
      };
      function immediataryParser(type, txt) {
        const json = {};
        switch (type) {
          case "br_table":
            const dests = [];
            while (1) {
              let dest = txt[0];
              if (isNaN(dest))
                break;
              txt.shift();
              dests.push(dest);
            }
            return dests;
          case "call_indirect":
            json.index = txt.shift();
            json.reserved = 0;
            return json;
          case "memory_immediate":
            json.flags = txt.shift();
            json.offset = txt.shift();
            return json;
          default:
            return txt.shift();
        }
      }
    }
  });

  // node_modules/redstone-wasm-json-toolkit/iterator.js
  var require_iterator = __commonJS({
    "node_modules/redstone-wasm-json-toolkit/iterator.js"(exports, module2) {
      var Buffer3 = require_npm_browser2().Buffer;
      var leb128 = require_leb128().unsigned;
      var wasm2json = require_wasm2json();
      var Pipe = require_buffer_pipe2();
      var SECTIONS = [
        "custom",
        "type",
        "import",
        "function",
        "table",
        "memory",
        "global",
        "export",
        "start",
        "element",
        "code",
        "data"
      ];
      module2.exports = class ModuleIterator {
        constructor(wasm) {
          this._wasm = wasm;
          this._sections = [];
          this._modified = false;
        }
        get wasm() {
          if (this._modified) {
            this._wasm = Buffer3.concat(this._sections.concat(this._pipe.buffer));
            this._modified = false;
          }
          return this._wasm;
        }
        *[Symbol.iterator]() {
          this._pipe = new Pipe(this._wasm);
          this._sections = [this._pipe.read(8)];
          while (!this._pipe.end) {
            const start = this._pipe.bytesRead;
            const sectionType = this._pipe.read(1)[0];
            const size = Number(leb128.read(this._pipe));
            const body = this._pipe.read(size);
            const end = this._pipe.bytesRead;
            const section = this._wasm.slice(start, end);
            const index = this._sections.push(section) - 1;
            yield new Section(sectionType, body, this, index);
          }
        }
        _update(index, data) {
          this._modified = true;
          this._sections[index] = data;
        }
      };
      var Section = class {
        constructor(sectionType, section, it, index) {
          this._it = it;
          this._index = index;
          this.type = SECTIONS[sectionType];
          this._type = sectionType;
          this._section = section;
          const pipe = new Pipe(section);
          if (this.type !== "custom") {
            this.count = Number(leb128.read(pipe));
          }
          this._body = pipe.buffer;
        }
        toJSON() {
          return wasm2json.sectionParsers[this.type](new Pipe(this._section));
        }
        appendEntries(entries) {
          this.count += entries.length;
          this._body = Buffer3.concat([this._body].concat(entries));
          const bodyAndCount = Buffer3.concat([leb128.encode(this.count), this._body]);
          this._it._update(this._index, Buffer3.concat([
            Buffer3.from([this._type]),
            leb128.encode(bodyAndCount.length),
            bodyAndCount
          ]));
        }
      };
    }
  });

  // node_modules/redstone-wasm-json-toolkit/index.js
  var require_redstone_wasm_json_toolkit = __commonJS({
    "node_modules/redstone-wasm-json-toolkit/index.js"(exports) {
      exports.wasm2json = require_wasm2json();
      exports.json2wasm = require_json2wasm();
      exports.text2json = require_text2json();
      exports.Iterator = require_iterator();
    }
  });

  // node_modules/redstone-wasm-metering/defaultCostTable.json
  var require_defaultCostTable = __commonJS({
    "node_modules/redstone-wasm-metering/defaultCostTable.json"(exports, module2) {
      module2.exports = {
        start: 0,
        type: {
          params: {
            DEFAULT: 0
          },
          return_type: {
            DEFAULT: 0
          }
        },
        import: 0,
        code: {
          locals: {
            DEFAULT: 1
          },
          code: {
            get_local: 120,
            set_local: 120,
            tee_local: 120,
            get_global: 120,
            set_global: 120,
            load8_s: 120,
            load8_u: 120,
            load16_s: 120,
            load16_u: 120,
            load32_s: 120,
            load32_u: 120,
            load: 120,
            store8: 120,
            store16: 120,
            store32: 120,
            store: 120,
            grow_memory: 1e4,
            current_memory: 100,
            nop: 1,
            block: 1,
            loop: 1,
            if: 1,
            then: 90,
            else: 90,
            br: 90,
            br_if: 90,
            br_table: 120,
            return: 90,
            call: 90,
            call_indirect: 1e4,
            const: 1,
            add: 45,
            sub: 45,
            mul: 45,
            div_s: 36e3,
            div_u: 36e3,
            rem_s: 36e3,
            rem_u: 36e3,
            and: 45,
            or: 45,
            xor: 45,
            shl: 67,
            shr_u: 67,
            shr_s: 67,
            rotl: 90,
            rotr: 90,
            eq: 45,
            eqz: 45,
            ne: 45,
            lt_s: 45,
            lt_u: 45,
            le_s: 45,
            le_u: 45,
            gt_s: 45,
            gt_u: 45,
            ge_s: 45,
            ge_u: 45,
            clz: 45,
            ctz: 45,
            popcnt: 45,
            drop: 120,
            select: 120,
            unreachable: 1
          }
        },
        data: 0
      };
    }
  });

  // node_modules/redstone-wasm-metering/index.js
  var require_redstone_wasm_metering = __commonJS({
    "node_modules/redstone-wasm-metering/index.js"(exports) {
      var toolkit = require_redstone_wasm_json_toolkit();
      var text2json = toolkit.text2json;
      var SECTION_IDS = require_json2wasm().SECTION_IDS;
      var defaultCostTable = require_defaultCostTable();
      function getCost(json, costTable = {}, defaultCost = 0) {
        let cost = 0;
        defaultCost = costTable["DEFAULT"] !== void 0 ? costTable["DEFAULT"] : 0;
        if (Array.isArray(json)) {
          json.forEach((el) => {
            cost += getCost(el, costTable);
          });
        } else if (typeof json === "object") {
          for (const propName in json) {
            const propCost = costTable[propName];
            if (propCost) {
              cost += getCost(json[propName], propCost, defaultCost);
            }
          }
        } else if (costTable[json] === void 0) {
          cost = defaultCost;
        } else {
          cost = costTable[json];
        }
        return cost;
      }
      function meterCodeEntry(entry, costTable, meterFuncIndex, meterType, cost) {
        function meteringStatement(cost2, meteringImportIndex) {
          return text2json(`${meterType}.const ${cost2} call ${meteringImportIndex}`);
        }
        function remapOp(op, funcIndex) {
          if (op.name === "call" && op.immediates >= funcIndex) {
            op.immediates = (++op.immediates).toString();
          }
        }
        function meterTheMeteringStatement() {
          const code2 = meteringStatement(0, 0);
          return code2.reduce((sum, op) => sum + getCost(op.name, costTable.code), 0);
        }
        const branchingOps = new Set([
          "grow_memory",
          "end",
          "br",
          "br_table",
          "br_if",
          "if",
          "else",
          "return",
          "loop"
        ]);
        const meteringOverHead = meterTheMeteringStatement();
        let code = entry.code.slice();
        let meteredCode = [];
        cost += getCost(entry.locals, costTable.local);
        while (code.length) {
          let i = 0;
          while (true) {
            const op = code[i++];
            remapOp(op, meterFuncIndex);
            cost += getCost(op.name, costTable.code);
            if (branchingOps.has(op.name)) {
              break;
            }
          }
          if (cost !== 0) {
            cost += meteringOverHead;
            meteredCode = meteredCode.concat(meteringStatement(cost, meterFuncIndex));
          }
          meteredCode = meteredCode.concat(code.slice(0, i));
          code = code.slice(i);
          cost = 0;
        }
        entry.code = meteredCode;
        return entry;
      }
      exports.meterJSON = (json, opts) => {
        function findSection(module3, sectionName) {
          return module3.find((section) => section.name === sectionName);
        }
        function createSection(module3, name) {
          const newSectionId = SECTION_IDS[name];
          for (let index in module3) {
            const section = module3[index];
            const sectionId = SECTION_IDS[section.name];
            if (sectionId) {
              if (newSectionId < sectionId) {
                module3.splice(index, 0, {
                  name,
                  entries: []
                });
                return;
              }
            }
          }
        }
        let funcIndex = 0;
        let functionModule, typeModule;
        let { costTable, moduleStr, fieldStr, meterType } = opts;
        if (!costTable)
          costTable = defaultCostTable;
        if (!moduleStr)
          moduleStr = "metering";
        if (!fieldStr)
          fieldStr = "usegas";
        if (!meterType)
          meterType = "i32";
        if (!findSection(json, "type"))
          createSection(json, "type");
        if (!findSection(json, "import"))
          createSection(json, "import");
        const importJson = {
          moduleStr,
          fieldStr,
          kind: "function"
        };
        const importType = {
          form: "func",
          params: [meterType]
        };
        json = json.slice(0);
        for (let section of json) {
          section = Object.assign(section);
          switch (section.name) {
            case "type":
              importJson.type = section.entries.push(importType) - 1;
              typeModule = section;
              break;
            case "function":
              functionModule = section;
              break;
            case "import":
              for (const entry of section.entries) {
                if (entry.moduleStr === moduleStr && entry.fieldStr === fieldStr) {
                  throw new Error("importing metering function is not allowed");
                }
                if (entry.kind === "function") {
                  funcIndex++;
                }
              }
              section.entries.push(importJson);
              break;
            case "export":
              for (const entry of section.entries) {
                if (entry.kind === "function" && entry.index >= funcIndex) {
                  entry.index++;
                }
              }
              break;
            case "element":
              for (const entry of section.entries) {
                entry.elements = entry.elements.map((el) => el >= funcIndex ? ++el : el);
              }
              break;
            case "start":
              if (section.index >= funcIndex)
                section.index++;
              break;
            case "code":
              for (const i in section.entries) {
                const entry = section.entries[i];
                const typeIndex = functionModule.entries[i];
                const type = typeModule.entries[typeIndex];
                const cost = getCost(type, costTable.type);
                meterCodeEntry(entry, costTable.code, funcIndex, meterType, cost);
              }
              break;
          }
        }
        return json;
      };
      exports.meterWASM = (wasm, opts = {}) => {
        let json = toolkit.wasm2json(wasm);
        json = exports.meterJSON(json, opts);
        return toolkit.json2wasm(json);
      };
    }
  });

  // node_modules/lodash/lodash.js
  var require_lodash = __commonJS({
    "node_modules/lodash/lodash.js"(exports, module2) {
      (function() {
        var undefined2;
        var VERSION = "4.17.21";
        var LARGE_ARRAY_SIZE = 200;
        var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
        var HASH_UNDEFINED = "__lodash_hash_undefined__";
        var MAX_MEMOIZE_SIZE = 500;
        var PLACEHOLDER = "__lodash_placeholder__";
        var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
        var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
        var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
        var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
        var HOT_COUNT = 800, HOT_SPAN = 16;
        var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
        var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
        var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
        var wrapFlags = [
          ["ary", WRAP_ARY_FLAG],
          ["bind", WRAP_BIND_FLAG],
          ["bindKey", WRAP_BIND_KEY_FLAG],
          ["curry", WRAP_CURRY_FLAG],
          ["curryRight", WRAP_CURRY_RIGHT_FLAG],
          ["flip", WRAP_FLIP_FLAG],
          ["partial", WRAP_PARTIAL_FLAG],
          ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
          ["rearg", WRAP_REARG_FLAG]
        ];
        var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
        var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
        var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
        var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
        var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
        var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
        var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
        var reTrimStart = /^\s+/;
        var reWhitespace = /\s/;
        var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
        var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
        var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
        var reEscapeChar = /\\(\\)?/g;
        var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
        var reFlags = /\w*$/;
        var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
        var reIsBinary = /^0b[01]+$/i;
        var reIsHostCtor = /^\[object .+?Constructor\]$/;
        var reIsOctal = /^0o[0-7]+$/i;
        var reIsUint = /^(?:0|[1-9]\d*)$/;
        var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
        var reNoMatch = /($^)/;
        var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
        var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
        var rsApos = "['\u2019]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
        var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
        var reApos = RegExp(rsApos, "g");
        var reComboMark = RegExp(rsCombo, "g");
        var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
        var reUnicodeWord = RegExp([
          rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
          rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
          rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
          rsUpper + "+" + rsOptContrUpper,
          rsOrdUpper,
          rsOrdLower,
          rsDigits,
          rsEmoji
        ].join("|"), "g");
        var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
        var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
        var contextProps = [
          "Array",
          "Buffer",
          "DataView",
          "Date",
          "Error",
          "Float32Array",
          "Float64Array",
          "Function",
          "Int8Array",
          "Int16Array",
          "Int32Array",
          "Map",
          "Math",
          "Object",
          "Promise",
          "RegExp",
          "Set",
          "String",
          "Symbol",
          "TypeError",
          "Uint8Array",
          "Uint8ClampedArray",
          "Uint16Array",
          "Uint32Array",
          "WeakMap",
          "_",
          "clearTimeout",
          "isFinite",
          "parseInt",
          "setTimeout"
        ];
        var templateCounter = -1;
        var typedArrayTags = {};
        typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
        typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
        var cloneableTags = {};
        cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
        cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
        var deburredLetters = {
          "\xC0": "A",
          "\xC1": "A",
          "\xC2": "A",
          "\xC3": "A",
          "\xC4": "A",
          "\xC5": "A",
          "\xE0": "a",
          "\xE1": "a",
          "\xE2": "a",
          "\xE3": "a",
          "\xE4": "a",
          "\xE5": "a",
          "\xC7": "C",
          "\xE7": "c",
          "\xD0": "D",
          "\xF0": "d",
          "\xC8": "E",
          "\xC9": "E",
          "\xCA": "E",
          "\xCB": "E",
          "\xE8": "e",
          "\xE9": "e",
          "\xEA": "e",
          "\xEB": "e",
          "\xCC": "I",
          "\xCD": "I",
          "\xCE": "I",
          "\xCF": "I",
          "\xEC": "i",
          "\xED": "i",
          "\xEE": "i",
          "\xEF": "i",
          "\xD1": "N",
          "\xF1": "n",
          "\xD2": "O",
          "\xD3": "O",
          "\xD4": "O",
          "\xD5": "O",
          "\xD6": "O",
          "\xD8": "O",
          "\xF2": "o",
          "\xF3": "o",
          "\xF4": "o",
          "\xF5": "o",
          "\xF6": "o",
          "\xF8": "o",
          "\xD9": "U",
          "\xDA": "U",
          "\xDB": "U",
          "\xDC": "U",
          "\xF9": "u",
          "\xFA": "u",
          "\xFB": "u",
          "\xFC": "u",
          "\xDD": "Y",
          "\xFD": "y",
          "\xFF": "y",
          "\xC6": "Ae",
          "\xE6": "ae",
          "\xDE": "Th",
          "\xFE": "th",
          "\xDF": "ss",
          "\u0100": "A",
          "\u0102": "A",
          "\u0104": "A",
          "\u0101": "a",
          "\u0103": "a",
          "\u0105": "a",
          "\u0106": "C",
          "\u0108": "C",
          "\u010A": "C",
          "\u010C": "C",
          "\u0107": "c",
          "\u0109": "c",
          "\u010B": "c",
          "\u010D": "c",
          "\u010E": "D",
          "\u0110": "D",
          "\u010F": "d",
          "\u0111": "d",
          "\u0112": "E",
          "\u0114": "E",
          "\u0116": "E",
          "\u0118": "E",
          "\u011A": "E",
          "\u0113": "e",
          "\u0115": "e",
          "\u0117": "e",
          "\u0119": "e",
          "\u011B": "e",
          "\u011C": "G",
          "\u011E": "G",
          "\u0120": "G",
          "\u0122": "G",
          "\u011D": "g",
          "\u011F": "g",
          "\u0121": "g",
          "\u0123": "g",
          "\u0124": "H",
          "\u0126": "H",
          "\u0125": "h",
          "\u0127": "h",
          "\u0128": "I",
          "\u012A": "I",
          "\u012C": "I",
          "\u012E": "I",
          "\u0130": "I",
          "\u0129": "i",
          "\u012B": "i",
          "\u012D": "i",
          "\u012F": "i",
          "\u0131": "i",
          "\u0134": "J",
          "\u0135": "j",
          "\u0136": "K",
          "\u0137": "k",
          "\u0138": "k",
          "\u0139": "L",
          "\u013B": "L",
          "\u013D": "L",
          "\u013F": "L",
          "\u0141": "L",
          "\u013A": "l",
          "\u013C": "l",
          "\u013E": "l",
          "\u0140": "l",
          "\u0142": "l",
          "\u0143": "N",
          "\u0145": "N",
          "\u0147": "N",
          "\u014A": "N",
          "\u0144": "n",
          "\u0146": "n",
          "\u0148": "n",
          "\u014B": "n",
          "\u014C": "O",
          "\u014E": "O",
          "\u0150": "O",
          "\u014D": "o",
          "\u014F": "o",
          "\u0151": "o",
          "\u0154": "R",
          "\u0156": "R",
          "\u0158": "R",
          "\u0155": "r",
          "\u0157": "r",
          "\u0159": "r",
          "\u015A": "S",
          "\u015C": "S",
          "\u015E": "S",
          "\u0160": "S",
          "\u015B": "s",
          "\u015D": "s",
          "\u015F": "s",
          "\u0161": "s",
          "\u0162": "T",
          "\u0164": "T",
          "\u0166": "T",
          "\u0163": "t",
          "\u0165": "t",
          "\u0167": "t",
          "\u0168": "U",
          "\u016A": "U",
          "\u016C": "U",
          "\u016E": "U",
          "\u0170": "U",
          "\u0172": "U",
          "\u0169": "u",
          "\u016B": "u",
          "\u016D": "u",
          "\u016F": "u",
          "\u0171": "u",
          "\u0173": "u",
          "\u0174": "W",
          "\u0175": "w",
          "\u0176": "Y",
          "\u0177": "y",
          "\u0178": "Y",
          "\u0179": "Z",
          "\u017B": "Z",
          "\u017D": "Z",
          "\u017A": "z",
          "\u017C": "z",
          "\u017E": "z",
          "\u0132": "IJ",
          "\u0133": "ij",
          "\u0152": "Oe",
          "\u0153": "oe",
          "\u0149": "'n",
          "\u017F": "s"
        };
        var htmlEscapes = {
          "&": "&amp;",
          "<": "&lt;",
          ">": "&gt;",
          '"': "&quot;",
          "'": "&#39;"
        };
        var htmlUnescapes = {
          "&amp;": "&",
          "&lt;": "<",
          "&gt;": ">",
          "&quot;": '"',
          "&#39;": "'"
        };
        var stringEscapes = {
          "\\": "\\",
          "'": "'",
          "\n": "n",
          "\r": "r",
          "\u2028": "u2028",
          "\u2029": "u2029"
        };
        var freeParseFloat = parseFloat, freeParseInt = parseInt;
        var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
        var freeSelf = typeof self == "object" && self && self.Object === Object && self;
        var root = freeGlobal || freeSelf || Function("return this")();
        var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
        var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
        var moduleExports = freeModule && freeModule.exports === freeExports;
        var freeProcess = moduleExports && freeGlobal.process;
        var nodeUtil = function() {
          try {
            var types = freeModule && freeModule.require && freeModule.require("util").types;
            if (types) {
              return types;
            }
            return freeProcess && freeProcess.binding && freeProcess.binding("util");
          } catch (e) {
          }
        }();
        var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
        function apply(func, thisArg, args) {
          switch (args.length) {
            case 0:
              return func.call(thisArg);
            case 1:
              return func.call(thisArg, args[0]);
            case 2:
              return func.call(thisArg, args[0], args[1]);
            case 3:
              return func.call(thisArg, args[0], args[1], args[2]);
          }
          return func.apply(thisArg, args);
        }
        function arrayAggregator(array, setter, iteratee, accumulator) {
          var index = -1, length = array == null ? 0 : array.length;
          while (++index < length) {
            var value = array[index];
            setter(accumulator, value, iteratee(value), array);
          }
          return accumulator;
        }
        function arrayEach(array, iteratee) {
          var index = -1, length = array == null ? 0 : array.length;
          while (++index < length) {
            if (iteratee(array[index], index, array) === false) {
              break;
            }
          }
          return array;
        }
        function arrayEachRight(array, iteratee) {
          var length = array == null ? 0 : array.length;
          while (length--) {
            if (iteratee(array[length], length, array) === false) {
              break;
            }
          }
          return array;
        }
        function arrayEvery(array, predicate) {
          var index = -1, length = array == null ? 0 : array.length;
          while (++index < length) {
            if (!predicate(array[index], index, array)) {
              return false;
            }
          }
          return true;
        }
        function arrayFilter(array, predicate) {
          var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
          while (++index < length) {
            var value = array[index];
            if (predicate(value, index, array)) {
              result[resIndex++] = value;
            }
          }
          return result;
        }
        function arrayIncludes(array, value) {
          var length = array == null ? 0 : array.length;
          return !!length && baseIndexOf(array, value, 0) > -1;
        }
        function arrayIncludesWith(array, value, comparator) {
          var index = -1, length = array == null ? 0 : array.length;
          while (++index < length) {
            if (comparator(value, array[index])) {
              return true;
            }
          }
          return false;
        }
        function arrayMap(array, iteratee) {
          var index = -1, length = array == null ? 0 : array.length, result = Array(length);
          while (++index < length) {
            result[index] = iteratee(array[index], index, array);
          }
          return result;
        }
        function arrayPush(array, values) {
          var index = -1, length = values.length, offset = array.length;
          while (++index < length) {
            array[offset + index] = values[index];
          }
          return array;
        }
        function arrayReduce(array, iteratee, accumulator, initAccum) {
          var index = -1, length = array == null ? 0 : array.length;
          if (initAccum && length) {
            accumulator = array[++index];
          }
          while (++index < length) {
            accumulator = iteratee(accumulator, array[index], index, array);
          }
          return accumulator;
        }
        function arrayReduceRight(array, iteratee, accumulator, initAccum) {
          var length = array == null ? 0 : array.length;
          if (initAccum && length) {
            accumulator = array[--length];
          }
          while (length--) {
            accumulator = iteratee(accumulator, array[length], length, array);
          }
          return accumulator;
        }
        function arraySome(array, predicate) {
          var index = -1, length = array == null ? 0 : array.length;
          while (++index < length) {
            if (predicate(array[index], index, array)) {
              return true;
            }
          }
          return false;
        }
        var asciiSize = baseProperty("length");
        function asciiToArray(string) {
          return string.split("");
        }
        function asciiWords(string) {
          return string.match(reAsciiWord) || [];
        }
        function baseFindKey(collection, predicate, eachFunc) {
          var result;
          eachFunc(collection, function(value, key, collection2) {
            if (predicate(value, key, collection2)) {
              result = key;
              return false;
            }
          });
          return result;
        }
        function baseFindIndex(array, predicate, fromIndex, fromRight) {
          var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
          while (fromRight ? index-- : ++index < length) {
            if (predicate(array[index], index, array)) {
              return index;
            }
          }
          return -1;
        }
        function baseIndexOf(array, value, fromIndex) {
          return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
        }
        function baseIndexOfWith(array, value, fromIndex, comparator) {
          var index = fromIndex - 1, length = array.length;
          while (++index < length) {
            if (comparator(array[index], value)) {
              return index;
            }
          }
          return -1;
        }
        function baseIsNaN(value) {
          return value !== value;
        }
        function baseMean(array, iteratee) {
          var length = array == null ? 0 : array.length;
          return length ? baseSum(array, iteratee) / length : NAN;
        }
        function baseProperty(key) {
          return function(object) {
            return object == null ? undefined2 : object[key];
          };
        }
        function basePropertyOf(object) {
          return function(key) {
            return object == null ? undefined2 : object[key];
          };
        }
        function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
          eachFunc(collection, function(value, index, collection2) {
            accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection2);
          });
          return accumulator;
        }
        function baseSortBy(array, comparer) {
          var length = array.length;
          array.sort(comparer);
          while (length--) {
            array[length] = array[length].value;
          }
          return array;
        }
        function baseSum(array, iteratee) {
          var result, index = -1, length = array.length;
          while (++index < length) {
            var current = iteratee(array[index]);
            if (current !== undefined2) {
              result = result === undefined2 ? current : result + current;
            }
          }
          return result;
        }
        function baseTimes(n, iteratee) {
          var index = -1, result = Array(n);
          while (++index < n) {
            result[index] = iteratee(index);
          }
          return result;
        }
        function baseToPairs(object, props) {
          return arrayMap(props, function(key) {
            return [key, object[key]];
          });
        }
        function baseTrim(string) {
          return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
        }
        function baseUnary(func) {
          return function(value) {
            return func(value);
          };
        }
        function baseValues(object, props) {
          return arrayMap(props, function(key) {
            return object[key];
          });
        }
        function cacheHas(cache, key) {
          return cache.has(key);
        }
        function charsStartIndex(strSymbols, chrSymbols) {
          var index = -1, length = strSymbols.length;
          while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
          }
          return index;
        }
        function charsEndIndex(strSymbols, chrSymbols) {
          var index = strSymbols.length;
          while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
          }
          return index;
        }
        function countHolders(array, placeholder) {
          var length = array.length, result = 0;
          while (length--) {
            if (array[length] === placeholder) {
              ++result;
            }
          }
          return result;
        }
        var deburrLetter = basePropertyOf(deburredLetters);
        var escapeHtmlChar = basePropertyOf(htmlEscapes);
        function escapeStringChar(chr) {
          return "\\" + stringEscapes[chr];
        }
        function getValue(object, key) {
          return object == null ? undefined2 : object[key];
        }
        function hasUnicode(string) {
          return reHasUnicode.test(string);
        }
        function hasUnicodeWord(string) {
          return reHasUnicodeWord.test(string);
        }
        function iteratorToArray(iterator) {
          var data, result = [];
          while (!(data = iterator.next()).done) {
            result.push(data.value);
          }
          return result;
        }
        function mapToArray(map) {
          var index = -1, result = Array(map.size);
          map.forEach(function(value, key) {
            result[++index] = [key, value];
          });
          return result;
        }
        function overArg(func, transform) {
          return function(arg) {
            return func(transform(arg));
          };
        }
        function replaceHolders(array, placeholder) {
          var index = -1, length = array.length, resIndex = 0, result = [];
          while (++index < length) {
            var value = array[index];
            if (value === placeholder || value === PLACEHOLDER) {
              array[index] = PLACEHOLDER;
              result[resIndex++] = index;
            }
          }
          return result;
        }
        function setToArray(set) {
          var index = -1, result = Array(set.size);
          set.forEach(function(value) {
            result[++index] = value;
          });
          return result;
        }
        function setToPairs(set) {
          var index = -1, result = Array(set.size);
          set.forEach(function(value) {
            result[++index] = [value, value];
          });
          return result;
        }
        function strictIndexOf(array, value, fromIndex) {
          var index = fromIndex - 1, length = array.length;
          while (++index < length) {
            if (array[index] === value) {
              return index;
            }
          }
          return -1;
        }
        function strictLastIndexOf(array, value, fromIndex) {
          var index = fromIndex + 1;
          while (index--) {
            if (array[index] === value) {
              return index;
            }
          }
          return index;
        }
        function stringSize(string) {
          return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
        }
        function stringToArray(string) {
          return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
        }
        function trimmedEndIndex(string) {
          var index = string.length;
          while (index-- && reWhitespace.test(string.charAt(index))) {
          }
          return index;
        }
        var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
        function unicodeSize(string) {
          var result = reUnicode.lastIndex = 0;
          while (reUnicode.test(string)) {
            ++result;
          }
          return result;
        }
        function unicodeToArray(string) {
          return string.match(reUnicode) || [];
        }
        function unicodeWords(string) {
          return string.match(reUnicodeWord) || [];
        }
        var runInContext = function runInContext2(context) {
          context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));
          var Array2 = context.Array, Date2 = context.Date, Error2 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError;
          var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype;
          var coreJsData = context["__core-js_shared__"];
          var funcToString = funcProto.toString;
          var hasOwnProperty = objectProto.hasOwnProperty;
          var idCounter = 0;
          var maskSrcKey = function() {
            var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
            return uid ? "Symbol(src)_1." + uid : "";
          }();
          var nativeObjectToString = objectProto.toString;
          var objectCtorString = funcToString.call(Object2);
          var oldDash = root._;
          var reIsNative = RegExp2("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
          var Buffer3 = moduleExports ? context.Buffer : undefined2, Symbol2 = context.Symbol, Uint8Array2 = context.Uint8Array, allocUnsafe = Buffer3 ? Buffer3.allocUnsafe : undefined2, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined2, symIterator = Symbol2 ? Symbol2.iterator : undefined2, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined2;
          var defineProperty = function() {
            try {
              var func = getNative(Object2, "defineProperty");
              func({}, "", {});
              return func;
            } catch (e) {
            }
          }();
          var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;
          var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer3 ? Buffer3.isBuffer : undefined2, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
          var DataView2 = getNative(context, "DataView"), Map2 = getNative(context, "Map"), Promise2 = getNative(context, "Promise"), Set2 = getNative(context, "Set"), WeakMap2 = getNative(context, "WeakMap"), nativeCreate = getNative(Object2, "create");
          var metaMap = WeakMap2 && new WeakMap2();
          var realNames = {};
          var dataViewCtorString = toSource(DataView2), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
          var symbolProto = Symbol2 ? Symbol2.prototype : undefined2, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined2, symbolToString = symbolProto ? symbolProto.toString : undefined2;
          function lodash(value) {
            if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
              if (value instanceof LodashWrapper) {
                return value;
              }
              if (hasOwnProperty.call(value, "__wrapped__")) {
                return wrapperClone(value);
              }
            }
            return new LodashWrapper(value);
          }
          var baseCreate = function() {
            function object() {
            }
            return function(proto) {
              if (!isObject2(proto)) {
                return {};
              }
              if (objectCreate) {
                return objectCreate(proto);
              }
              object.prototype = proto;
              var result2 = new object();
              object.prototype = undefined2;
              return result2;
            };
          }();
          function baseLodash() {
          }
          function LodashWrapper(value, chainAll) {
            this.__wrapped__ = value;
            this.__actions__ = [];
            this.__chain__ = !!chainAll;
            this.__index__ = 0;
            this.__values__ = undefined2;
          }
          lodash.templateSettings = {
            "escape": reEscape,
            "evaluate": reEvaluate,
            "interpolate": reInterpolate,
            "variable": "",
            "imports": {
              "_": lodash
            }
          };
          lodash.prototype = baseLodash.prototype;
          lodash.prototype.constructor = lodash;
          LodashWrapper.prototype = baseCreate(baseLodash.prototype);
          LodashWrapper.prototype.constructor = LodashWrapper;
          function LazyWrapper(value) {
            this.__wrapped__ = value;
            this.__actions__ = [];
            this.__dir__ = 1;
            this.__filtered__ = false;
            this.__iteratees__ = [];
            this.__takeCount__ = MAX_ARRAY_LENGTH;
            this.__views__ = [];
          }
          function lazyClone() {
            var result2 = new LazyWrapper(this.__wrapped__);
            result2.__actions__ = copyArray(this.__actions__);
            result2.__dir__ = this.__dir__;
            result2.__filtered__ = this.__filtered__;
            result2.__iteratees__ = copyArray(this.__iteratees__);
            result2.__takeCount__ = this.__takeCount__;
            result2.__views__ = copyArray(this.__views__);
            return result2;
          }
          function lazyReverse() {
            if (this.__filtered__) {
              var result2 = new LazyWrapper(this);
              result2.__dir__ = -1;
              result2.__filtered__ = true;
            } else {
              result2 = this.clone();
              result2.__dir__ *= -1;
            }
            return result2;
          }
          function lazyValue() {
            var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
            if (!isArr || !isRight && arrLength == length && takeCount == length) {
              return baseWrapperValue(array, this.__actions__);
            }
            var result2 = [];
            outer:
              while (length-- && resIndex < takeCount) {
                index += dir;
                var iterIndex = -1, value = array[index];
                while (++iterIndex < iterLength) {
                  var data = iteratees[iterIndex], iteratee2 = data.iteratee, type = data.type, computed = iteratee2(value);
                  if (type == LAZY_MAP_FLAG) {
                    value = computed;
                  } else if (!computed) {
                    if (type == LAZY_FILTER_FLAG) {
                      continue outer;
                    } else {
                      break outer;
                    }
                  }
                }
                result2[resIndex++] = value;
              }
            return result2;
          }
          LazyWrapper.prototype = baseCreate(baseLodash.prototype);
          LazyWrapper.prototype.constructor = LazyWrapper;
          function Hash(entries) {
            var index = -1, length = entries == null ? 0 : entries.length;
            this.clear();
            while (++index < length) {
              var entry = entries[index];
              this.set(entry[0], entry[1]);
            }
          }
          function hashClear() {
            this.__data__ = nativeCreate ? nativeCreate(null) : {};
            this.size = 0;
          }
          function hashDelete(key) {
            var result2 = this.has(key) && delete this.__data__[key];
            this.size -= result2 ? 1 : 0;
            return result2;
          }
          function hashGet(key) {
            var data = this.__data__;
            if (nativeCreate) {
              var result2 = data[key];
              return result2 === HASH_UNDEFINED ? undefined2 : result2;
            }
            return hasOwnProperty.call(data, key) ? data[key] : undefined2;
          }
          function hashHas(key) {
            var data = this.__data__;
            return nativeCreate ? data[key] !== undefined2 : hasOwnProperty.call(data, key);
          }
          function hashSet(key, value) {
            var data = this.__data__;
            this.size += this.has(key) ? 0 : 1;
            data[key] = nativeCreate && value === undefined2 ? HASH_UNDEFINED : value;
            return this;
          }
          Hash.prototype.clear = hashClear;
          Hash.prototype["delete"] = hashDelete;
          Hash.prototype.get = hashGet;
          Hash.prototype.has = hashHas;
          Hash.prototype.set = hashSet;
          function ListCache(entries) {
            var index = -1, length = entries == null ? 0 : entries.length;
            this.clear();
            while (++index < length) {
              var entry = entries[index];
              this.set(entry[0], entry[1]);
            }
          }
          function listCacheClear() {
            this.__data__ = [];
            this.size = 0;
          }
          function listCacheDelete(key) {
            var data = this.__data__, index = assocIndexOf(data, key);
            if (index < 0) {
              return false;
            }
            var lastIndex = data.length - 1;
            if (index == lastIndex) {
              data.pop();
            } else {
              splice.call(data, index, 1);
            }
            --this.size;
            return true;
          }
          function listCacheGet(key) {
            var data = this.__data__, index = assocIndexOf(data, key);
            return index < 0 ? undefined2 : data[index][1];
          }
          function listCacheHas(key) {
            return assocIndexOf(this.__data__, key) > -1;
          }
          function listCacheSet(key, value) {
            var data = this.__data__, index = assocIndexOf(data, key);
            if (index < 0) {
              ++this.size;
              data.push([key, value]);
            } else {
              data[index][1] = value;
            }
            return this;
          }
          ListCache.prototype.clear = listCacheClear;
          ListCache.prototype["delete"] = listCacheDelete;
          ListCache.prototype.get = listCacheGet;
          ListCache.prototype.has = listCacheHas;
          ListCache.prototype.set = listCacheSet;
          function MapCache(entries) {
            var index = -1, length = entries == null ? 0 : entries.length;
            this.clear();
            while (++index < length) {
              var entry = entries[index];
              this.set(entry[0], entry[1]);
            }
          }
          function mapCacheClear() {
            this.size = 0;
            this.__data__ = {
              "hash": new Hash(),
              "map": new (Map2 || ListCache)(),
              "string": new Hash()
            };
          }
          function mapCacheDelete(key) {
            var result2 = getMapData(this, key)["delete"](key);
            this.size -= result2 ? 1 : 0;
            return result2;
          }
          function mapCacheGet(key) {
            return getMapData(this, key).get(key);
          }
          function mapCacheHas(key) {
            return getMapData(this, key).has(key);
          }
          function mapCacheSet(key, value) {
            var data = getMapData(this, key), size2 = data.size;
            data.set(key, value);
            this.size += data.size == size2 ? 0 : 1;
            return this;
          }
          MapCache.prototype.clear = mapCacheClear;
          MapCache.prototype["delete"] = mapCacheDelete;
          MapCache.prototype.get = mapCacheGet;
          MapCache.prototype.has = mapCacheHas;
          MapCache.prototype.set = mapCacheSet;
          function SetCache(values2) {
            var index = -1, length = values2 == null ? 0 : values2.length;
            this.__data__ = new MapCache();
            while (++index < length) {
              this.add(values2[index]);
            }
          }
          function setCacheAdd(value) {
            this.__data__.set(value, HASH_UNDEFINED);
            return this;
          }
          function setCacheHas(value) {
            return this.__data__.has(value);
          }
          SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
          SetCache.prototype.has = setCacheHas;
          function Stack(entries) {
            var data = this.__data__ = new ListCache(entries);
            this.size = data.size;
          }
          function stackClear() {
            this.__data__ = new ListCache();
            this.size = 0;
          }
          function stackDelete(key) {
            var data = this.__data__, result2 = data["delete"](key);
            this.size = data.size;
            return result2;
          }
          function stackGet(key) {
            return this.__data__.get(key);
          }
          function stackHas(key) {
            return this.__data__.has(key);
          }
          function stackSet(key, value) {
            var data = this.__data__;
            if (data instanceof ListCache) {
              var pairs = data.__data__;
              if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
                pairs.push([key, value]);
                this.size = ++data.size;
                return this;
              }
              data = this.__data__ = new MapCache(pairs);
            }
            data.set(key, value);
            this.size = data.size;
            return this;
          }
          Stack.prototype.clear = stackClear;
          Stack.prototype["delete"] = stackDelete;
          Stack.prototype.get = stackGet;
          Stack.prototype.has = stackHas;
          Stack.prototype.set = stackSet;
          function arrayLikeKeys(value, inherited) {
            var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String2) : [], length = result2.length;
            for (var key in value) {
              if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex(key, length)))) {
                result2.push(key);
              }
            }
            return result2;
          }
          function arraySample(array) {
            var length = array.length;
            return length ? array[baseRandom(0, length - 1)] : undefined2;
          }
          function arraySampleSize(array, n) {
            return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
          }
          function arrayShuffle(array) {
            return shuffleSelf(copyArray(array));
          }
          function assignMergeValue(object, key, value) {
            if (value !== undefined2 && !eq(object[key], value) || value === undefined2 && !(key in object)) {
              baseAssignValue(object, key, value);
            }
          }
          function assignValue(object, key, value) {
            var objValue = object[key];
            if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined2 && !(key in object)) {
              baseAssignValue(object, key, value);
            }
          }
          function assocIndexOf(array, key) {
            var length = array.length;
            while (length--) {
              if (eq(array[length][0], key)) {
                return length;
              }
            }
            return -1;
          }
          function baseAggregator(collection, setter, iteratee2, accumulator) {
            baseEach(collection, function(value, key, collection2) {
              setter(accumulator, value, iteratee2(value), collection2);
            });
            return accumulator;
          }
          function baseAssign(object, source) {
            return object && copyObject(source, keys(source), object);
          }
          function baseAssignIn(object, source) {
            return object && copyObject(source, keysIn(source), object);
          }
          function baseAssignValue(object, key, value) {
            if (key == "__proto__" && defineProperty) {
              defineProperty(object, key, {
                "configurable": true,
                "enumerable": true,
                "value": value,
                "writable": true
              });
            } else {
              object[key] = value;
            }
          }
          function baseAt(object, paths) {
            var index = -1, length = paths.length, result2 = Array2(length), skip = object == null;
            while (++index < length) {
              result2[index] = skip ? undefined2 : get(object, paths[index]);
            }
            return result2;
          }
          function baseClamp(number, lower, upper) {
            if (number === number) {
              if (upper !== undefined2) {
                number = number <= upper ? number : upper;
              }
              if (lower !== undefined2) {
                number = number >= lower ? number : lower;
              }
            }
            return number;
          }
          function baseClone(value, bitmask, customizer, key, object, stack) {
            var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
            if (customizer) {
              result2 = object ? customizer(value, key, object, stack) : customizer(value);
            }
            if (result2 !== undefined2) {
              return result2;
            }
            if (!isObject2(value)) {
              return value;
            }
            var isArr = isArray(value);
            if (isArr) {
              result2 = initCloneArray(value);
              if (!isDeep) {
                return copyArray(value, result2);
              }
            } else {
              var tag = getTag2(value), isFunc = tag == funcTag || tag == genTag;
              if (isBuffer(value)) {
                return cloneBuffer(value, isDeep);
              }
              if (tag == objectTag || tag == argsTag || isFunc && !object) {
                result2 = isFlat || isFunc ? {} : initCloneObject(value);
                if (!isDeep) {
                  return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
                }
              } else {
                if (!cloneableTags[tag]) {
                  return object ? value : {};
                }
                result2 = initCloneByTag(value, tag, isDeep);
              }
            }
            stack || (stack = new Stack());
            var stacked = stack.get(value);
            if (stacked) {
              return stacked;
            }
            stack.set(value, result2);
            if (isSet(value)) {
              value.forEach(function(subValue) {
                result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
              });
            } else if (isMap(value)) {
              value.forEach(function(subValue, key2) {
                result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
              });
            }
            var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
            var props = isArr ? undefined2 : keysFunc(value);
            arrayEach(props || value, function(subValue, key2) {
              if (props) {
                key2 = subValue;
                subValue = value[key2];
              }
              assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
            });
            return result2;
          }
          function baseConforms(source) {
            var props = keys(source);
            return function(object) {
              return baseConformsTo(object, source, props);
            };
          }
          function baseConformsTo(object, source, props) {
            var length = props.length;
            if (object == null) {
              return !length;
            }
            object = Object2(object);
            while (length--) {
              var key = props[length], predicate = source[key], value = object[key];
              if (value === undefined2 && !(key in object) || !predicate(value)) {
                return false;
              }
            }
            return true;
          }
          function baseDelay(func, wait, args) {
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            return setTimeout2(function() {
              func.apply(undefined2, args);
            }, wait);
          }
          function baseDifference(array, values2, iteratee2, comparator) {
            var index = -1, includes2 = arrayIncludes, isCommon = true, length = array.length, result2 = [], valuesLength = values2.length;
            if (!length) {
              return result2;
            }
            if (iteratee2) {
              values2 = arrayMap(values2, baseUnary(iteratee2));
            }
            if (comparator) {
              includes2 = arrayIncludesWith;
              isCommon = false;
            } else if (values2.length >= LARGE_ARRAY_SIZE) {
              includes2 = cacheHas;
              isCommon = false;
              values2 = new SetCache(values2);
            }
            outer:
              while (++index < length) {
                var value = array[index], computed = iteratee2 == null ? value : iteratee2(value);
                value = comparator || value !== 0 ? value : 0;
                if (isCommon && computed === computed) {
                  var valuesIndex = valuesLength;
                  while (valuesIndex--) {
                    if (values2[valuesIndex] === computed) {
                      continue outer;
                    }
                  }
                  result2.push(value);
                } else if (!includes2(values2, computed, comparator)) {
                  result2.push(value);
                }
              }
            return result2;
          }
          var baseEach = createBaseEach(baseForOwn);
          var baseEachRight = createBaseEach(baseForOwnRight, true);
          function baseEvery(collection, predicate) {
            var result2 = true;
            baseEach(collection, function(value, index, collection2) {
              result2 = !!predicate(value, index, collection2);
              return result2;
            });
            return result2;
          }
          function baseExtremum(array, iteratee2, comparator) {
            var index = -1, length = array.length;
            while (++index < length) {
              var value = array[index], current = iteratee2(value);
              if (current != null && (computed === undefined2 ? current === current && !isSymbol(current) : comparator(current, computed))) {
                var computed = current, result2 = value;
              }
            }
            return result2;
          }
          function baseFill(array, value, start, end) {
            var length = array.length;
            start = toInteger(start);
            if (start < 0) {
              start = -start > length ? 0 : length + start;
            }
            end = end === undefined2 || end > length ? length : toInteger(end);
            if (end < 0) {
              end += length;
            }
            end = start > end ? 0 : toLength(end);
            while (start < end) {
              array[start++] = value;
            }
            return array;
          }
          function baseFilter(collection, predicate) {
            var result2 = [];
            baseEach(collection, function(value, index, collection2) {
              if (predicate(value, index, collection2)) {
                result2.push(value);
              }
            });
            return result2;
          }
          function baseFlatten(array, depth, predicate, isStrict, result2) {
            var index = -1, length = array.length;
            predicate || (predicate = isFlattenable);
            result2 || (result2 = []);
            while (++index < length) {
              var value = array[index];
              if (depth > 0 && predicate(value)) {
                if (depth > 1) {
                  baseFlatten(value, depth - 1, predicate, isStrict, result2);
                } else {
                  arrayPush(result2, value);
                }
              } else if (!isStrict) {
                result2[result2.length] = value;
              }
            }
            return result2;
          }
          var baseFor = createBaseFor();
          var baseForRight = createBaseFor(true);
          function baseForOwn(object, iteratee2) {
            return object && baseFor(object, iteratee2, keys);
          }
          function baseForOwnRight(object, iteratee2) {
            return object && baseForRight(object, iteratee2, keys);
          }
          function baseFunctions(object, props) {
            return arrayFilter(props, function(key) {
              return isFunction(object[key]);
            });
          }
          function baseGet(object, path2) {
            path2 = castPath(path2, object);
            var index = 0, length = path2.length;
            while (object != null && index < length) {
              object = object[toKey(path2[index++])];
            }
            return index && index == length ? object : undefined2;
          }
          function baseGetAllKeys(object, keysFunc, symbolsFunc) {
            var result2 = keysFunc(object);
            return isArray(object) ? result2 : arrayPush(result2, symbolsFunc(object));
          }
          function baseGetTag(value) {
            if (value == null) {
              return value === undefined2 ? undefinedTag : nullTag;
            }
            return symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString(value);
          }
          function baseGt(value, other) {
            return value > other;
          }
          function baseHas(object, key) {
            return object != null && hasOwnProperty.call(object, key);
          }
          function baseHasIn(object, key) {
            return object != null && key in Object2(object);
          }
          function baseInRange(number, start, end) {
            return number >= nativeMin(start, end) && number < nativeMax(start, end);
          }
          function baseIntersection(arrays, iteratee2, comparator) {
            var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
            while (othIndex--) {
              var array = arrays[othIndex];
              if (othIndex && iteratee2) {
                array = arrayMap(array, baseUnary(iteratee2));
              }
              maxLength = nativeMin(array.length, maxLength);
              caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined2;
            }
            array = arrays[0];
            var index = -1, seen = caches[0];
            outer:
              while (++index < length && result2.length < maxLength) {
                var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
                value = comparator || value !== 0 ? value : 0;
                if (!(seen ? cacheHas(seen, computed) : includes2(result2, computed, comparator))) {
                  othIndex = othLength;
                  while (--othIndex) {
                    var cache = caches[othIndex];
                    if (!(cache ? cacheHas(cache, computed) : includes2(arrays[othIndex], computed, comparator))) {
                      continue outer;
                    }
                  }
                  if (seen) {
                    seen.push(computed);
                  }
                  result2.push(value);
                }
              }
            return result2;
          }
          function baseInverter(object, setter, iteratee2, accumulator) {
            baseForOwn(object, function(value, key, object2) {
              setter(accumulator, iteratee2(value), key, object2);
            });
            return accumulator;
          }
          function baseInvoke(object, path2, args) {
            path2 = castPath(path2, object);
            object = parent(object, path2);
            var func = object == null ? object : object[toKey(last(path2))];
            return func == null ? undefined2 : apply(func, object, args);
          }
          function baseIsArguments(value) {
            return isObjectLike(value) && baseGetTag(value) == argsTag;
          }
          function baseIsArrayBuffer(value) {
            return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
          }
          function baseIsDate(value) {
            return isObjectLike(value) && baseGetTag(value) == dateTag;
          }
          function baseIsEqual(value, other, bitmask, customizer, stack) {
            if (value === other) {
              return true;
            }
            if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
              return value !== value && other !== other;
            }
            return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
          }
          function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
            var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag2(object), othTag = othIsArr ? arrayTag : getTag2(other);
            objTag = objTag == argsTag ? objectTag : objTag;
            othTag = othTag == argsTag ? objectTag : othTag;
            var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
            if (isSameTag && isBuffer(object)) {
              if (!isBuffer(other)) {
                return false;
              }
              objIsArr = true;
              objIsObj = false;
            }
            if (isSameTag && !objIsObj) {
              stack || (stack = new Stack());
              return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
            }
            if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
              var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
              if (objIsWrapped || othIsWrapped) {
                var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
                stack || (stack = new Stack());
                return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
              }
            }
            if (!isSameTag) {
              return false;
            }
            stack || (stack = new Stack());
            return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
          }
          function baseIsMap(value) {
            return isObjectLike(value) && getTag2(value) == mapTag;
          }
          function baseIsMatch(object, source, matchData, customizer) {
            var index = matchData.length, length = index, noCustomizer = !customizer;
            if (object == null) {
              return !length;
            }
            object = Object2(object);
            while (index--) {
              var data = matchData[index];
              if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
                return false;
              }
            }
            while (++index < length) {
              data = matchData[index];
              var key = data[0], objValue = object[key], srcValue = data[1];
              if (noCustomizer && data[2]) {
                if (objValue === undefined2 && !(key in object)) {
                  return false;
                }
              } else {
                var stack = new Stack();
                if (customizer) {
                  var result2 = customizer(objValue, srcValue, key, object, source, stack);
                }
                if (!(result2 === undefined2 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result2)) {
                  return false;
                }
              }
            }
            return true;
          }
          function baseIsNative(value) {
            if (!isObject2(value) || isMasked(value)) {
              return false;
            }
            var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
            return pattern.test(toSource(value));
          }
          function baseIsRegExp(value) {
            return isObjectLike(value) && baseGetTag(value) == regexpTag;
          }
          function baseIsSet(value) {
            return isObjectLike(value) && getTag2(value) == setTag;
          }
          function baseIsTypedArray(value) {
            return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
          }
          function baseIteratee(value) {
            if (typeof value == "function") {
              return value;
            }
            if (value == null) {
              return identity;
            }
            if (typeof value == "object") {
              return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
            }
            return property(value);
          }
          function baseKeys(object) {
            if (!isPrototype(object)) {
              return nativeKeys(object);
            }
            var result2 = [];
            for (var key in Object2(object)) {
              if (hasOwnProperty.call(object, key) && key != "constructor") {
                result2.push(key);
              }
            }
            return result2;
          }
          function baseKeysIn(object) {
            if (!isObject2(object)) {
              return nativeKeysIn(object);
            }
            var isProto = isPrototype(object), result2 = [];
            for (var key in object) {
              if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
                result2.push(key);
              }
            }
            return result2;
          }
          function baseLt(value, other) {
            return value < other;
          }
          function baseMap(collection, iteratee2) {
            var index = -1, result2 = isArrayLike(collection) ? Array2(collection.length) : [];
            baseEach(collection, function(value, key, collection2) {
              result2[++index] = iteratee2(value, key, collection2);
            });
            return result2;
          }
          function baseMatches(source) {
            var matchData = getMatchData(source);
            if (matchData.length == 1 && matchData[0][2]) {
              return matchesStrictComparable(matchData[0][0], matchData[0][1]);
            }
            return function(object) {
              return object === source || baseIsMatch(object, source, matchData);
            };
          }
          function baseMatchesProperty(path2, srcValue) {
            if (isKey(path2) && isStrictComparable(srcValue)) {
              return matchesStrictComparable(toKey(path2), srcValue);
            }
            return function(object) {
              var objValue = get(object, path2);
              return objValue === undefined2 && objValue === srcValue ? hasIn(object, path2) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
            };
          }
          function baseMerge(object, source, srcIndex, customizer, stack) {
            if (object === source) {
              return;
            }
            baseFor(source, function(srcValue, key) {
              stack || (stack = new Stack());
              if (isObject2(srcValue)) {
                baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
              } else {
                var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : undefined2;
                if (newValue === undefined2) {
                  newValue = srcValue;
                }
                assignMergeValue(object, key, newValue);
              }
            }, keysIn);
          }
          function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
            var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
            if (stacked) {
              assignMergeValue(object, key, stacked);
              return;
            }
            var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined2;
            var isCommon = newValue === undefined2;
            if (isCommon) {
              var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
              newValue = srcValue;
              if (isArr || isBuff || isTyped) {
                if (isArray(objValue)) {
                  newValue = objValue;
                } else if (isArrayLikeObject(objValue)) {
                  newValue = copyArray(objValue);
                } else if (isBuff) {
                  isCommon = false;
                  newValue = cloneBuffer(srcValue, true);
                } else if (isTyped) {
                  isCommon = false;
                  newValue = cloneTypedArray(srcValue, true);
                } else {
                  newValue = [];
                }
              } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
                newValue = objValue;
                if (isArguments(objValue)) {
                  newValue = toPlainObject(objValue);
                } else if (!isObject2(objValue) || isFunction(objValue)) {
                  newValue = initCloneObject(srcValue);
                }
              } else {
                isCommon = false;
              }
            }
            if (isCommon) {
              stack.set(srcValue, newValue);
              mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
              stack["delete"](srcValue);
            }
            assignMergeValue(object, key, newValue);
          }
          function baseNth(array, n) {
            var length = array.length;
            if (!length) {
              return;
            }
            n += n < 0 ? length : 0;
            return isIndex(n, length) ? array[n] : undefined2;
          }
          function baseOrderBy(collection, iteratees, orders) {
            if (iteratees.length) {
              iteratees = arrayMap(iteratees, function(iteratee2) {
                if (isArray(iteratee2)) {
                  return function(value) {
                    return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
                  };
                }
                return iteratee2;
              });
            } else {
              iteratees = [identity];
            }
            var index = -1;
            iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
            var result2 = baseMap(collection, function(value, key, collection2) {
              var criteria = arrayMap(iteratees, function(iteratee2) {
                return iteratee2(value);
              });
              return { "criteria": criteria, "index": ++index, "value": value };
            });
            return baseSortBy(result2, function(object, other) {
              return compareMultiple(object, other, orders);
            });
          }
          function basePick(object, paths) {
            return basePickBy(object, paths, function(value, path2) {
              return hasIn(object, path2);
            });
          }
          function basePickBy(object, paths, predicate) {
            var index = -1, length = paths.length, result2 = {};
            while (++index < length) {
              var path2 = paths[index], value = baseGet(object, path2);
              if (predicate(value, path2)) {
                baseSet(result2, castPath(path2, object), value);
              }
            }
            return result2;
          }
          function basePropertyDeep(path2) {
            return function(object) {
              return baseGet(object, path2);
            };
          }
          function basePullAll(array, values2, iteratee2, comparator) {
            var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length = values2.length, seen = array;
            if (array === values2) {
              values2 = copyArray(values2);
            }
            if (iteratee2) {
              seen = arrayMap(array, baseUnary(iteratee2));
            }
            while (++index < length) {
              var fromIndex = 0, value = values2[index], computed = iteratee2 ? iteratee2(value) : value;
              while ((fromIndex = indexOf2(seen, computed, fromIndex, comparator)) > -1) {
                if (seen !== array) {
                  splice.call(seen, fromIndex, 1);
                }
                splice.call(array, fromIndex, 1);
              }
            }
            return array;
          }
          function basePullAt(array, indexes) {
            var length = array ? indexes.length : 0, lastIndex = length - 1;
            while (length--) {
              var index = indexes[length];
              if (length == lastIndex || index !== previous) {
                var previous = index;
                if (isIndex(index)) {
                  splice.call(array, index, 1);
                } else {
                  baseUnset(array, index);
                }
              }
            }
            return array;
          }
          function baseRandom(lower, upper) {
            return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
          }
          function baseRange(start, end, step, fromRight) {
            var index = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result2 = Array2(length);
            while (length--) {
              result2[fromRight ? length : ++index] = start;
              start += step;
            }
            return result2;
          }
          function baseRepeat(string, n) {
            var result2 = "";
            if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
              return result2;
            }
            do {
              if (n % 2) {
                result2 += string;
              }
              n = nativeFloor(n / 2);
              if (n) {
                string += string;
              }
            } while (n);
            return result2;
          }
          function baseRest(func, start) {
            return setToString(overRest(func, start, identity), func + "");
          }
          function baseSample(collection) {
            return arraySample(values(collection));
          }
          function baseSampleSize(collection, n) {
            var array = values(collection);
            return shuffleSelf(array, baseClamp(n, 0, array.length));
          }
          function baseSet(object, path2, value, customizer) {
            if (!isObject2(object)) {
              return object;
            }
            path2 = castPath(path2, object);
            var index = -1, length = path2.length, lastIndex = length - 1, nested = object;
            while (nested != null && ++index < length) {
              var key = toKey(path2[index]), newValue = value;
              if (key === "__proto__" || key === "constructor" || key === "prototype") {
                return object;
              }
              if (index != lastIndex) {
                var objValue = nested[key];
                newValue = customizer ? customizer(objValue, key, nested) : undefined2;
                if (newValue === undefined2) {
                  newValue = isObject2(objValue) ? objValue : isIndex(path2[index + 1]) ? [] : {};
                }
              }
              assignValue(nested, key, newValue);
              nested = nested[key];
            }
            return object;
          }
          var baseSetData = !metaMap ? identity : function(func, data) {
            metaMap.set(func, data);
            return func;
          };
          var baseSetToString = !defineProperty ? identity : function(func, string) {
            return defineProperty(func, "toString", {
              "configurable": true,
              "enumerable": false,
              "value": constant(string),
              "writable": true
            });
          };
          function baseShuffle(collection) {
            return shuffleSelf(values(collection));
          }
          function baseSlice(array, start, end) {
            var index = -1, length = array.length;
            if (start < 0) {
              start = -start > length ? 0 : length + start;
            }
            end = end > length ? length : end;
            if (end < 0) {
              end += length;
            }
            length = start > end ? 0 : end - start >>> 0;
            start >>>= 0;
            var result2 = Array2(length);
            while (++index < length) {
              result2[index] = array[index + start];
            }
            return result2;
          }
          function baseSome(collection, predicate) {
            var result2;
            baseEach(collection, function(value, index, collection2) {
              result2 = predicate(value, index, collection2);
              return !result2;
            });
            return !!result2;
          }
          function baseSortedIndex(array, value, retHighest) {
            var low = 0, high = array == null ? low : array.length;
            if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
              while (low < high) {
                var mid = low + high >>> 1, computed = array[mid];
                if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) {
                  low = mid + 1;
                } else {
                  high = mid;
                }
              }
              return high;
            }
            return baseSortedIndexBy(array, value, identity, retHighest);
          }
          function baseSortedIndexBy(array, value, iteratee2, retHighest) {
            var low = 0, high = array == null ? 0 : array.length;
            if (high === 0) {
              return 0;
            }
            value = iteratee2(value);
            var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined2;
            while (low < high) {
              var mid = nativeFloor((low + high) / 2), computed = iteratee2(array[mid]), othIsDefined = computed !== undefined2, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
              if (valIsNaN) {
                var setLow = retHighest || othIsReflexive;
              } else if (valIsUndefined) {
                setLow = othIsReflexive && (retHighest || othIsDefined);
              } else if (valIsNull) {
                setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
              } else if (valIsSymbol) {
                setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
              } else if (othIsNull || othIsSymbol) {
                setLow = false;
              } else {
                setLow = retHighest ? computed <= value : computed < value;
              }
              if (setLow) {
                low = mid + 1;
              } else {
                high = mid;
              }
            }
            return nativeMin(high, MAX_ARRAY_INDEX);
          }
          function baseSortedUniq(array, iteratee2) {
            var index = -1, length = array.length, resIndex = 0, result2 = [];
            while (++index < length) {
              var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
              if (!index || !eq(computed, seen)) {
                var seen = computed;
                result2[resIndex++] = value === 0 ? 0 : value;
              }
            }
            return result2;
          }
          function baseToNumber(value) {
            if (typeof value == "number") {
              return value;
            }
            if (isSymbol(value)) {
              return NAN;
            }
            return +value;
          }
          function baseToString(value) {
            if (typeof value == "string") {
              return value;
            }
            if (isArray(value)) {
              return arrayMap(value, baseToString) + "";
            }
            if (isSymbol(value)) {
              return symbolToString ? symbolToString.call(value) : "";
            }
            var result2 = value + "";
            return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
          }
          function baseUniq(array, iteratee2, comparator) {
            var index = -1, includes2 = arrayIncludes, length = array.length, isCommon = true, result2 = [], seen = result2;
            if (comparator) {
              isCommon = false;
              includes2 = arrayIncludesWith;
            } else if (length >= LARGE_ARRAY_SIZE) {
              var set2 = iteratee2 ? null : createSet(array);
              if (set2) {
                return setToArray(set2);
              }
              isCommon = false;
              includes2 = cacheHas;
              seen = new SetCache();
            } else {
              seen = iteratee2 ? [] : result2;
            }
            outer:
              while (++index < length) {
                var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
                value = comparator || value !== 0 ? value : 0;
                if (isCommon && computed === computed) {
                  var seenIndex = seen.length;
                  while (seenIndex--) {
                    if (seen[seenIndex] === computed) {
                      continue outer;
                    }
                  }
                  if (iteratee2) {
                    seen.push(computed);
                  }
                  result2.push(value);
                } else if (!includes2(seen, computed, comparator)) {
                  if (seen !== result2) {
                    seen.push(computed);
                  }
                  result2.push(value);
                }
              }
            return result2;
          }
          function baseUnset(object, path2) {
            path2 = castPath(path2, object);
            object = parent(object, path2);
            return object == null || delete object[toKey(last(path2))];
          }
          function baseUpdate(object, path2, updater, customizer) {
            return baseSet(object, path2, updater(baseGet(object, path2)), customizer);
          }
          function baseWhile(array, predicate, isDrop, fromRight) {
            var length = array.length, index = fromRight ? length : -1;
            while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {
            }
            return isDrop ? baseSlice(array, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array, fromRight ? index + 1 : 0, fromRight ? length : index);
          }
          function baseWrapperValue(value, actions) {
            var result2 = value;
            if (result2 instanceof LazyWrapper) {
              result2 = result2.value();
            }
            return arrayReduce(actions, function(result3, action) {
              return action.func.apply(action.thisArg, arrayPush([result3], action.args));
            }, result2);
          }
          function baseXor(arrays, iteratee2, comparator) {
            var length = arrays.length;
            if (length < 2) {
              return length ? baseUniq(arrays[0]) : [];
            }
            var index = -1, result2 = Array2(length);
            while (++index < length) {
              var array = arrays[index], othIndex = -1;
              while (++othIndex < length) {
                if (othIndex != index) {
                  result2[index] = baseDifference(result2[index] || array, arrays[othIndex], iteratee2, comparator);
                }
              }
            }
            return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
          }
          function baseZipObject(props, values2, assignFunc) {
            var index = -1, length = props.length, valsLength = values2.length, result2 = {};
            while (++index < length) {
              var value = index < valsLength ? values2[index] : undefined2;
              assignFunc(result2, props[index], value);
            }
            return result2;
          }
          function castArrayLikeObject(value) {
            return isArrayLikeObject(value) ? value : [];
          }
          function castFunction(value) {
            return typeof value == "function" ? value : identity;
          }
          function castPath(value, object) {
            if (isArray(value)) {
              return value;
            }
            return isKey(value, object) ? [value] : stringToPath(toString2(value));
          }
          var castRest = baseRest;
          function castSlice(array, start, end) {
            var length = array.length;
            end = end === undefined2 ? length : end;
            return !start && end >= length ? array : baseSlice(array, start, end);
          }
          var clearTimeout2 = ctxClearTimeout || function(id) {
            return root.clearTimeout(id);
          };
          function cloneBuffer(buffer, isDeep) {
            if (isDeep) {
              return buffer.slice();
            }
            var length = buffer.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
            buffer.copy(result2);
            return result2;
          }
          function cloneArrayBuffer(arrayBuffer) {
            var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
            new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
            return result2;
          }
          function cloneDataView(dataView, isDeep) {
            var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
            return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
          }
          function cloneRegExp(regexp) {
            var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
            result2.lastIndex = regexp.lastIndex;
            return result2;
          }
          function cloneSymbol(symbol) {
            return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
          }
          function cloneTypedArray(typedArray, isDeep) {
            var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
            return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
          }
          function compareAscending(value, other) {
            if (value !== other) {
              var valIsDefined = value !== undefined2, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
              var othIsDefined = other !== undefined2, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
              if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
                return 1;
              }
              if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
                return -1;
              }
            }
            return 0;
          }
          function compareMultiple(object, other, orders) {
            var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
            while (++index < length) {
              var result2 = compareAscending(objCriteria[index], othCriteria[index]);
              if (result2) {
                if (index >= ordersLength) {
                  return result2;
                }
                var order = orders[index];
                return result2 * (order == "desc" ? -1 : 1);
              }
            }
            return object.index - other.index;
          }
          function composeArgs(args, partials, holders, isCurried) {
            var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
            while (++leftIndex < leftLength) {
              result2[leftIndex] = partials[leftIndex];
            }
            while (++argsIndex < holdersLength) {
              if (isUncurried || argsIndex < argsLength) {
                result2[holders[argsIndex]] = args[argsIndex];
              }
            }
            while (rangeLength--) {
              result2[leftIndex++] = args[argsIndex++];
            }
            return result2;
          }
          function composeArgsRight(args, partials, holders, isCurried) {
            var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
            while (++argsIndex < rangeLength) {
              result2[argsIndex] = args[argsIndex];
            }
            var offset = argsIndex;
            while (++rightIndex < rightLength) {
              result2[offset + rightIndex] = partials[rightIndex];
            }
            while (++holdersIndex < holdersLength) {
              if (isUncurried || argsIndex < argsLength) {
                result2[offset + holders[holdersIndex]] = args[argsIndex++];
              }
            }
            return result2;
          }
          function copyArray(source, array) {
            var index = -1, length = source.length;
            array || (array = Array2(length));
            while (++index < length) {
              array[index] = source[index];
            }
            return array;
          }
          function copyObject(source, props, object, customizer) {
            var isNew = !object;
            object || (object = {});
            var index = -1, length = props.length;
            while (++index < length) {
              var key = props[index];
              var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined2;
              if (newValue === undefined2) {
                newValue = source[key];
              }
              if (isNew) {
                baseAssignValue(object, key, newValue);
              } else {
                assignValue(object, key, newValue);
              }
            }
            return object;
          }
          function copySymbols(source, object) {
            return copyObject(source, getSymbols(source), object);
          }
          function copySymbolsIn(source, object) {
            return copyObject(source, getSymbolsIn(source), object);
          }
          function createAggregator(setter, initializer) {
            return function(collection, iteratee2) {
              var func = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
              return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
            };
          }
          function createAssigner(assigner) {
            return baseRest(function(object, sources) {
              var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined2, guard = length > 2 ? sources[2] : undefined2;
              customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined2;
              if (guard && isIterateeCall(sources[0], sources[1], guard)) {
                customizer = length < 3 ? undefined2 : customizer;
                length = 1;
              }
              object = Object2(object);
              while (++index < length) {
                var source = sources[index];
                if (source) {
                  assigner(object, source, index, customizer);
                }
              }
              return object;
            });
          }
          function createBaseEach(eachFunc, fromRight) {
            return function(collection, iteratee2) {
              if (collection == null) {
                return collection;
              }
              if (!isArrayLike(collection)) {
                return eachFunc(collection, iteratee2);
              }
              var length = collection.length, index = fromRight ? length : -1, iterable = Object2(collection);
              while (fromRight ? index-- : ++index < length) {
                if (iteratee2(iterable[index], index, iterable) === false) {
                  break;
                }
              }
              return collection;
            };
          }
          function createBaseFor(fromRight) {
            return function(object, iteratee2, keysFunc) {
              var index = -1, iterable = Object2(object), props = keysFunc(object), length = props.length;
              while (length--) {
                var key = props[fromRight ? length : ++index];
                if (iteratee2(iterable[key], key, iterable) === false) {
                  break;
                }
              }
              return object;
            };
          }
          function createBind(func, bitmask, thisArg) {
            var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
            function wrapper() {
              var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
              return fn.apply(isBind ? thisArg : this, arguments);
            }
            return wrapper;
          }
          function createCaseFirst(methodName) {
            return function(string) {
              string = toString2(string);
              var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined2;
              var chr = strSymbols ? strSymbols[0] : string.charAt(0);
              var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
              return chr[methodName]() + trailing;
            };
          }
          function createCompounder(callback) {
            return function(string) {
              return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
            };
          }
          function createCtor(Ctor) {
            return function() {
              var args = arguments;
              switch (args.length) {
                case 0:
                  return new Ctor();
                case 1:
                  return new Ctor(args[0]);
                case 2:
                  return new Ctor(args[0], args[1]);
                case 3:
                  return new Ctor(args[0], args[1], args[2]);
                case 4:
                  return new Ctor(args[0], args[1], args[2], args[3]);
                case 5:
                  return new Ctor(args[0], args[1], args[2], args[3], args[4]);
                case 6:
                  return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
                case 7:
                  return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
              }
              var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
              return isObject2(result2) ? result2 : thisBinding;
            };
          }
          function createCurry(func, bitmask, arity) {
            var Ctor = createCtor(func);
            function wrapper() {
              var length = arguments.length, args = Array2(length), index = length, placeholder = getHolder(wrapper);
              while (index--) {
                args[index] = arguments[index];
              }
              var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
              length -= holders.length;
              if (length < arity) {
                return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, undefined2, args, holders, undefined2, undefined2, arity - length);
              }
              var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
              return apply(fn, this, args);
            }
            return wrapper;
          }
          function createFind(findIndexFunc) {
            return function(collection, predicate, fromIndex) {
              var iterable = Object2(collection);
              if (!isArrayLike(collection)) {
                var iteratee2 = getIteratee(predicate, 3);
                collection = keys(collection);
                predicate = function(key) {
                  return iteratee2(iterable[key], key, iterable);
                };
              }
              var index = findIndexFunc(collection, predicate, fromIndex);
              return index > -1 ? iterable[iteratee2 ? collection[index] : index] : undefined2;
            };
          }
          function createFlow(fromRight) {
            return flatRest(function(funcs) {
              var length = funcs.length, index = length, prereq = LodashWrapper.prototype.thru;
              if (fromRight) {
                funcs.reverse();
              }
              while (index--) {
                var func = funcs[index];
                if (typeof func != "function") {
                  throw new TypeError2(FUNC_ERROR_TEXT);
                }
                if (prereq && !wrapper && getFuncName(func) == "wrapper") {
                  var wrapper = new LodashWrapper([], true);
                }
              }
              index = wrapper ? index : length;
              while (++index < length) {
                func = funcs[index];
                var funcName = getFuncName(func), data = funcName == "wrapper" ? getData(func) : undefined2;
                if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
                  wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
                } else {
                  wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
                }
              }
              return function() {
                var args = arguments, value = args[0];
                if (wrapper && args.length == 1 && isArray(value)) {
                  return wrapper.plant(value).value();
                }
                var index2 = 0, result2 = length ? funcs[index2].apply(this, args) : value;
                while (++index2 < length) {
                  result2 = funcs[index2].call(this, result2);
                }
                return result2;
              };
            });
          }
          function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
            var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined2 : createCtor(func);
            function wrapper() {
              var length = arguments.length, args = Array2(length), index = length;
              while (index--) {
                args[index] = arguments[index];
              }
              if (isCurried) {
                var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
              }
              if (partials) {
                args = composeArgs(args, partials, holders, isCurried);
              }
              if (partialsRight) {
                args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
              }
              length -= holdersCount;
              if (isCurried && length < arity) {
                var newHolders = replaceHolders(args, placeholder);
                return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, thisArg, args, newHolders, argPos, ary2, arity - length);
              }
              var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
              length = args.length;
              if (argPos) {
                args = reorder(args, argPos);
              } else if (isFlip && length > 1) {
                args.reverse();
              }
              if (isAry && ary2 < length) {
                args.length = ary2;
              }
              if (this && this !== root && this instanceof wrapper) {
                fn = Ctor || createCtor(fn);
              }
              return fn.apply(thisBinding, args);
            }
            return wrapper;
          }
          function createInverter(setter, toIteratee) {
            return function(object, iteratee2) {
              return baseInverter(object, setter, toIteratee(iteratee2), {});
            };
          }
          function createMathOperation(operator, defaultValue) {
            return function(value, other) {
              var result2;
              if (value === undefined2 && other === undefined2) {
                return defaultValue;
              }
              if (value !== undefined2) {
                result2 = value;
              }
              if (other !== undefined2) {
                if (result2 === undefined2) {
                  return other;
                }
                if (typeof value == "string" || typeof other == "string") {
                  value = baseToString(value);
                  other = baseToString(other);
                } else {
                  value = baseToNumber(value);
                  other = baseToNumber(other);
                }
                result2 = operator(value, other);
              }
              return result2;
            };
          }
          function createOver(arrayFunc) {
            return flatRest(function(iteratees) {
              iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
              return baseRest(function(args) {
                var thisArg = this;
                return arrayFunc(iteratees, function(iteratee2) {
                  return apply(iteratee2, thisArg, args);
                });
              });
            });
          }
          function createPadding(length, chars) {
            chars = chars === undefined2 ? " " : baseToString(chars);
            var charsLength = chars.length;
            if (charsLength < 2) {
              return charsLength ? baseRepeat(chars, length) : chars;
            }
            var result2 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
            return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length).join("") : result2.slice(0, length);
          }
          function createPartial(func, bitmask, thisArg, partials) {
            var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
            function wrapper() {
              var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root && this instanceof wrapper ? Ctor : func;
              while (++leftIndex < leftLength) {
                args[leftIndex] = partials[leftIndex];
              }
              while (argsLength--) {
                args[leftIndex++] = arguments[++argsIndex];
              }
              return apply(fn, isBind ? thisArg : this, args);
            }
            return wrapper;
          }
          function createRange(fromRight) {
            return function(start, end, step) {
              if (step && typeof step != "number" && isIterateeCall(start, end, step)) {
                end = step = undefined2;
              }
              start = toFinite(start);
              if (end === undefined2) {
                end = start;
                start = 0;
              } else {
                end = toFinite(end);
              }
              step = step === undefined2 ? start < end ? 1 : -1 : toFinite(step);
              return baseRange(start, end, step, fromRight);
            };
          }
          function createRelationalOperation(operator) {
            return function(value, other) {
              if (!(typeof value == "string" && typeof other == "string")) {
                value = toNumber(value);
                other = toNumber(other);
              }
              return operator(value, other);
            };
          }
          function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
            var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined2, newHoldersRight = isCurry ? undefined2 : holders, newPartials = isCurry ? partials : undefined2, newPartialsRight = isCurry ? undefined2 : partials;
            bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
            bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
            if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
              bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
            }
            var newData = [
              func,
              bitmask,
              thisArg,
              newPartials,
              newHolders,
              newPartialsRight,
              newHoldersRight,
              argPos,
              ary2,
              arity
            ];
            var result2 = wrapFunc.apply(undefined2, newData);
            if (isLaziable(func)) {
              setData(result2, newData);
            }
            result2.placeholder = placeholder;
            return setWrapToString(result2, func, bitmask);
          }
          function createRound(methodName) {
            var func = Math2[methodName];
            return function(number, precision) {
              number = toNumber(number);
              precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
              if (precision && nativeIsFinite(number)) {
                var pair = (toString2(number) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
                pair = (toString2(value) + "e").split("e");
                return +(pair[0] + "e" + (+pair[1] - precision));
              }
              return func(number);
            };
          }
          var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop : function(values2) {
            return new Set2(values2);
          };
          function createToPairs(keysFunc) {
            return function(object) {
              var tag = getTag2(object);
              if (tag == mapTag) {
                return mapToArray(object);
              }
              if (tag == setTag) {
                return setToPairs(object);
              }
              return baseToPairs(object, keysFunc(object));
            };
          }
          function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
            var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
            if (!isBindKey && typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            var length = partials ? partials.length : 0;
            if (!length) {
              bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
              partials = holders = undefined2;
            }
            ary2 = ary2 === undefined2 ? ary2 : nativeMax(toInteger(ary2), 0);
            arity = arity === undefined2 ? arity : toInteger(arity);
            length -= holders ? holders.length : 0;
            if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
              var partialsRight = partials, holdersRight = holders;
              partials = holders = undefined2;
            }
            var data = isBindKey ? undefined2 : getData(func);
            var newData = [
              func,
              bitmask,
              thisArg,
              partials,
              holders,
              partialsRight,
              holdersRight,
              argPos,
              ary2,
              arity
            ];
            if (data) {
              mergeData(newData, data);
            }
            func = newData[0];
            bitmask = newData[1];
            thisArg = newData[2];
            partials = newData[3];
            holders = newData[4];
            arity = newData[9] = newData[9] === undefined2 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
            if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
              bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
            }
            if (!bitmask || bitmask == WRAP_BIND_FLAG) {
              var result2 = createBind(func, bitmask, thisArg);
            } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
              result2 = createCurry(func, bitmask, arity);
            } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
              result2 = createPartial(func, bitmask, thisArg, partials);
            } else {
              result2 = createHybrid.apply(undefined2, newData);
            }
            var setter = data ? baseSetData : setData;
            return setWrapToString(setter(result2, newData), func, bitmask);
          }
          function customDefaultsAssignIn(objValue, srcValue, key, object) {
            if (objValue === undefined2 || eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key)) {
              return srcValue;
            }
            return objValue;
          }
          function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
            if (isObject2(objValue) && isObject2(srcValue)) {
              stack.set(srcValue, objValue);
              baseMerge(objValue, srcValue, undefined2, customDefaultsMerge, stack);
              stack["delete"](srcValue);
            }
            return objValue;
          }
          function customOmitClone(value) {
            return isPlainObject(value) ? undefined2 : value;
          }
          function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
            if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
              return false;
            }
            var arrStacked = stack.get(array);
            var othStacked = stack.get(other);
            if (arrStacked && othStacked) {
              return arrStacked == other && othStacked == array;
            }
            var index = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined2;
            stack.set(array, other);
            stack.set(other, array);
            while (++index < arrLength) {
              var arrValue = array[index], othValue = other[index];
              if (customizer) {
                var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
              }
              if (compared !== undefined2) {
                if (compared) {
                  continue;
                }
                result2 = false;
                break;
              }
              if (seen) {
                if (!arraySome(other, function(othValue2, othIndex) {
                  if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                    return seen.push(othIndex);
                  }
                })) {
                  result2 = false;
                  break;
                }
              } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                result2 = false;
                break;
              }
            }
            stack["delete"](array);
            stack["delete"](other);
            return result2;
          }
          function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
            switch (tag) {
              case dataViewTag:
                if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
                  return false;
                }
                object = object.buffer;
                other = other.buffer;
              case arrayBufferTag:
                if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
                  return false;
                }
                return true;
              case boolTag:
              case dateTag:
              case numberTag:
                return eq(+object, +other);
              case errorTag:
                return object.name == other.name && object.message == other.message;
              case regexpTag:
              case stringTag:
                return object == other + "";
              case mapTag:
                var convert = mapToArray;
              case setTag:
                var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
                convert || (convert = setToArray);
                if (object.size != other.size && !isPartial) {
                  return false;
                }
                var stacked = stack.get(object);
                if (stacked) {
                  return stacked == other;
                }
                bitmask |= COMPARE_UNORDERED_FLAG;
                stack.set(object, other);
                var result2 = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
                stack["delete"](object);
                return result2;
              case symbolTag:
                if (symbolValueOf) {
                  return symbolValueOf.call(object) == symbolValueOf.call(other);
                }
            }
            return false;
          }
          function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
            if (objLength != othLength && !isPartial) {
              return false;
            }
            var index = objLength;
            while (index--) {
              var key = objProps[index];
              if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
                return false;
              }
            }
            var objStacked = stack.get(object);
            var othStacked = stack.get(other);
            if (objStacked && othStacked) {
              return objStacked == other && othStacked == object;
            }
            var result2 = true;
            stack.set(object, other);
            stack.set(other, object);
            var skipCtor = isPartial;
            while (++index < objLength) {
              key = objProps[index];
              var objValue = object[key], othValue = other[key];
              if (customizer) {
                var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
              }
              if (!(compared === undefined2 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
                result2 = false;
                break;
              }
              skipCtor || (skipCtor = key == "constructor");
            }
            if (result2 && !skipCtor) {
              var objCtor = object.constructor, othCtor = other.constructor;
              if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
                result2 = false;
              }
            }
            stack["delete"](object);
            stack["delete"](other);
            return result2;
          }
          function flatRest(func) {
            return setToString(overRest(func, undefined2, flatten), func + "");
          }
          function getAllKeys(object) {
            return baseGetAllKeys(object, keys, getSymbols);
          }
          function getAllKeysIn(object) {
            return baseGetAllKeys(object, keysIn, getSymbolsIn);
          }
          var getData = !metaMap ? noop : function(func) {
            return metaMap.get(func);
          };
          function getFuncName(func) {
            var result2 = func.name + "", array = realNames[result2], length = hasOwnProperty.call(realNames, result2) ? array.length : 0;
            while (length--) {
              var data = array[length], otherFunc = data.func;
              if (otherFunc == null || otherFunc == func) {
                return data.name;
              }
            }
            return result2;
          }
          function getHolder(func) {
            var object = hasOwnProperty.call(lodash, "placeholder") ? lodash : func;
            return object.placeholder;
          }
          function getIteratee() {
            var result2 = lodash.iteratee || iteratee;
            result2 = result2 === iteratee ? baseIteratee : result2;
            return arguments.length ? result2(arguments[0], arguments[1]) : result2;
          }
          function getMapData(map2, key) {
            var data = map2.__data__;
            return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
          }
          function getMatchData(object) {
            var result2 = keys(object), length = result2.length;
            while (length--) {
              var key = result2[length], value = object[key];
              result2[length] = [key, value, isStrictComparable(value)];
            }
            return result2;
          }
          function getNative(object, key) {
            var value = getValue(object, key);
            return baseIsNative(value) ? value : undefined2;
          }
          function getRawTag(value) {
            var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
            try {
              value[symToStringTag] = undefined2;
              var unmasked = true;
            } catch (e) {
            }
            var result2 = nativeObjectToString.call(value);
            if (unmasked) {
              if (isOwn) {
                value[symToStringTag] = tag;
              } else {
                delete value[symToStringTag];
              }
            }
            return result2;
          }
          var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
            if (object == null) {
              return [];
            }
            object = Object2(object);
            return arrayFilter(nativeGetSymbols(object), function(symbol) {
              return propertyIsEnumerable.call(object, symbol);
            });
          };
          var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
            var result2 = [];
            while (object) {
              arrayPush(result2, getSymbols(object));
              object = getPrototype(object);
            }
            return result2;
          };
          var getTag2 = baseGetTag;
          if (DataView2 && getTag2(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag2(new Map2()) != mapTag || Promise2 && getTag2(Promise2.resolve()) != promiseTag || Set2 && getTag2(new Set2()) != setTag || WeakMap2 && getTag2(new WeakMap2()) != weakMapTag) {
            getTag2 = function(value) {
              var result2 = baseGetTag(value), Ctor = result2 == objectTag ? value.constructor : undefined2, ctorString = Ctor ? toSource(Ctor) : "";
              if (ctorString) {
                switch (ctorString) {
                  case dataViewCtorString:
                    return dataViewTag;
                  case mapCtorString:
                    return mapTag;
                  case promiseCtorString:
                    return promiseTag;
                  case setCtorString:
                    return setTag;
                  case weakMapCtorString:
                    return weakMapTag;
                }
              }
              return result2;
            };
          }
          function getView(start, end, transforms) {
            var index = -1, length = transforms.length;
            while (++index < length) {
              var data = transforms[index], size2 = data.size;
              switch (data.type) {
                case "drop":
                  start += size2;
                  break;
                case "dropRight":
                  end -= size2;
                  break;
                case "take":
                  end = nativeMin(end, start + size2);
                  break;
                case "takeRight":
                  start = nativeMax(start, end - size2);
                  break;
              }
            }
            return { "start": start, "end": end };
          }
          function getWrapDetails(source) {
            var match = source.match(reWrapDetails);
            return match ? match[1].split(reSplitDetails) : [];
          }
          function hasPath(object, path2, hasFunc) {
            path2 = castPath(path2, object);
            var index = -1, length = path2.length, result2 = false;
            while (++index < length) {
              var key = toKey(path2[index]);
              if (!(result2 = object != null && hasFunc(object, key))) {
                break;
              }
              object = object[key];
            }
            if (result2 || ++index != length) {
              return result2;
            }
            length = object == null ? 0 : object.length;
            return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
          }
          function initCloneArray(array) {
            var length = array.length, result2 = new array.constructor(length);
            if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
              result2.index = array.index;
              result2.input = array.input;
            }
            return result2;
          }
          function initCloneObject(object) {
            return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
          }
          function initCloneByTag(object, tag, isDeep) {
            var Ctor = object.constructor;
            switch (tag) {
              case arrayBufferTag:
                return cloneArrayBuffer(object);
              case boolTag:
              case dateTag:
                return new Ctor(+object);
              case dataViewTag:
                return cloneDataView(object, isDeep);
              case float32Tag:
              case float64Tag:
              case int8Tag:
              case int16Tag:
              case int32Tag:
              case uint8Tag:
              case uint8ClampedTag:
              case uint16Tag:
              case uint32Tag:
                return cloneTypedArray(object, isDeep);
              case mapTag:
                return new Ctor();
              case numberTag:
              case stringTag:
                return new Ctor(object);
              case regexpTag:
                return cloneRegExp(object);
              case setTag:
                return new Ctor();
              case symbolTag:
                return cloneSymbol(object);
            }
          }
          function insertWrapDetails(source, details) {
            var length = details.length;
            if (!length) {
              return source;
            }
            var lastIndex = length - 1;
            details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
            details = details.join(length > 2 ? ", " : " ");
            return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
          }
          function isFlattenable(value) {
            return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
          }
          function isIndex(value, length) {
            var type = typeof value;
            length = length == null ? MAX_SAFE_INTEGER : length;
            return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
          }
          function isIterateeCall(value, index, object) {
            if (!isObject2(object)) {
              return false;
            }
            var type = typeof index;
            if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
              return eq(object[index], value);
            }
            return false;
          }
          function isKey(value, object) {
            if (isArray(value)) {
              return false;
            }
            var type = typeof value;
            if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
              return true;
            }
            return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object2(object);
          }
          function isKeyable(value) {
            var type = typeof value;
            return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
          }
          function isLaziable(func) {
            var funcName = getFuncName(func), other = lodash[funcName];
            if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
              return false;
            }
            if (func === other) {
              return true;
            }
            var data = getData(other);
            return !!data && func === data[0];
          }
          function isMasked(func) {
            return !!maskSrcKey && maskSrcKey in func;
          }
          var isMaskable = coreJsData ? isFunction : stubFalse;
          function isPrototype(value) {
            var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
            return value === proto;
          }
          function isStrictComparable(value) {
            return value === value && !isObject2(value);
          }
          function matchesStrictComparable(key, srcValue) {
            return function(object) {
              if (object == null) {
                return false;
              }
              return object[key] === srcValue && (srcValue !== undefined2 || key in Object2(object));
            };
          }
          function memoizeCapped(func) {
            var result2 = memoize(func, function(key) {
              if (cache.size === MAX_MEMOIZE_SIZE) {
                cache.clear();
              }
              return key;
            });
            var cache = result2.cache;
            return result2;
          }
          function mergeData(data, source) {
            var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
            var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
            if (!(isCommon || isCombo)) {
              return data;
            }
            if (srcBitmask & WRAP_BIND_FLAG) {
              data[2] = source[2];
              newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
            }
            var value = source[3];
            if (value) {
              var partials = data[3];
              data[3] = partials ? composeArgs(partials, value, source[4]) : value;
              data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
            }
            value = source[5];
            if (value) {
              partials = data[5];
              data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
              data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
            }
            value = source[7];
            if (value) {
              data[7] = value;
            }
            if (srcBitmask & WRAP_ARY_FLAG) {
              data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
            }
            if (data[9] == null) {
              data[9] = source[9];
            }
            data[0] = source[0];
            data[1] = newBitmask;
            return data;
          }
          function nativeKeysIn(object) {
            var result2 = [];
            if (object != null) {
              for (var key in Object2(object)) {
                result2.push(key);
              }
            }
            return result2;
          }
          function objectToString(value) {
            return nativeObjectToString.call(value);
          }
          function overRest(func, start, transform2) {
            start = nativeMax(start === undefined2 ? func.length - 1 : start, 0);
            return function() {
              var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array2(length);
              while (++index < length) {
                array[index] = args[start + index];
              }
              index = -1;
              var otherArgs = Array2(start + 1);
              while (++index < start) {
                otherArgs[index] = args[index];
              }
              otherArgs[start] = transform2(array);
              return apply(func, this, otherArgs);
            };
          }
          function parent(object, path2) {
            return path2.length < 2 ? object : baseGet(object, baseSlice(path2, 0, -1));
          }
          function reorder(array, indexes) {
            var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);
            while (length--) {
              var index = indexes[length];
              array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined2;
            }
            return array;
          }
          function safeGet(object, key) {
            if (key === "constructor" && typeof object[key] === "function") {
              return;
            }
            if (key == "__proto__") {
              return;
            }
            return object[key];
          }
          var setData = shortOut(baseSetData);
          var setTimeout2 = ctxSetTimeout || function(func, wait) {
            return root.setTimeout(func, wait);
          };
          var setToString = shortOut(baseSetToString);
          function setWrapToString(wrapper, reference, bitmask) {
            var source = reference + "";
            return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
          }
          function shortOut(func) {
            var count = 0, lastCalled = 0;
            return function() {
              var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
              lastCalled = stamp;
              if (remaining > 0) {
                if (++count >= HOT_COUNT) {
                  return arguments[0];
                }
              } else {
                count = 0;
              }
              return func.apply(undefined2, arguments);
            };
          }
          function shuffleSelf(array, size2) {
            var index = -1, length = array.length, lastIndex = length - 1;
            size2 = size2 === undefined2 ? length : size2;
            while (++index < size2) {
              var rand = baseRandom(index, lastIndex), value = array[rand];
              array[rand] = array[index];
              array[index] = value;
            }
            array.length = size2;
            return array;
          }
          var stringToPath = memoizeCapped(function(string) {
            var result2 = [];
            if (string.charCodeAt(0) === 46) {
              result2.push("");
            }
            string.replace(rePropName, function(match, number, quote, subString) {
              result2.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
            });
            return result2;
          });
          function toKey(value) {
            if (typeof value == "string" || isSymbol(value)) {
              return value;
            }
            var result2 = value + "";
            return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
          }
          function toSource(func) {
            if (func != null) {
              try {
                return funcToString.call(func);
              } catch (e) {
              }
              try {
                return func + "";
              } catch (e) {
              }
            }
            return "";
          }
          function updateWrapDetails(details, bitmask) {
            arrayEach(wrapFlags, function(pair) {
              var value = "_." + pair[0];
              if (bitmask & pair[1] && !arrayIncludes(details, value)) {
                details.push(value);
              }
            });
            return details.sort();
          }
          function wrapperClone(wrapper) {
            if (wrapper instanceof LazyWrapper) {
              return wrapper.clone();
            }
            var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
            result2.__actions__ = copyArray(wrapper.__actions__);
            result2.__index__ = wrapper.__index__;
            result2.__values__ = wrapper.__values__;
            return result2;
          }
          function chunk(array, size2, guard) {
            if (guard ? isIterateeCall(array, size2, guard) : size2 === undefined2) {
              size2 = 1;
            } else {
              size2 = nativeMax(toInteger(size2), 0);
            }
            var length = array == null ? 0 : array.length;
            if (!length || size2 < 1) {
              return [];
            }
            var index = 0, resIndex = 0, result2 = Array2(nativeCeil(length / size2));
            while (index < length) {
              result2[resIndex++] = baseSlice(array, index, index += size2);
            }
            return result2;
          }
          function compact(array) {
            var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result2 = [];
            while (++index < length) {
              var value = array[index];
              if (value) {
                result2[resIndex++] = value;
              }
            }
            return result2;
          }
          function concat() {
            var length = arguments.length;
            if (!length) {
              return [];
            }
            var args = Array2(length - 1), array = arguments[0], index = length;
            while (index--) {
              args[index - 1] = arguments[index];
            }
            return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
          }
          var difference = baseRest(function(array, values2) {
            return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];
          });
          var differenceBy = baseRest(function(array, values2) {
            var iteratee2 = last(values2);
            if (isArrayLikeObject(iteratee2)) {
              iteratee2 = undefined2;
            }
            return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
          });
          var differenceWith = baseRest(function(array, values2) {
            var comparator = last(values2);
            if (isArrayLikeObject(comparator)) {
              comparator = undefined2;
            }
            return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), undefined2, comparator) : [];
          });
          function drop(array, n, guard) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return [];
            }
            n = guard || n === undefined2 ? 1 : toInteger(n);
            return baseSlice(array, n < 0 ? 0 : n, length);
          }
          function dropRight(array, n, guard) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return [];
            }
            n = guard || n === undefined2 ? 1 : toInteger(n);
            n = length - n;
            return baseSlice(array, 0, n < 0 ? 0 : n);
          }
          function dropRightWhile(array, predicate) {
            return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
          }
          function dropWhile(array, predicate) {
            return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
          }
          function fill(array, value, start, end) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return [];
            }
            if (start && typeof start != "number" && isIterateeCall(array, value, start)) {
              start = 0;
              end = length;
            }
            return baseFill(array, value, start, end);
          }
          function findIndex(array, predicate, fromIndex) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return -1;
            }
            var index = fromIndex == null ? 0 : toInteger(fromIndex);
            if (index < 0) {
              index = nativeMax(length + index, 0);
            }
            return baseFindIndex(array, getIteratee(predicate, 3), index);
          }
          function findLastIndex(array, predicate, fromIndex) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return -1;
            }
            var index = length - 1;
            if (fromIndex !== undefined2) {
              index = toInteger(fromIndex);
              index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
            }
            return baseFindIndex(array, getIteratee(predicate, 3), index, true);
          }
          function flatten(array) {
            var length = array == null ? 0 : array.length;
            return length ? baseFlatten(array, 1) : [];
          }
          function flattenDeep(array) {
            var length = array == null ? 0 : array.length;
            return length ? baseFlatten(array, INFINITY) : [];
          }
          function flattenDepth(array, depth) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return [];
            }
            depth = depth === undefined2 ? 1 : toInteger(depth);
            return baseFlatten(array, depth);
          }
          function fromPairs(pairs) {
            var index = -1, length = pairs == null ? 0 : pairs.length, result2 = {};
            while (++index < length) {
              var pair = pairs[index];
              result2[pair[0]] = pair[1];
            }
            return result2;
          }
          function head(array) {
            return array && array.length ? array[0] : undefined2;
          }
          function indexOf(array, value, fromIndex) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return -1;
            }
            var index = fromIndex == null ? 0 : toInteger(fromIndex);
            if (index < 0) {
              index = nativeMax(length + index, 0);
            }
            return baseIndexOf(array, value, index);
          }
          function initial(array) {
            var length = array == null ? 0 : array.length;
            return length ? baseSlice(array, 0, -1) : [];
          }
          var intersection = baseRest(function(arrays) {
            var mapped = arrayMap(arrays, castArrayLikeObject);
            return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
          });
          var intersectionBy = baseRest(function(arrays) {
            var iteratee2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
            if (iteratee2 === last(mapped)) {
              iteratee2 = undefined2;
            } else {
              mapped.pop();
            }
            return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
          });
          var intersectionWith = baseRest(function(arrays) {
            var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
            comparator = typeof comparator == "function" ? comparator : undefined2;
            if (comparator) {
              mapped.pop();
            }
            return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined2, comparator) : [];
          });
          function join(array, separator) {
            return array == null ? "" : nativeJoin.call(array, separator);
          }
          function last(array) {
            var length = array == null ? 0 : array.length;
            return length ? array[length - 1] : undefined2;
          }
          function lastIndexOf(array, value, fromIndex) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return -1;
            }
            var index = length;
            if (fromIndex !== undefined2) {
              index = toInteger(fromIndex);
              index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
            }
            return value === value ? strictLastIndexOf(array, value, index) : baseFindIndex(array, baseIsNaN, index, true);
          }
          function nth(array, n) {
            return array && array.length ? baseNth(array, toInteger(n)) : undefined2;
          }
          var pull = baseRest(pullAll);
          function pullAll(array, values2) {
            return array && array.length && values2 && values2.length ? basePullAll(array, values2) : array;
          }
          function pullAllBy(array, values2, iteratee2) {
            return array && array.length && values2 && values2.length ? basePullAll(array, values2, getIteratee(iteratee2, 2)) : array;
          }
          function pullAllWith(array, values2, comparator) {
            return array && array.length && values2 && values2.length ? basePullAll(array, values2, undefined2, comparator) : array;
          }
          var pullAt = flatRest(function(array, indexes) {
            var length = array == null ? 0 : array.length, result2 = baseAt(array, indexes);
            basePullAt(array, arrayMap(indexes, function(index) {
              return isIndex(index, length) ? +index : index;
            }).sort(compareAscending));
            return result2;
          });
          function remove(array, predicate) {
            var result2 = [];
            if (!(array && array.length)) {
              return result2;
            }
            var index = -1, indexes = [], length = array.length;
            predicate = getIteratee(predicate, 3);
            while (++index < length) {
              var value = array[index];
              if (predicate(value, index, array)) {
                result2.push(value);
                indexes.push(index);
              }
            }
            basePullAt(array, indexes);
            return result2;
          }
          function reverse(array) {
            return array == null ? array : nativeReverse.call(array);
          }
          function slice(array, start, end) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return [];
            }
            if (end && typeof end != "number" && isIterateeCall(array, start, end)) {
              start = 0;
              end = length;
            } else {
              start = start == null ? 0 : toInteger(start);
              end = end === undefined2 ? length : toInteger(end);
            }
            return baseSlice(array, start, end);
          }
          function sortedIndex(array, value) {
            return baseSortedIndex(array, value);
          }
          function sortedIndexBy(array, value, iteratee2) {
            return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2));
          }
          function sortedIndexOf(array, value) {
            var length = array == null ? 0 : array.length;
            if (length) {
              var index = baseSortedIndex(array, value);
              if (index < length && eq(array[index], value)) {
                return index;
              }
            }
            return -1;
          }
          function sortedLastIndex(array, value) {
            return baseSortedIndex(array, value, true);
          }
          function sortedLastIndexBy(array, value, iteratee2) {
            return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2), true);
          }
          function sortedLastIndexOf(array, value) {
            var length = array == null ? 0 : array.length;
            if (length) {
              var index = baseSortedIndex(array, value, true) - 1;
              if (eq(array[index], value)) {
                return index;
              }
            }
            return -1;
          }
          function sortedUniq(array) {
            return array && array.length ? baseSortedUniq(array) : [];
          }
          function sortedUniqBy(array, iteratee2) {
            return array && array.length ? baseSortedUniq(array, getIteratee(iteratee2, 2)) : [];
          }
          function tail(array) {
            var length = array == null ? 0 : array.length;
            return length ? baseSlice(array, 1, length) : [];
          }
          function take(array, n, guard) {
            if (!(array && array.length)) {
              return [];
            }
            n = guard || n === undefined2 ? 1 : toInteger(n);
            return baseSlice(array, 0, n < 0 ? 0 : n);
          }
          function takeRight(array, n, guard) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return [];
            }
            n = guard || n === undefined2 ? 1 : toInteger(n);
            n = length - n;
            return baseSlice(array, n < 0 ? 0 : n, length);
          }
          function takeRightWhile(array, predicate) {
            return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
          }
          function takeWhile(array, predicate) {
            return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
          }
          var union = baseRest(function(arrays) {
            return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
          });
          var unionBy = baseRest(function(arrays) {
            var iteratee2 = last(arrays);
            if (isArrayLikeObject(iteratee2)) {
              iteratee2 = undefined2;
            }
            return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
          });
          var unionWith = baseRest(function(arrays) {
            var comparator = last(arrays);
            comparator = typeof comparator == "function" ? comparator : undefined2;
            return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined2, comparator);
          });
          function uniq(array) {
            return array && array.length ? baseUniq(array) : [];
          }
          function uniqBy(array, iteratee2) {
            return array && array.length ? baseUniq(array, getIteratee(iteratee2, 2)) : [];
          }
          function uniqWith(array, comparator) {
            comparator = typeof comparator == "function" ? comparator : undefined2;
            return array && array.length ? baseUniq(array, undefined2, comparator) : [];
          }
          function unzip2(array) {
            if (!(array && array.length)) {
              return [];
            }
            var length = 0;
            array = arrayFilter(array, function(group) {
              if (isArrayLikeObject(group)) {
                length = nativeMax(group.length, length);
                return true;
              }
            });
            return baseTimes(length, function(index) {
              return arrayMap(array, baseProperty(index));
            });
          }
          function unzipWith(array, iteratee2) {
            if (!(array && array.length)) {
              return [];
            }
            var result2 = unzip2(array);
            if (iteratee2 == null) {
              return result2;
            }
            return arrayMap(result2, function(group) {
              return apply(iteratee2, undefined2, group);
            });
          }
          var without = baseRest(function(array, values2) {
            return isArrayLikeObject(array) ? baseDifference(array, values2) : [];
          });
          var xor = baseRest(function(arrays) {
            return baseXor(arrayFilter(arrays, isArrayLikeObject));
          });
          var xorBy = baseRest(function(arrays) {
            var iteratee2 = last(arrays);
            if (isArrayLikeObject(iteratee2)) {
              iteratee2 = undefined2;
            }
            return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
          });
          var xorWith = baseRest(function(arrays) {
            var comparator = last(arrays);
            comparator = typeof comparator == "function" ? comparator : undefined2;
            return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined2, comparator);
          });
          var zip = baseRest(unzip2);
          function zipObject(props, values2) {
            return baseZipObject(props || [], values2 || [], assignValue);
          }
          function zipObjectDeep(props, values2) {
            return baseZipObject(props || [], values2 || [], baseSet);
          }
          var zipWith = baseRest(function(arrays) {
            var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined2;
            iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined2;
            return unzipWith(arrays, iteratee2);
          });
          function chain(value) {
            var result2 = lodash(value);
            result2.__chain__ = true;
            return result2;
          }
          function tap(value, interceptor) {
            interceptor(value);
            return value;
          }
          function thru(value, interceptor) {
            return interceptor(value);
          }
          var wrapperAt = flatRest(function(paths) {
            var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
              return baseAt(object, paths);
            };
            if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) {
              return this.thru(interceptor);
            }
            value = value.slice(start, +start + (length ? 1 : 0));
            value.__actions__.push({
              "func": thru,
              "args": [interceptor],
              "thisArg": undefined2
            });
            return new LodashWrapper(value, this.__chain__).thru(function(array) {
              if (length && !array.length) {
                array.push(undefined2);
              }
              return array;
            });
          });
          function wrapperChain() {
            return chain(this);
          }
          function wrapperCommit() {
            return new LodashWrapper(this.value(), this.__chain__);
          }
          function wrapperNext() {
            if (this.__values__ === undefined2) {
              this.__values__ = toArray(this.value());
            }
            var done = this.__index__ >= this.__values__.length, value = done ? undefined2 : this.__values__[this.__index__++];
            return { "done": done, "value": value };
          }
          function wrapperToIterator() {
            return this;
          }
          function wrapperPlant(value) {
            var result2, parent2 = this;
            while (parent2 instanceof baseLodash) {
              var clone2 = wrapperClone(parent2);
              clone2.__index__ = 0;
              clone2.__values__ = undefined2;
              if (result2) {
                previous.__wrapped__ = clone2;
              } else {
                result2 = clone2;
              }
              var previous = clone2;
              parent2 = parent2.__wrapped__;
            }
            previous.__wrapped__ = value;
            return result2;
          }
          function wrapperReverse() {
            var value = this.__wrapped__;
            if (value instanceof LazyWrapper) {
              var wrapped = value;
              if (this.__actions__.length) {
                wrapped = new LazyWrapper(this);
              }
              wrapped = wrapped.reverse();
              wrapped.__actions__.push({
                "func": thru,
                "args": [reverse],
                "thisArg": undefined2
              });
              return new LodashWrapper(wrapped, this.__chain__);
            }
            return this.thru(reverse);
          }
          function wrapperValue() {
            return baseWrapperValue(this.__wrapped__, this.__actions__);
          }
          var countBy = createAggregator(function(result2, value, key) {
            if (hasOwnProperty.call(result2, key)) {
              ++result2[key];
            } else {
              baseAssignValue(result2, key, 1);
            }
          });
          function every(collection, predicate, guard) {
            var func = isArray(collection) ? arrayEvery : baseEvery;
            if (guard && isIterateeCall(collection, predicate, guard)) {
              predicate = undefined2;
            }
            return func(collection, getIteratee(predicate, 3));
          }
          function filter(collection, predicate) {
            var func = isArray(collection) ? arrayFilter : baseFilter;
            return func(collection, getIteratee(predicate, 3));
          }
          var find = createFind(findIndex);
          var findLast = createFind(findLastIndex);
          function flatMap(collection, iteratee2) {
            return baseFlatten(map(collection, iteratee2), 1);
          }
          function flatMapDeep(collection, iteratee2) {
            return baseFlatten(map(collection, iteratee2), INFINITY);
          }
          function flatMapDepth(collection, iteratee2, depth) {
            depth = depth === undefined2 ? 1 : toInteger(depth);
            return baseFlatten(map(collection, iteratee2), depth);
          }
          function forEach(collection, iteratee2) {
            var func = isArray(collection) ? arrayEach : baseEach;
            return func(collection, getIteratee(iteratee2, 3));
          }
          function forEachRight(collection, iteratee2) {
            var func = isArray(collection) ? arrayEachRight : baseEachRight;
            return func(collection, getIteratee(iteratee2, 3));
          }
          var groupBy = createAggregator(function(result2, value, key) {
            if (hasOwnProperty.call(result2, key)) {
              result2[key].push(value);
            } else {
              baseAssignValue(result2, key, [value]);
            }
          });
          function includes(collection, value, fromIndex, guard) {
            collection = isArrayLike(collection) ? collection : values(collection);
            fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
            var length = collection.length;
            if (fromIndex < 0) {
              fromIndex = nativeMax(length + fromIndex, 0);
            }
            return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
          }
          var invokeMap = baseRest(function(collection, path2, args) {
            var index = -1, isFunc = typeof path2 == "function", result2 = isArrayLike(collection) ? Array2(collection.length) : [];
            baseEach(collection, function(value) {
              result2[++index] = isFunc ? apply(path2, value, args) : baseInvoke(value, path2, args);
            });
            return result2;
          });
          var keyBy = createAggregator(function(result2, value, key) {
            baseAssignValue(result2, key, value);
          });
          function map(collection, iteratee2) {
            var func = isArray(collection) ? arrayMap : baseMap;
            return func(collection, getIteratee(iteratee2, 3));
          }
          function orderBy(collection, iteratees, orders, guard) {
            if (collection == null) {
              return [];
            }
            if (!isArray(iteratees)) {
              iteratees = iteratees == null ? [] : [iteratees];
            }
            orders = guard ? undefined2 : orders;
            if (!isArray(orders)) {
              orders = orders == null ? [] : [orders];
            }
            return baseOrderBy(collection, iteratees, orders);
          }
          var partition = createAggregator(function(result2, value, key) {
            result2[key ? 0 : 1].push(value);
          }, function() {
            return [[], []];
          });
          function reduce(collection, iteratee2, accumulator) {
            var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
            return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
          }
          function reduceRight(collection, iteratee2, accumulator) {
            var func = isArray(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
            return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
          }
          function reject(collection, predicate) {
            var func = isArray(collection) ? arrayFilter : baseFilter;
            return func(collection, negate(getIteratee(predicate, 3)));
          }
          function sample(collection) {
            var func = isArray(collection) ? arraySample : baseSample;
            return func(collection);
          }
          function sampleSize(collection, n, guard) {
            if (guard ? isIterateeCall(collection, n, guard) : n === undefined2) {
              n = 1;
            } else {
              n = toInteger(n);
            }
            var func = isArray(collection) ? arraySampleSize : baseSampleSize;
            return func(collection, n);
          }
          function shuffle(collection) {
            var func = isArray(collection) ? arrayShuffle : baseShuffle;
            return func(collection);
          }
          function size(collection) {
            if (collection == null) {
              return 0;
            }
            if (isArrayLike(collection)) {
              return isString(collection) ? stringSize(collection) : collection.length;
            }
            var tag = getTag2(collection);
            if (tag == mapTag || tag == setTag) {
              return collection.size;
            }
            return baseKeys(collection).length;
          }
          function some(collection, predicate, guard) {
            var func = isArray(collection) ? arraySome : baseSome;
            if (guard && isIterateeCall(collection, predicate, guard)) {
              predicate = undefined2;
            }
            return func(collection, getIteratee(predicate, 3));
          }
          var sortBy = baseRest(function(collection, iteratees) {
            if (collection == null) {
              return [];
            }
            var length = iteratees.length;
            if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
              iteratees = [];
            } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
              iteratees = [iteratees[0]];
            }
            return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
          });
          var now = ctxNow || function() {
            return root.Date.now();
          };
          function after(n, func) {
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            n = toInteger(n);
            return function() {
              if (--n < 1) {
                return func.apply(this, arguments);
              }
            };
          }
          function ary(func, n, guard) {
            n = guard ? undefined2 : n;
            n = func && n == null ? func.length : n;
            return createWrap(func, WRAP_ARY_FLAG, undefined2, undefined2, undefined2, undefined2, n);
          }
          function before(n, func) {
            var result2;
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            n = toInteger(n);
            return function() {
              if (--n > 0) {
                result2 = func.apply(this, arguments);
              }
              if (n <= 1) {
                func = undefined2;
              }
              return result2;
            };
          }
          var bind = baseRest(function(func, thisArg, partials) {
            var bitmask = WRAP_BIND_FLAG;
            if (partials.length) {
              var holders = replaceHolders(partials, getHolder(bind));
              bitmask |= WRAP_PARTIAL_FLAG;
            }
            return createWrap(func, bitmask, thisArg, partials, holders);
          });
          var bindKey = baseRest(function(object, key, partials) {
            var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
            if (partials.length) {
              var holders = replaceHolders(partials, getHolder(bindKey));
              bitmask |= WRAP_PARTIAL_FLAG;
            }
            return createWrap(key, bitmask, object, partials, holders);
          });
          function curry(func, arity, guard) {
            arity = guard ? undefined2 : arity;
            var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
            result2.placeholder = curry.placeholder;
            return result2;
          }
          function curryRight(func, arity, guard) {
            arity = guard ? undefined2 : arity;
            var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
            result2.placeholder = curryRight.placeholder;
            return result2;
          }
          function debounce(func, wait, options) {
            var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            wait = toNumber(wait) || 0;
            if (isObject2(options)) {
              leading = !!options.leading;
              maxing = "maxWait" in options;
              maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
              trailing = "trailing" in options ? !!options.trailing : trailing;
            }
            function invokeFunc(time) {
              var args = lastArgs, thisArg = lastThis;
              lastArgs = lastThis = undefined2;
              lastInvokeTime = time;
              result2 = func.apply(thisArg, args);
              return result2;
            }
            function leadingEdge(time) {
              lastInvokeTime = time;
              timerId = setTimeout2(timerExpired, wait);
              return leading ? invokeFunc(time) : result2;
            }
            function remainingWait(time) {
              var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
              return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
            }
            function shouldInvoke(time) {
              var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
              return lastCallTime === undefined2 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
            }
            function timerExpired() {
              var time = now();
              if (shouldInvoke(time)) {
                return trailingEdge(time);
              }
              timerId = setTimeout2(timerExpired, remainingWait(time));
            }
            function trailingEdge(time) {
              timerId = undefined2;
              if (trailing && lastArgs) {
                return invokeFunc(time);
              }
              lastArgs = lastThis = undefined2;
              return result2;
            }
            function cancel() {
              if (timerId !== undefined2) {
                clearTimeout2(timerId);
              }
              lastInvokeTime = 0;
              lastArgs = lastCallTime = lastThis = timerId = undefined2;
            }
            function flush() {
              return timerId === undefined2 ? result2 : trailingEdge(now());
            }
            function debounced() {
              var time = now(), isInvoking = shouldInvoke(time);
              lastArgs = arguments;
              lastThis = this;
              lastCallTime = time;
              if (isInvoking) {
                if (timerId === undefined2) {
                  return leadingEdge(lastCallTime);
                }
                if (maxing) {
                  clearTimeout2(timerId);
                  timerId = setTimeout2(timerExpired, wait);
                  return invokeFunc(lastCallTime);
                }
              }
              if (timerId === undefined2) {
                timerId = setTimeout2(timerExpired, wait);
              }
              return result2;
            }
            debounced.cancel = cancel;
            debounced.flush = flush;
            return debounced;
          }
          var defer = baseRest(function(func, args) {
            return baseDelay(func, 1, args);
          });
          var delay = baseRest(function(func, wait, args) {
            return baseDelay(func, toNumber(wait) || 0, args);
          });
          function flip(func) {
            return createWrap(func, WRAP_FLIP_FLAG);
          }
          function memoize(func, resolver) {
            if (typeof func != "function" || resolver != null && typeof resolver != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            var memoized = function() {
              var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
              if (cache.has(key)) {
                return cache.get(key);
              }
              var result2 = func.apply(this, args);
              memoized.cache = cache.set(key, result2) || cache;
              return result2;
            };
            memoized.cache = new (memoize.Cache || MapCache)();
            return memoized;
          }
          memoize.Cache = MapCache;
          function negate(predicate) {
            if (typeof predicate != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            return function() {
              var args = arguments;
              switch (args.length) {
                case 0:
                  return !predicate.call(this);
                case 1:
                  return !predicate.call(this, args[0]);
                case 2:
                  return !predicate.call(this, args[0], args[1]);
                case 3:
                  return !predicate.call(this, args[0], args[1], args[2]);
              }
              return !predicate.apply(this, args);
            };
          }
          function once(func) {
            return before(2, func);
          }
          var overArgs = castRest(function(func, transforms) {
            transforms = transforms.length == 1 && isArray(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
            var funcsLength = transforms.length;
            return baseRest(function(args) {
              var index = -1, length = nativeMin(args.length, funcsLength);
              while (++index < length) {
                args[index] = transforms[index].call(this, args[index]);
              }
              return apply(func, this, args);
            });
          });
          var partial = baseRest(function(func, partials) {
            var holders = replaceHolders(partials, getHolder(partial));
            return createWrap(func, WRAP_PARTIAL_FLAG, undefined2, partials, holders);
          });
          var partialRight = baseRest(function(func, partials) {
            var holders = replaceHolders(partials, getHolder(partialRight));
            return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined2, partials, holders);
          });
          var rearg = flatRest(function(func, indexes) {
            return createWrap(func, WRAP_REARG_FLAG, undefined2, undefined2, undefined2, indexes);
          });
          function rest(func, start) {
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            start = start === undefined2 ? start : toInteger(start);
            return baseRest(func, start);
          }
          function spread(func, start) {
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            start = start == null ? 0 : nativeMax(toInteger(start), 0);
            return baseRest(function(args) {
              var array = args[start], otherArgs = castSlice(args, 0, start);
              if (array) {
                arrayPush(otherArgs, array);
              }
              return apply(func, this, otherArgs);
            });
          }
          function throttle(func, wait, options) {
            var leading = true, trailing = true;
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            if (isObject2(options)) {
              leading = "leading" in options ? !!options.leading : leading;
              trailing = "trailing" in options ? !!options.trailing : trailing;
            }
            return debounce(func, wait, {
              "leading": leading,
              "maxWait": wait,
              "trailing": trailing
            });
          }
          function unary(func) {
            return ary(func, 1);
          }
          function wrap(value, wrapper) {
            return partial(castFunction(wrapper), value);
          }
          function castArray() {
            if (!arguments.length) {
              return [];
            }
            var value = arguments[0];
            return isArray(value) ? value : [value];
          }
          function clone(value) {
            return baseClone(value, CLONE_SYMBOLS_FLAG);
          }
          function cloneWith(value, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
          }
          function cloneDeep2(value) {
            return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
          }
          function cloneDeepWith(value, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
          }
          function conformsTo(object, source) {
            return source == null || baseConformsTo(object, source, keys(source));
          }
          function eq(value, other) {
            return value === other || value !== value && other !== other;
          }
          var gt = createRelationalOperation(baseGt);
          var gte = createRelationalOperation(function(value, other) {
            return value >= other;
          });
          var isArguments = baseIsArguments(function() {
            return arguments;
          }()) ? baseIsArguments : function(value) {
            return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
          };
          var isArray = Array2.isArray;
          var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
          function isArrayLike(value) {
            return value != null && isLength(value.length) && !isFunction(value);
          }
          function isArrayLikeObject(value) {
            return isObjectLike(value) && isArrayLike(value);
          }
          function isBoolean(value) {
            return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
          }
          var isBuffer = nativeIsBuffer || stubFalse;
          var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
          function isElement(value) {
            return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
          }
          function isEmpty(value) {
            if (value == null) {
              return true;
            }
            if (isArrayLike(value) && (isArray(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
              return !value.length;
            }
            var tag = getTag2(value);
            if (tag == mapTag || tag == setTag) {
              return !value.size;
            }
            if (isPrototype(value)) {
              return !baseKeys(value).length;
            }
            for (var key in value) {
              if (hasOwnProperty.call(value, key)) {
                return false;
              }
            }
            return true;
          }
          function isEqual(value, other) {
            return baseIsEqual(value, other);
          }
          function isEqualWith(value, other, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            var result2 = customizer ? customizer(value, other) : undefined2;
            return result2 === undefined2 ? baseIsEqual(value, other, undefined2, customizer) : !!result2;
          }
          function isError(value) {
            if (!isObjectLike(value)) {
              return false;
            }
            var tag = baseGetTag(value);
            return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject(value);
          }
          function isFinite2(value) {
            return typeof value == "number" && nativeIsFinite(value);
          }
          function isFunction(value) {
            if (!isObject2(value)) {
              return false;
            }
            var tag = baseGetTag(value);
            return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
          }
          function isInteger(value) {
            return typeof value == "number" && value == toInteger(value);
          }
          function isLength(value) {
            return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
          }
          function isObject2(value) {
            var type = typeof value;
            return value != null && (type == "object" || type == "function");
          }
          function isObjectLike(value) {
            return value != null && typeof value == "object";
          }
          var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
          function isMatch(object, source) {
            return object === source || baseIsMatch(object, source, getMatchData(source));
          }
          function isMatchWith(object, source, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            return baseIsMatch(object, source, getMatchData(source), customizer);
          }
          function isNaN2(value) {
            return isNumber(value) && value != +value;
          }
          function isNative(value) {
            if (isMaskable(value)) {
              throw new Error2(CORE_ERROR_TEXT);
            }
            return baseIsNative(value);
          }
          function isNull(value) {
            return value === null;
          }
          function isNil(value) {
            return value == null;
          }
          function isNumber(value) {
            return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
          }
          function isPlainObject(value) {
            if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
              return false;
            }
            var proto = getPrototype(value);
            if (proto === null) {
              return true;
            }
            var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
            return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
          }
          var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
          function isSafeInteger(value) {
            return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
          }
          var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
          function isString(value) {
            return typeof value == "string" || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
          }
          function isSymbol(value) {
            return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
          }
          var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
          function isUndefined(value) {
            return value === undefined2;
          }
          function isWeakMap(value) {
            return isObjectLike(value) && getTag2(value) == weakMapTag;
          }
          function isWeakSet(value) {
            return isObjectLike(value) && baseGetTag(value) == weakSetTag;
          }
          var lt = createRelationalOperation(baseLt);
          var lte = createRelationalOperation(function(value, other) {
            return value <= other;
          });
          function toArray(value) {
            if (!value) {
              return [];
            }
            if (isArrayLike(value)) {
              return isString(value) ? stringToArray(value) : copyArray(value);
            }
            if (symIterator && value[symIterator]) {
              return iteratorToArray(value[symIterator]());
            }
            var tag = getTag2(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
            return func(value);
          }
          function toFinite(value) {
            if (!value) {
              return value === 0 ? value : 0;
            }
            value = toNumber(value);
            if (value === INFINITY || value === -INFINITY) {
              var sign = value < 0 ? -1 : 1;
              return sign * MAX_INTEGER;
            }
            return value === value ? value : 0;
          }
          function toInteger(value) {
            var result2 = toFinite(value), remainder = result2 % 1;
            return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
          }
          function toLength(value) {
            return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
          }
          function toNumber(value) {
            if (typeof value == "number") {
              return value;
            }
            if (isSymbol(value)) {
              return NAN;
            }
            if (isObject2(value)) {
              var other = typeof value.valueOf == "function" ? value.valueOf() : value;
              value = isObject2(other) ? other + "" : other;
            }
            if (typeof value != "string") {
              return value === 0 ? value : +value;
            }
            value = baseTrim(value);
            var isBinary = reIsBinary.test(value);
            return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
          }
          function toPlainObject(value) {
            return copyObject(value, keysIn(value));
          }
          function toSafeInteger(value) {
            return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
          }
          function toString2(value) {
            return value == null ? "" : baseToString(value);
          }
          var assign = createAssigner(function(object, source) {
            if (isPrototype(source) || isArrayLike(source)) {
              copyObject(source, keys(source), object);
              return;
            }
            for (var key in source) {
              if (hasOwnProperty.call(source, key)) {
                assignValue(object, key, source[key]);
              }
            }
          });
          var assignIn = createAssigner(function(object, source) {
            copyObject(source, keysIn(source), object);
          });
          var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
            copyObject(source, keysIn(source), object, customizer);
          });
          var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
            copyObject(source, keys(source), object, customizer);
          });
          var at = flatRest(baseAt);
          function create(prototype, properties) {
            var result2 = baseCreate(prototype);
            return properties == null ? result2 : baseAssign(result2, properties);
          }
          var defaults = baseRest(function(object, sources) {
            object = Object2(object);
            var index = -1;
            var length = sources.length;
            var guard = length > 2 ? sources[2] : undefined2;
            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
              length = 1;
            }
            while (++index < length) {
              var source = sources[index];
              var props = keysIn(source);
              var propsIndex = -1;
              var propsLength = props.length;
              while (++propsIndex < propsLength) {
                var key = props[propsIndex];
                var value = object[key];
                if (value === undefined2 || eq(value, objectProto[key]) && !hasOwnProperty.call(object, key)) {
                  object[key] = source[key];
                }
              }
            }
            return object;
          });
          var defaultsDeep = baseRest(function(args) {
            args.push(undefined2, customDefaultsMerge);
            return apply(mergeWith, undefined2, args);
          });
          function findKey(object, predicate) {
            return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
          }
          function findLastKey(object, predicate) {
            return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
          }
          function forIn(object, iteratee2) {
            return object == null ? object : baseFor(object, getIteratee(iteratee2, 3), keysIn);
          }
          function forInRight(object, iteratee2) {
            return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn);
          }
          function forOwn(object, iteratee2) {
            return object && baseForOwn(object, getIteratee(iteratee2, 3));
          }
          function forOwnRight(object, iteratee2) {
            return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
          }
          function functions(object) {
            return object == null ? [] : baseFunctions(object, keys(object));
          }
          function functionsIn(object) {
            return object == null ? [] : baseFunctions(object, keysIn(object));
          }
          function get(object, path2, defaultValue) {
            var result2 = object == null ? undefined2 : baseGet(object, path2);
            return result2 === undefined2 ? defaultValue : result2;
          }
          function has(object, path2) {
            return object != null && hasPath(object, path2, baseHas);
          }
          function hasIn(object, path2) {
            return object != null && hasPath(object, path2, baseHasIn);
          }
          var invert = createInverter(function(result2, value, key) {
            if (value != null && typeof value.toString != "function") {
              value = nativeObjectToString.call(value);
            }
            result2[value] = key;
          }, constant(identity));
          var invertBy = createInverter(function(result2, value, key) {
            if (value != null && typeof value.toString != "function") {
              value = nativeObjectToString.call(value);
            }
            if (hasOwnProperty.call(result2, value)) {
              result2[value].push(key);
            } else {
              result2[value] = [key];
            }
          }, getIteratee);
          var invoke = baseRest(baseInvoke);
          function keys(object) {
            return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
          }
          function keysIn(object) {
            return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
          }
          function mapKeys(object, iteratee2) {
            var result2 = {};
            iteratee2 = getIteratee(iteratee2, 3);
            baseForOwn(object, function(value, key, object2) {
              baseAssignValue(result2, iteratee2(value, key, object2), value);
            });
            return result2;
          }
          function mapValues(object, iteratee2) {
            var result2 = {};
            iteratee2 = getIteratee(iteratee2, 3);
            baseForOwn(object, function(value, key, object2) {
              baseAssignValue(result2, key, iteratee2(value, key, object2));
            });
            return result2;
          }
          var merge = createAssigner(function(object, source, srcIndex) {
            baseMerge(object, source, srcIndex);
          });
          var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
            baseMerge(object, source, srcIndex, customizer);
          });
          var omit = flatRest(function(object, paths) {
            var result2 = {};
            if (object == null) {
              return result2;
            }
            var isDeep = false;
            paths = arrayMap(paths, function(path2) {
              path2 = castPath(path2, object);
              isDeep || (isDeep = path2.length > 1);
              return path2;
            });
            copyObject(object, getAllKeysIn(object), result2);
            if (isDeep) {
              result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
            }
            var length = paths.length;
            while (length--) {
              baseUnset(result2, paths[length]);
            }
            return result2;
          });
          function omitBy(object, predicate) {
            return pickBy(object, negate(getIteratee(predicate)));
          }
          var pick = flatRest(function(object, paths) {
            return object == null ? {} : basePick(object, paths);
          });
          function pickBy(object, predicate) {
            if (object == null) {
              return {};
            }
            var props = arrayMap(getAllKeysIn(object), function(prop) {
              return [prop];
            });
            predicate = getIteratee(predicate);
            return basePickBy(object, props, function(value, path2) {
              return predicate(value, path2[0]);
            });
          }
          function result(object, path2, defaultValue) {
            path2 = castPath(path2, object);
            var index = -1, length = path2.length;
            if (!length) {
              length = 1;
              object = undefined2;
            }
            while (++index < length) {
              var value = object == null ? undefined2 : object[toKey(path2[index])];
              if (value === undefined2) {
                index = length;
                value = defaultValue;
              }
              object = isFunction(value) ? value.call(object) : value;
            }
            return object;
          }
          function set(object, path2, value) {
            return object == null ? object : baseSet(object, path2, value);
          }
          function setWith(object, path2, value, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            return object == null ? object : baseSet(object, path2, value, customizer);
          }
          var toPairs = createToPairs(keys);
          var toPairsIn = createToPairs(keysIn);
          function transform(object, iteratee2, accumulator) {
            var isArr = isArray(object), isArrLike = isArr || isBuffer(object) || isTypedArray(object);
            iteratee2 = getIteratee(iteratee2, 4);
            if (accumulator == null) {
              var Ctor = object && object.constructor;
              if (isArrLike) {
                accumulator = isArr ? new Ctor() : [];
              } else if (isObject2(object)) {
                accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
              } else {
                accumulator = {};
              }
            }
            (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object2) {
              return iteratee2(accumulator, value, index, object2);
            });
            return accumulator;
          }
          function unset(object, path2) {
            return object == null ? true : baseUnset(object, path2);
          }
          function update(object, path2, updater) {
            return object == null ? object : baseUpdate(object, path2, castFunction(updater));
          }
          function updateWith(object, path2, updater, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            return object == null ? object : baseUpdate(object, path2, castFunction(updater), customizer);
          }
          function values(object) {
            return object == null ? [] : baseValues(object, keys(object));
          }
          function valuesIn(object) {
            return object == null ? [] : baseValues(object, keysIn(object));
          }
          function clamp(number, lower, upper) {
            if (upper === undefined2) {
              upper = lower;
              lower = undefined2;
            }
            if (upper !== undefined2) {
              upper = toNumber(upper);
              upper = upper === upper ? upper : 0;
            }
            if (lower !== undefined2) {
              lower = toNumber(lower);
              lower = lower === lower ? lower : 0;
            }
            return baseClamp(toNumber(number), lower, upper);
          }
          function inRange(number, start, end) {
            start = toFinite(start);
            if (end === undefined2) {
              end = start;
              start = 0;
            } else {
              end = toFinite(end);
            }
            number = toNumber(number);
            return baseInRange(number, start, end);
          }
          function random(lower, upper, floating) {
            if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
              upper = floating = undefined2;
            }
            if (floating === undefined2) {
              if (typeof upper == "boolean") {
                floating = upper;
                upper = undefined2;
              } else if (typeof lower == "boolean") {
                floating = lower;
                lower = undefined2;
              }
            }
            if (lower === undefined2 && upper === undefined2) {
              lower = 0;
              upper = 1;
            } else {
              lower = toFinite(lower);
              if (upper === undefined2) {
                upper = lower;
                lower = 0;
              } else {
                upper = toFinite(upper);
              }
            }
            if (lower > upper) {
              var temp = lower;
              lower = upper;
              upper = temp;
            }
            if (floating || lower % 1 || upper % 1) {
              var rand = nativeRandom();
              return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
            }
            return baseRandom(lower, upper);
          }
          var camelCase = createCompounder(function(result2, word, index) {
            word = word.toLowerCase();
            return result2 + (index ? capitalize(word) : word);
          });
          function capitalize(string) {
            return upperFirst(toString2(string).toLowerCase());
          }
          function deburr(string) {
            string = toString2(string);
            return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
          }
          function endsWith(string, target, position) {
            string = toString2(string);
            target = baseToString(target);
            var length = string.length;
            position = position === undefined2 ? length : baseClamp(toInteger(position), 0, length);
            var end = position;
            position -= target.length;
            return position >= 0 && string.slice(position, end) == target;
          }
          function escape(string) {
            string = toString2(string);
            return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
          }
          function escapeRegExp(string) {
            string = toString2(string);
            return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
          }
          var kebabCase = createCompounder(function(result2, word, index) {
            return result2 + (index ? "-" : "") + word.toLowerCase();
          });
          var lowerCase = createCompounder(function(result2, word, index) {
            return result2 + (index ? " " : "") + word.toLowerCase();
          });
          var lowerFirst = createCaseFirst("toLowerCase");
          function pad(string, length, chars) {
            string = toString2(string);
            length = toInteger(length);
            var strLength = length ? stringSize(string) : 0;
            if (!length || strLength >= length) {
              return string;
            }
            var mid = (length - strLength) / 2;
            return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
          }
          function padEnd(string, length, chars) {
            string = toString2(string);
            length = toInteger(length);
            var strLength = length ? stringSize(string) : 0;
            return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
          }
          function padStart(string, length, chars) {
            string = toString2(string);
            length = toInteger(length);
            var strLength = length ? stringSize(string) : 0;
            return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
          }
          function parseInt3(string, radix, guard) {
            if (guard || radix == null) {
              radix = 0;
            } else if (radix) {
              radix = +radix;
            }
            return nativeParseInt(toString2(string).replace(reTrimStart, ""), radix || 0);
          }
          function repeat(string, n, guard) {
            if (guard ? isIterateeCall(string, n, guard) : n === undefined2) {
              n = 1;
            } else {
              n = toInteger(n);
            }
            return baseRepeat(toString2(string), n);
          }
          function replace() {
            var args = arguments, string = toString2(args[0]);
            return args.length < 3 ? string : string.replace(args[1], args[2]);
          }
          var snakeCase = createCompounder(function(result2, word, index) {
            return result2 + (index ? "_" : "") + word.toLowerCase();
          });
          function split(string, separator, limit) {
            if (limit && typeof limit != "number" && isIterateeCall(string, separator, limit)) {
              separator = limit = undefined2;
            }
            limit = limit === undefined2 ? MAX_ARRAY_LENGTH : limit >>> 0;
            if (!limit) {
              return [];
            }
            string = toString2(string);
            if (string && (typeof separator == "string" || separator != null && !isRegExp(separator))) {
              separator = baseToString(separator);
              if (!separator && hasUnicode(string)) {
                return castSlice(stringToArray(string), 0, limit);
              }
            }
            return string.split(separator, limit);
          }
          var startCase = createCompounder(function(result2, word, index) {
            return result2 + (index ? " " : "") + upperFirst(word);
          });
          function startsWith(string, target, position) {
            string = toString2(string);
            position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length);
            target = baseToString(target);
            return string.slice(position, position + target.length) == target;
          }
          function template(string, options, guard) {
            var settings = lodash.templateSettings;
            if (guard && isIterateeCall(string, options, guard)) {
              options = undefined2;
            }
            string = toString2(string);
            options = assignInWith({}, options, settings, customDefaultsAssignIn);
            var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
            var isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
            var reDelimiters = RegExp2((options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$", "g");
            var sourceURL = "//# sourceURL=" + (hasOwnProperty.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
            string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
              interpolateValue || (interpolateValue = esTemplateValue);
              source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);
              if (escapeValue) {
                isEscaping = true;
                source += "' +\n__e(" + escapeValue + ") +\n'";
              }
              if (evaluateValue) {
                isEvaluating = true;
                source += "';\n" + evaluateValue + ";\n__p += '";
              }
              if (interpolateValue) {
                source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
              }
              index = offset + match.length;
              return match;
            });
            source += "';\n";
            var variable = hasOwnProperty.call(options, "variable") && options.variable;
            if (!variable) {
              source = "with (obj) {\n" + source + "\n}\n";
            } else if (reForbiddenIdentifierChars.test(variable)) {
              throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
            }
            source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
            source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
            var result2 = attempt(function() {
              return Function2(importsKeys, sourceURL + "return " + source).apply(undefined2, importsValues);
            });
            result2.source = source;
            if (isError(result2)) {
              throw result2;
            }
            return result2;
          }
          function toLower(value) {
            return toString2(value).toLowerCase();
          }
          function toUpper(value) {
            return toString2(value).toUpperCase();
          }
          function trim(string, chars, guard) {
            string = toString2(string);
            if (string && (guard || chars === undefined2)) {
              return baseTrim(string);
            }
            if (!string || !(chars = baseToString(chars))) {
              return string;
            }
            var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
            return castSlice(strSymbols, start, end).join("");
          }
          function trimEnd(string, chars, guard) {
            string = toString2(string);
            if (string && (guard || chars === undefined2)) {
              return string.slice(0, trimmedEndIndex(string) + 1);
            }
            if (!string || !(chars = baseToString(chars))) {
              return string;
            }
            var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
            return castSlice(strSymbols, 0, end).join("");
          }
          function trimStart(string, chars, guard) {
            string = toString2(string);
            if (string && (guard || chars === undefined2)) {
              return string.replace(reTrimStart, "");
            }
            if (!string || !(chars = baseToString(chars))) {
              return string;
            }
            var strSymbols = stringToArray(string), start = charsStartIndex(strSymbols, stringToArray(chars));
            return castSlice(strSymbols, start).join("");
          }
          function truncate(string, options) {
            var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
            if (isObject2(options)) {
              var separator = "separator" in options ? options.separator : separator;
              length = "length" in options ? toInteger(options.length) : length;
              omission = "omission" in options ? baseToString(options.omission) : omission;
            }
            string = toString2(string);
            var strLength = string.length;
            if (hasUnicode(string)) {
              var strSymbols = stringToArray(string);
              strLength = strSymbols.length;
            }
            if (length >= strLength) {
              return string;
            }
            var end = length - stringSize(omission);
            if (end < 1) {
              return omission;
            }
            var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string.slice(0, end);
            if (separator === undefined2) {
              return result2 + omission;
            }
            if (strSymbols) {
              end += result2.length - end;
            }
            if (isRegExp(separator)) {
              if (string.slice(end).search(separator)) {
                var match, substring = result2;
                if (!separator.global) {
                  separator = RegExp2(separator.source, toString2(reFlags.exec(separator)) + "g");
                }
                separator.lastIndex = 0;
                while (match = separator.exec(substring)) {
                  var newEnd = match.index;
                }
                result2 = result2.slice(0, newEnd === undefined2 ? end : newEnd);
              }
            } else if (string.indexOf(baseToString(separator), end) != end) {
              var index = result2.lastIndexOf(separator);
              if (index > -1) {
                result2 = result2.slice(0, index);
              }
            }
            return result2 + omission;
          }
          function unescape2(string) {
            string = toString2(string);
            return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
          }
          var upperCase = createCompounder(function(result2, word, index) {
            return result2 + (index ? " " : "") + word.toUpperCase();
          });
          var upperFirst = createCaseFirst("toUpperCase");
          function words(string, pattern, guard) {
            string = toString2(string);
            pattern = guard ? undefined2 : pattern;
            if (pattern === undefined2) {
              return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
            }
            return string.match(pattern) || [];
          }
          var attempt = baseRest(function(func, args) {
            try {
              return apply(func, undefined2, args);
            } catch (e) {
              return isError(e) ? e : new Error2(e);
            }
          });
          var bindAll = flatRest(function(object, methodNames) {
            arrayEach(methodNames, function(key) {
              key = toKey(key);
              baseAssignValue(object, key, bind(object[key], object));
            });
            return object;
          });
          function cond(pairs) {
            var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
            pairs = !length ? [] : arrayMap(pairs, function(pair) {
              if (typeof pair[1] != "function") {
                throw new TypeError2(FUNC_ERROR_TEXT);
              }
              return [toIteratee(pair[0]), pair[1]];
            });
            return baseRest(function(args) {
              var index = -1;
              while (++index < length) {
                var pair = pairs[index];
                if (apply(pair[0], this, args)) {
                  return apply(pair[1], this, args);
                }
              }
            });
          }
          function conforms(source) {
            return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
          }
          function constant(value) {
            return function() {
              return value;
            };
          }
          function defaultTo(value, defaultValue) {
            return value == null || value !== value ? defaultValue : value;
          }
          var flow = createFlow();
          var flowRight = createFlow(true);
          function identity(value) {
            return value;
          }
          function iteratee(func) {
            return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
          }
          function matches(source) {
            return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
          }
          function matchesProperty(path2, srcValue) {
            return baseMatchesProperty(path2, baseClone(srcValue, CLONE_DEEP_FLAG));
          }
          var method = baseRest(function(path2, args) {
            return function(object) {
              return baseInvoke(object, path2, args);
            };
          });
          var methodOf = baseRest(function(object, args) {
            return function(path2) {
              return baseInvoke(object, path2, args);
            };
          });
          function mixin(object, source, options) {
            var props = keys(source), methodNames = baseFunctions(source, props);
            if (options == null && !(isObject2(source) && (methodNames.length || !props.length))) {
              options = source;
              source = object;
              object = this;
              methodNames = baseFunctions(source, keys(source));
            }
            var chain2 = !(isObject2(options) && "chain" in options) || !!options.chain, isFunc = isFunction(object);
            arrayEach(methodNames, function(methodName) {
              var func = source[methodName];
              object[methodName] = func;
              if (isFunc) {
                object.prototype[methodName] = function() {
                  var chainAll = this.__chain__;
                  if (chain2 || chainAll) {
                    var result2 = object(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);
                    actions.push({ "func": func, "args": arguments, "thisArg": object });
                    result2.__chain__ = chainAll;
                    return result2;
                  }
                  return func.apply(object, arrayPush([this.value()], arguments));
                };
              }
            });
            return object;
          }
          function noConflict() {
            if (root._ === this) {
              root._ = oldDash;
            }
            return this;
          }
          function noop() {
          }
          function nthArg(n) {
            n = toInteger(n);
            return baseRest(function(args) {
              return baseNth(args, n);
            });
          }
          var over = createOver(arrayMap);
          var overEvery = createOver(arrayEvery);
          var overSome = createOver(arraySome);
          function property(path2) {
            return isKey(path2) ? baseProperty(toKey(path2)) : basePropertyDeep(path2);
          }
          function propertyOf(object) {
            return function(path2) {
              return object == null ? undefined2 : baseGet(object, path2);
            };
          }
          var range = createRange();
          var rangeRight = createRange(true);
          function stubArray() {
            return [];
          }
          function stubFalse() {
            return false;
          }
          function stubObject() {
            return {};
          }
          function stubString() {
            return "";
          }
          function stubTrue() {
            return true;
          }
          function times(n, iteratee2) {
            n = toInteger(n);
            if (n < 1 || n > MAX_SAFE_INTEGER) {
              return [];
            }
            var index = MAX_ARRAY_LENGTH, length = nativeMin(n, MAX_ARRAY_LENGTH);
            iteratee2 = getIteratee(iteratee2);
            n -= MAX_ARRAY_LENGTH;
            var result2 = baseTimes(length, iteratee2);
            while (++index < n) {
              iteratee2(index);
            }
            return result2;
          }
          function toPath(value) {
            if (isArray(value)) {
              return arrayMap(value, toKey);
            }
            return isSymbol(value) ? [value] : copyArray(stringToPath(toString2(value)));
          }
          function uniqueId(prefix) {
            var id = ++idCounter;
            return toString2(prefix) + id;
          }
          var add = createMathOperation(function(augend, addend) {
            return augend + addend;
          }, 0);
          var ceil = createRound("ceil");
          var divide = createMathOperation(function(dividend, divisor) {
            return dividend / divisor;
          }, 1);
          var floor = createRound("floor");
          function max(array) {
            return array && array.length ? baseExtremum(array, identity, baseGt) : undefined2;
          }
          function maxBy(array, iteratee2) {
            return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseGt) : undefined2;
          }
          function mean(array) {
            return baseMean(array, identity);
          }
          function meanBy(array, iteratee2) {
            return baseMean(array, getIteratee(iteratee2, 2));
          }
          function min(array) {
            return array && array.length ? baseExtremum(array, identity, baseLt) : undefined2;
          }
          function minBy(array, iteratee2) {
            return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseLt) : undefined2;
          }
          var multiply = createMathOperation(function(multiplier, multiplicand) {
            return multiplier * multiplicand;
          }, 1);
          var round = createRound("round");
          var subtract = createMathOperation(function(minuend, subtrahend) {
            return minuend - subtrahend;
          }, 0);
          function sum(array) {
            return array && array.length ? baseSum(array, identity) : 0;
          }
          function sumBy(array, iteratee2) {
            return array && array.length ? baseSum(array, getIteratee(iteratee2, 2)) : 0;
          }
          lodash.after = after;
          lodash.ary = ary;
          lodash.assign = assign;
          lodash.assignIn = assignIn;
          lodash.assignInWith = assignInWith;
          lodash.assignWith = assignWith;
          lodash.at = at;
          lodash.before = before;
          lodash.bind = bind;
          lodash.bindAll = bindAll;
          lodash.bindKey = bindKey;
          lodash.castArray = castArray;
          lodash.chain = chain;
          lodash.chunk = chunk;
          lodash.compact = compact;
          lodash.concat = concat;
          lodash.cond = cond;
          lodash.conforms = conforms;
          lodash.constant = constant;
          lodash.countBy = countBy;
          lodash.create = create;
          lodash.curry = curry;
          lodash.curryRight = curryRight;
          lodash.debounce = debounce;
          lodash.defaults = defaults;
          lodash.defaultsDeep = defaultsDeep;
          lodash.defer = defer;
          lodash.delay = delay;
          lodash.difference = difference;
          lodash.differenceBy = differenceBy;
          lodash.differenceWith = differenceWith;
          lodash.drop = drop;
          lodash.dropRight = dropRight;
          lodash.dropRightWhile = dropRightWhile;
          lodash.dropWhile = dropWhile;
          lodash.fill = fill;
          lodash.filter = filter;
          lodash.flatMap = flatMap;
          lodash.flatMapDeep = flatMapDeep;
          lodash.flatMapDepth = flatMapDepth;
          lodash.flatten = flatten;
          lodash.flattenDeep = flattenDeep;
          lodash.flattenDepth = flattenDepth;
          lodash.flip = flip;
          lodash.flow = flow;
          lodash.flowRight = flowRight;
          lodash.fromPairs = fromPairs;
          lodash.functions = functions;
          lodash.functionsIn = functionsIn;
          lodash.groupBy = groupBy;
          lodash.initial = initial;
          lodash.intersection = intersection;
          lodash.intersectionBy = intersectionBy;
          lodash.intersectionWith = intersectionWith;
          lodash.invert = invert;
          lodash.invertBy = invertBy;
          lodash.invokeMap = invokeMap;
          lodash.iteratee = iteratee;
          lodash.keyBy = keyBy;
          lodash.keys = keys;
          lodash.keysIn = keysIn;
          lodash.map = map;
          lodash.mapKeys = mapKeys;
          lodash.mapValues = mapValues;
          lodash.matches = matches;
          lodash.matchesProperty = matchesProperty;
          lodash.memoize = memoize;
          lodash.merge = merge;
          lodash.mergeWith = mergeWith;
          lodash.method = method;
          lodash.methodOf = methodOf;
          lodash.mixin = mixin;
          lodash.negate = negate;
          lodash.nthArg = nthArg;
          lodash.omit = omit;
          lodash.omitBy = omitBy;
          lodash.once = once;
          lodash.orderBy = orderBy;
          lodash.over = over;
          lodash.overArgs = overArgs;
          lodash.overEvery = overEvery;
          lodash.overSome = overSome;
          lodash.partial = partial;
          lodash.partialRight = partialRight;
          lodash.partition = partition;
          lodash.pick = pick;
          lodash.pickBy = pickBy;
          lodash.property = property;
          lodash.propertyOf = propertyOf;
          lodash.pull = pull;
          lodash.pullAll = pullAll;
          lodash.pullAllBy = pullAllBy;
          lodash.pullAllWith = pullAllWith;
          lodash.pullAt = pullAt;
          lodash.range = range;
          lodash.rangeRight = rangeRight;
          lodash.rearg = rearg;
          lodash.reject = reject;
          lodash.remove = remove;
          lodash.rest = rest;
          lodash.reverse = reverse;
          lodash.sampleSize = sampleSize;
          lodash.set = set;
          lodash.setWith = setWith;
          lodash.shuffle = shuffle;
          lodash.slice = slice;
          lodash.sortBy = sortBy;
          lodash.sortedUniq = sortedUniq;
          lodash.sortedUniqBy = sortedUniqBy;
          lodash.split = split;
          lodash.spread = spread;
          lodash.tail = tail;
          lodash.take = take;
          lodash.takeRight = takeRight;
          lodash.takeRightWhile = takeRightWhile;
          lodash.takeWhile = takeWhile;
          lodash.tap = tap;
          lodash.throttle = throttle;
          lodash.thru = thru;
          lodash.toArray = toArray;
          lodash.toPairs = toPairs;
          lodash.toPairsIn = toPairsIn;
          lodash.toPath = toPath;
          lodash.toPlainObject = toPlainObject;
          lodash.transform = transform;
          lodash.unary = unary;
          lodash.union = union;
          lodash.unionBy = unionBy;
          lodash.unionWith = unionWith;
          lodash.uniq = uniq;
          lodash.uniqBy = uniqBy;
          lodash.uniqWith = uniqWith;
          lodash.unset = unset;
          lodash.unzip = unzip2;
          lodash.unzipWith = unzipWith;
          lodash.update = update;
          lodash.updateWith = updateWith;
          lodash.values = values;
          lodash.valuesIn = valuesIn;
          lodash.without = without;
          lodash.words = words;
          lodash.wrap = wrap;
          lodash.xor = xor;
          lodash.xorBy = xorBy;
          lodash.xorWith = xorWith;
          lodash.zip = zip;
          lodash.zipObject = zipObject;
          lodash.zipObjectDeep = zipObjectDeep;
          lodash.zipWith = zipWith;
          lodash.entries = toPairs;
          lodash.entriesIn = toPairsIn;
          lodash.extend = assignIn;
          lodash.extendWith = assignInWith;
          mixin(lodash, lodash);
          lodash.add = add;
          lodash.attempt = attempt;
          lodash.camelCase = camelCase;
          lodash.capitalize = capitalize;
          lodash.ceil = ceil;
          lodash.clamp = clamp;
          lodash.clone = clone;
          lodash.cloneDeep = cloneDeep2;
          lodash.cloneDeepWith = cloneDeepWith;
          lodash.cloneWith = cloneWith;
          lodash.conformsTo = conformsTo;
          lodash.deburr = deburr;
          lodash.defaultTo = defaultTo;
          lodash.divide = divide;
          lodash.endsWith = endsWith;
          lodash.eq = eq;
          lodash.escape = escape;
          lodash.escapeRegExp = escapeRegExp;
          lodash.every = every;
          lodash.find = find;
          lodash.findIndex = findIndex;
          lodash.findKey = findKey;
          lodash.findLast = findLast;
          lodash.findLastIndex = findLastIndex;
          lodash.findLastKey = findLastKey;
          lodash.floor = floor;
          lodash.forEach = forEach;
          lodash.forEachRight = forEachRight;
          lodash.forIn = forIn;
          lodash.forInRight = forInRight;
          lodash.forOwn = forOwn;
          lodash.forOwnRight = forOwnRight;
          lodash.get = get;
          lodash.gt = gt;
          lodash.gte = gte;
          lodash.has = has;
          lodash.hasIn = hasIn;
          lodash.head = head;
          lodash.identity = identity;
          lodash.includes = includes;
          lodash.indexOf = indexOf;
          lodash.inRange = inRange;
          lodash.invoke = invoke;
          lodash.isArguments = isArguments;
          lodash.isArray = isArray;
          lodash.isArrayBuffer = isArrayBuffer;
          lodash.isArrayLike = isArrayLike;
          lodash.isArrayLikeObject = isArrayLikeObject;
          lodash.isBoolean = isBoolean;
          lodash.isBuffer = isBuffer;
          lodash.isDate = isDate;
          lodash.isElement = isElement;
          lodash.isEmpty = isEmpty;
          lodash.isEqual = isEqual;
          lodash.isEqualWith = isEqualWith;
          lodash.isError = isError;
          lodash.isFinite = isFinite2;
          lodash.isFunction = isFunction;
          lodash.isInteger = isInteger;
          lodash.isLength = isLength;
          lodash.isMap = isMap;
          lodash.isMatch = isMatch;
          lodash.isMatchWith = isMatchWith;
          lodash.isNaN = isNaN2;
          lodash.isNative = isNative;
          lodash.isNil = isNil;
          lodash.isNull = isNull;
          lodash.isNumber = isNumber;
          lodash.isObject = isObject2;
          lodash.isObjectLike = isObjectLike;
          lodash.isPlainObject = isPlainObject;
          lodash.isRegExp = isRegExp;
          lodash.isSafeInteger = isSafeInteger;
          lodash.isSet = isSet;
          lodash.isString = isString;
          lodash.isSymbol = isSymbol;
          lodash.isTypedArray = isTypedArray;
          lodash.isUndefined = isUndefined;
          lodash.isWeakMap = isWeakMap;
          lodash.isWeakSet = isWeakSet;
          lodash.join = join;
          lodash.kebabCase = kebabCase;
          lodash.last = last;
          lodash.lastIndexOf = lastIndexOf;
          lodash.lowerCase = lowerCase;
          lodash.lowerFirst = lowerFirst;
          lodash.lt = lt;
          lodash.lte = lte;
          lodash.max = max;
          lodash.maxBy = maxBy;
          lodash.mean = mean;
          lodash.meanBy = meanBy;
          lodash.min = min;
          lodash.minBy = minBy;
          lodash.stubArray = stubArray;
          lodash.stubFalse = stubFalse;
          lodash.stubObject = stubObject;
          lodash.stubString = stubString;
          lodash.stubTrue = stubTrue;
          lodash.multiply = multiply;
          lodash.nth = nth;
          lodash.noConflict = noConflict;
          lodash.noop = noop;
          lodash.now = now;
          lodash.pad = pad;
          lodash.padEnd = padEnd;
          lodash.padStart = padStart;
          lodash.parseInt = parseInt3;
          lodash.random = random;
          lodash.reduce = reduce;
          lodash.reduceRight = reduceRight;
          lodash.repeat = repeat;
          lodash.replace = replace;
          lodash.result = result;
          lodash.round = round;
          lodash.runInContext = runInContext2;
          lodash.sample = sample;
          lodash.size = size;
          lodash.snakeCase = snakeCase;
          lodash.some = some;
          lodash.sortedIndex = sortedIndex;
          lodash.sortedIndexBy = sortedIndexBy;
          lodash.sortedIndexOf = sortedIndexOf;
          lodash.sortedLastIndex = sortedLastIndex;
          lodash.sortedLastIndexBy = sortedLastIndexBy;
          lodash.sortedLastIndexOf = sortedLastIndexOf;
          lodash.startCase = startCase;
          lodash.startsWith = startsWith;
          lodash.subtract = subtract;
          lodash.sum = sum;
          lodash.sumBy = sumBy;
          lodash.template = template;
          lodash.times = times;
          lodash.toFinite = toFinite;
          lodash.toInteger = toInteger;
          lodash.toLength = toLength;
          lodash.toLower = toLower;
          lodash.toNumber = toNumber;
          lodash.toSafeInteger = toSafeInteger;
          lodash.toString = toString2;
          lodash.toUpper = toUpper;
          lodash.trim = trim;
          lodash.trimEnd = trimEnd;
          lodash.trimStart = trimStart;
          lodash.truncate = truncate;
          lodash.unescape = unescape2;
          lodash.uniqueId = uniqueId;
          lodash.upperCase = upperCase;
          lodash.upperFirst = upperFirst;
          lodash.each = forEach;
          lodash.eachRight = forEachRight;
          lodash.first = head;
          mixin(lodash, function() {
            var source = {};
            baseForOwn(lodash, function(func, methodName) {
              if (!hasOwnProperty.call(lodash.prototype, methodName)) {
                source[methodName] = func;
              }
            });
            return source;
          }(), { "chain": false });
          lodash.VERSION = VERSION;
          arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
            lodash[methodName].placeholder = lodash;
          });
          arrayEach(["drop", "take"], function(methodName, index) {
            LazyWrapper.prototype[methodName] = function(n) {
              n = n === undefined2 ? 1 : nativeMax(toInteger(n), 0);
              var result2 = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();
              if (result2.__filtered__) {
                result2.__takeCount__ = nativeMin(n, result2.__takeCount__);
              } else {
                result2.__views__.push({
                  "size": nativeMin(n, MAX_ARRAY_LENGTH),
                  "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
                });
              }
              return result2;
            };
            LazyWrapper.prototype[methodName + "Right"] = function(n) {
              return this.reverse()[methodName](n).reverse();
            };
          });
          arrayEach(["filter", "map", "takeWhile"], function(methodName, index) {
            var type = index + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
            LazyWrapper.prototype[methodName] = function(iteratee2) {
              var result2 = this.clone();
              result2.__iteratees__.push({
                "iteratee": getIteratee(iteratee2, 3),
                "type": type
              });
              result2.__filtered__ = result2.__filtered__ || isFilter;
              return result2;
            };
          });
          arrayEach(["head", "last"], function(methodName, index) {
            var takeName = "take" + (index ? "Right" : "");
            LazyWrapper.prototype[methodName] = function() {
              return this[takeName](1).value()[0];
            };
          });
          arrayEach(["initial", "tail"], function(methodName, index) {
            var dropName = "drop" + (index ? "" : "Right");
            LazyWrapper.prototype[methodName] = function() {
              return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
            };
          });
          LazyWrapper.prototype.compact = function() {
            return this.filter(identity);
          };
          LazyWrapper.prototype.find = function(predicate) {
            return this.filter(predicate).head();
          };
          LazyWrapper.prototype.findLast = function(predicate) {
            return this.reverse().find(predicate);
          };
          LazyWrapper.prototype.invokeMap = baseRest(function(path2, args) {
            if (typeof path2 == "function") {
              return new LazyWrapper(this);
            }
            return this.map(function(value) {
              return baseInvoke(value, path2, args);
            });
          });
          LazyWrapper.prototype.reject = function(predicate) {
            return this.filter(negate(getIteratee(predicate)));
          };
          LazyWrapper.prototype.slice = function(start, end) {
            start = toInteger(start);
            var result2 = this;
            if (result2.__filtered__ && (start > 0 || end < 0)) {
              return new LazyWrapper(result2);
            }
            if (start < 0) {
              result2 = result2.takeRight(-start);
            } else if (start) {
              result2 = result2.drop(start);
            }
            if (end !== undefined2) {
              end = toInteger(end);
              result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start);
            }
            return result2;
          };
          LazyWrapper.prototype.takeRightWhile = function(predicate) {
            return this.reverse().takeWhile(predicate).reverse();
          };
          LazyWrapper.prototype.toArray = function() {
            return this.take(MAX_ARRAY_LENGTH);
          };
          baseForOwn(LazyWrapper.prototype, function(func, methodName) {
            var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
            if (!lodashFunc) {
              return;
            }
            lodash.prototype[methodName] = function() {
              var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray(value);
              var interceptor = function(value2) {
                var result3 = lodashFunc.apply(lodash, arrayPush([value2], args));
                return isTaker && chainAll ? result3[0] : result3;
              };
              if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
                isLazy = useLazy = false;
              }
              var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
              if (!retUnwrapped && useLazy) {
                value = onlyLazy ? value : new LazyWrapper(this);
                var result2 = func.apply(value, args);
                result2.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined2 });
                return new LodashWrapper(result2, chainAll);
              }
              if (isUnwrapped && onlyLazy) {
                return func.apply(this, args);
              }
              result2 = this.thru(interceptor);
              return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
            };
          });
          arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
            var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
            lodash.prototype[methodName] = function() {
              var args = arguments;
              if (retUnwrapped && !this.__chain__) {
                var value = this.value();
                return func.apply(isArray(value) ? value : [], args);
              }
              return this[chainName](function(value2) {
                return func.apply(isArray(value2) ? value2 : [], args);
              });
            };
          });
          baseForOwn(LazyWrapper.prototype, function(func, methodName) {
            var lodashFunc = lodash[methodName];
            if (lodashFunc) {
              var key = lodashFunc.name + "";
              if (!hasOwnProperty.call(realNames, key)) {
                realNames[key] = [];
              }
              realNames[key].push({ "name": methodName, "func": lodashFunc });
            }
          });
          realNames[createHybrid(undefined2, WRAP_BIND_KEY_FLAG).name] = [{
            "name": "wrapper",
            "func": undefined2
          }];
          LazyWrapper.prototype.clone = lazyClone;
          LazyWrapper.prototype.reverse = lazyReverse;
          LazyWrapper.prototype.value = lazyValue;
          lodash.prototype.at = wrapperAt;
          lodash.prototype.chain = wrapperChain;
          lodash.prototype.commit = wrapperCommit;
          lodash.prototype.next = wrapperNext;
          lodash.prototype.plant = wrapperPlant;
          lodash.prototype.reverse = wrapperReverse;
          lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
          lodash.prototype.first = lodash.prototype.head;
          if (symIterator) {
            lodash.prototype[symIterator] = wrapperToIterator;
          }
          return lodash;
        };
        var _ = runInContext();
        if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
          root._ = _;
          define(function() {
            return _;
          });
        } else if (freeModule) {
          (freeModule.exports = _)._ = _;
          freeExports._ = _;
        } else {
          root._ = _;
        }
      }).call(exports);
    }
  });

  // (disabled):node_modules/archiver/index.js
  var require_archiver = __commonJS({
    "(disabled):node_modules/archiver/index.js"() {
    }
  });

  // (disabled):node_modules/stream-buffers/lib/streambuffer.js
  var require_streambuffer = __commonJS({
    "(disabled):node_modules/stream-buffers/lib/streambuffer.js"() {
    }
  });

  // src/index.ts
  var src_exports = {};
  __export(src_exports, {
    ArweaveGatewayInteractionsLoader: () => ArweaveGatewayInteractionsLoader,
    ArweaveWrapper: () => ArweaveWrapper,
    Benchmark: () => Benchmark,
    BlockHeightCacheResult: () => BlockHeightCacheResult2,
    BlockHeightInteractionsSorter: () => BlockHeightInteractionsSorter,
    BlockHeightKey: () => BlockHeightKey3,
    CacheableContractInteractionsLoader: () => CacheableContractInteractionsLoader,
    CacheableExecutorFactory: () => CacheableExecutorFactory,
    CacheableStateEvaluator: () => CacheableStateEvaluator,
    ConsoleLogger: () => ConsoleLogger,
    ConsoleLoggerFactory: () => ConsoleLoggerFactory,
    ContractCallStack: () => ContractCallStack,
    ContractDefinitionLoader: () => ContractDefinitionLoader,
    ContractMetadata: () => ContractMetadata,
    DebuggableExecutorFactory: () => DebuggableExecutorFactory,
    DefaultCreateContract: () => DefaultCreateContract,
    DefaultEvaluationOptions: () => DefaultEvaluationOptions,
    DefaultStateEvaluator: () => DefaultStateEvaluator,
    EvalStateResult: () => EvalStateResult,
    Evolve: () => Evolve,
    FileBlockHeightSwCache: () => FileBlockHeightSwCache,
    HandlerBasedContract: () => HandlerBasedContract,
    HandlerExecutorFactory: () => HandlerExecutorFactory,
    InnerWritesEvaluator: () => InnerWritesEvaluator,
    InteractionCall: () => InteractionCall2,
    InteractionInput: () => InteractionInput,
    InteractionOutput: () => InteractionOutput,
    KnexStateCache: () => KnexStateCache,
    LexicographicalInteractionsSorter: () => LexicographicalInteractionsSorter,
    LogLevelOrder: () => LogLevelOrder,
    LoggerFactory: () => LoggerFactory,
    MemBlockHeightSwCache: () => MemBlockHeightSwCache,
    MemCache: () => MemCache,
    PstContractImpl: () => PstContractImpl,
    RedstoneGatewayContractDefinitionLoader: () => RedstoneGatewayContractDefinitionLoader,
    RedstoneGatewayInteractionsLoader: () => RedstoneGatewayInteractionsLoader,
    RemoteBlockHeightCache: () => RemoteBlockHeightCache,
    SmartWeave: () => SmartWeave,
    SmartWeaveBuilder: () => SmartWeaveBuilder3,
    SmartWeaveError: () => SmartWeaveError,
    SmartWeaveErrorType: () => SmartWeaveErrorType,
    SmartWeaveGlobal: () => SmartWeaveGlobal5,
    SmartWeaveNodeFactory: () => SmartWeaveNodeFactory,
    SmartWeaveTags: () => SmartWeaveTags,
    SmartWeaveWebFactory: () => SmartWeaveWebFactory,
    SourceType: () => SourceType,
    TagsParser: () => TagsParser,
    WasmSrc: () => WasmSrc,
    arrayToHex: () => arrayToHex,
    asc: () => asc,
    ascS: () => ascS,
    bundledTxsFilter: () => bundledTxsFilter,
    canBeCached: () => canBeCached,
    createDummyTx: () => createDummyTx,
    createTx: () => createTx,
    deepCopy: () => deepCopy,
    desc: () => desc,
    descS: () => descS,
    emptyTransfer: () => emptyTransfer,
    getTag: () => getTag,
    lvlToOrder: () => lvlToOrder,
    mapReplacer: () => mapReplacer,
    mapReviver: () => mapReviver,
    normalizeContractSource: () => normalizeContractSource,
    sleep: () => sleep,
    stripTrailingSlash: () => stripTrailingSlash,
    timeout: () => timeout,
    unpackTags: () => unpackTags
  });

  // src/logging/web/ConsoleLogger.ts
  var ConsoleLogger = class {
    constructor(moduleName, settings) {
      this.moduleName = moduleName;
      this.settings = settings;
    }
    trace(message, ...optionalParams) {
      if (this.shouldLog("trace")) {
        console.debug(this.message("trace", message), optionalParams);
      }
    }
    error(message, ...optionalParams) {
      if (this.shouldLog("error")) {
        console.error(this.message("error", message), optionalParams);
      }
    }
    info(message, ...optionalParams) {
      if (this.shouldLog("info")) {
        console.info(this.message("info", message), optionalParams);
      }
    }
    silly(message, ...optionalParams) {
      if (this.shouldLog("silly")) {
        console.debug(this.message("silly", message), optionalParams);
      }
    }
    debug(message, ...optionalParams) {
      if (this.shouldLog("debug")) {
        console.debug(this.message("debug", message), optionalParams);
      }
    }
    warn(message, ...optionalParams) {
      if (this.shouldLog("warn")) {
        console.warn(this.message("warn", message), optionalParams);
      }
    }
    log(message, ...optionalParams) {
      if (this.shouldLog("info")) {
        console.info(this.message("info", message), optionalParams);
      }
    }
    fatal(message, ...optionalParams) {
      if (this.shouldLog("fatal")) {
        console.error(this.message("fatal", message), optionalParams);
      }
    }
    shouldLog(logLevel) {
      return lvlToOrder(logLevel) >= lvlToOrder(this.settings.minLevel);
    }
    setSettings(settings) {
      this.settings = settings;
    }
    message(lvl, message) {
      return `${new Date().toISOString()} ${lvl.toUpperCase()} [${this.moduleName}] ${message}`;
    }
  };

  // src/logging/web/ConsoleLoggerFactory.ts
  var ConsoleLoggerFactory = class {
    constructor() {
      this.registeredLoggers = {};
      this.registeredOptions = {};
      this.defOptions = {
        minLevel: "info"
      };
      this.setOptions = this.setOptions.bind(this);
      this.getOptions = this.getOptions.bind(this);
      this.create = this.create.bind(this);
      this.logLevel = this.logLevel.bind(this);
    }
    setOptions(newOptions, moduleName) {
      if (!moduleName) {
        this.defOptions = newOptions;
        Object.keys(this.registeredLoggers).forEach((key) => {
          this.registeredLoggers[key].setSettings(__spreadValues(__spreadValues({}, this.registeredLoggers[key].settings), newOptions));
        });
      } else {
        if (this.registeredLoggers[moduleName]) {
          this.registeredLoggers[moduleName].setSettings(__spreadValues(__spreadValues({}, this.registeredLoggers[moduleName].settings), newOptions));
        } else {
          this.registeredOptions[moduleName] = __spreadValues(__spreadValues({}, this.defOptions), newOptions);
        }
      }
    }
    getOptions(moduleName) {
      if (!moduleName) {
        return this.defOptions;
      } else {
        if (this.registeredLoggers[moduleName]) {
          return this.registeredLoggers[moduleName].settings;
        } else if (this.registeredOptions[moduleName]) {
          return this.registeredOptions[moduleName];
        } else {
          return this.defOptions;
        }
      }
    }
    logLevel(level, moduleName) {
      this.setOptions({ minLevel: level }, moduleName);
    }
    create(moduleName = "SWC") {
      if (!Object.prototype.hasOwnProperty.call(this.registeredLoggers, moduleName)) {
        this.registeredLoggers[moduleName] = new ConsoleLogger(moduleName, this.getOptions(moduleName));
      }
      return this.registeredLoggers[moduleName];
    }
  };

  // src/logging/LoggerFactory.ts
  var _LoggerFactory = class {
    constructor() {
    }
    setOptions(newOptions, moduleName) {
      _LoggerFactory.INST.setOptions(newOptions, moduleName);
    }
    getOptions(moduleName) {
      return _LoggerFactory.INST.getOptions(moduleName);
    }
    logLevel(level, moduleName) {
      _LoggerFactory.INST.logLevel(level, moduleName);
    }
    create(moduleName) {
      return _LoggerFactory.INST.create(moduleName);
    }
    static use(logger) {
      _LoggerFactory.INST = logger;
    }
  };
  var LoggerFactory = _LoggerFactory;
  LoggerFactory.INST = new ConsoleLoggerFactory();

  // src/logging/LoggerSettings.ts
  var LogLevelOrder = {
    silly: 0,
    trace: 1,
    debug: 2,
    info: 3,
    warn: 4,
    error: 5,
    fatal: 6
  };
  function lvlToOrder(logLevel) {
    return LogLevelOrder[logLevel];
  }

  // src/logging/Benchmark.ts
  var Benchmark = class {
    constructor() {
      this.start = Date.now();
      this.end = null;
    }
    static measure() {
      return new Benchmark();
    }
    reset() {
      this.start = Date.now();
      this.end = null;
    }
    stop() {
      this.end = Date.now();
    }
    elapsed(rawValue = false) {
      if (this.end === null) {
        this.end = Date.now();
      }
      const result = this.end - this.start;
      return rawValue ? result : `${(this.end - this.start).toFixed(0)}ms`;
    }
  };

  // src/core/modules/StateEvaluator.ts
  var EvalStateResult = class {
    constructor(state, validity, transactionId, blockId) {
      this.state = state;
      this.validity = validity;
      this.transactionId = transactionId;
      this.blockId = blockId;
    }
  };
  var DefaultEvaluationOptions = class {
    constructor() {
      this.ignoreExceptions = true;
      this.waitForConfirmation = false;
      this.updateCacheForEachInteraction = false;
      this.internalWrites = false;
      this.maxCallDepth = 7;
      this.maxInteractionEvaluationTimeSeconds = 60;
      this.stackTrace = {
        saveState: false
      };
      this.bundlerAddress = "https://gateway.redstone.finance/";
      this.gasLimit = Number.MAX_SAFE_INTEGER;
      this.useFastCopy = true;
      this.manualCacheFlush = false;
      this.useVM2 = false;
    }
  };

  // src/core/modules/CreateContract.ts
  var emptyTransfer = {
    target: "",
    winstonQty: "0"
  };

  // src/core/modules/impl/BlockHeightInteractionsSorter.ts
  var BlockHeightInteractionsSorter = class {
    async sort(transactions) {
      const copy2 = [...transactions];
      return copy2.sort((a, b) => a.node.block.height - b.node.block.height || a.node.id.localeCompare(b.node.id));
    }
  };

  // node_modules/unzipit/dist/unzipit.module.js
  function readBlobAsArrayBuffer(blob) {
    if (blob.arrayBuffer) {
      return blob.arrayBuffer();
    }
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.addEventListener("loadend", () => {
        resolve(reader.result);
      });
      reader.addEventListener("error", reject);
      reader.readAsArrayBuffer(blob);
    });
  }
  async function readBlobAsUint8Array(blob) {
    const arrayBuffer = await readBlobAsArrayBuffer(blob);
    return new Uint8Array(arrayBuffer);
  }
  function isBlob(v) {
    return typeof Blob !== "undefined" && v instanceof Blob;
  }
  function isSharedArrayBuffer(b) {
    return typeof SharedArrayBuffer !== "undefined" && b instanceof SharedArrayBuffer;
  }
  var isNode = typeof process !== "undefined" && process.versions && typeof process.versions.node !== "undefined" && typeof process.versions.electron === "undefined";
  function isTypedArraySameAsArrayBuffer(typedArray) {
    return typedArray.byteOffset === 0 && typedArray.byteLength === typedArray.buffer.byteLength;
  }
  var ArrayBufferReader = class {
    constructor(arrayBufferOrView) {
      this.typedArray = arrayBufferOrView instanceof ArrayBuffer || isSharedArrayBuffer(arrayBufferOrView) ? new Uint8Array(arrayBufferOrView) : new Uint8Array(arrayBufferOrView.buffer, arrayBufferOrView.byteOffset, arrayBufferOrView.byteLength);
    }
    async getLength() {
      return this.typedArray.byteLength;
    }
    async read(offset, length) {
      return new Uint8Array(this.typedArray.buffer, this.typedArray.byteOffset + offset, length);
    }
  };
  var BlobReader = class {
    constructor(blob) {
      this.blob = blob;
    }
    async getLength() {
      return this.blob.size;
    }
    async read(offset, length) {
      const blob = this.blob.slice(offset, offset + length);
      const arrayBuffer = await readBlobAsArrayBuffer(blob);
      return new Uint8Array(arrayBuffer);
    }
    async sliceAsBlob(offset, length, type = "") {
      return this.blob.slice(offset, offset + length, type);
    }
  };
  function inflate(data, buf) {
    var u8 = Uint8Array;
    if (data[0] == 3 && data[1] == 0)
      return buf ? buf : new u8(0);
    var bitsF = _bitsF, bitsE = _bitsE, decodeTiny = _decodeTiny, get17 = _get17;
    var noBuf = buf == null;
    if (noBuf)
      buf = new u8(data.length >>> 2 << 3);
    var BFINAL = 0, BTYPE = 0, HLIT = 0, HDIST = 0, HCLEN = 0, ML = 0, MD = 0;
    var off = 0, pos = 0;
    var lmap, dmap;
    while (BFINAL == 0) {
      BFINAL = bitsF(data, pos, 1);
      BTYPE = bitsF(data, pos + 1, 2);
      pos += 3;
      if (BTYPE == 0) {
        if ((pos & 7) != 0)
          pos += 8 - (pos & 7);
        var p8 = (pos >>> 3) + 4, len = data[p8 - 4] | data[p8 - 3] << 8;
        if (noBuf)
          buf = _check(buf, off + len);
        buf.set(new u8(data.buffer, data.byteOffset + p8, len), off);
        pos = p8 + len << 3;
        off += len;
        continue;
      }
      if (noBuf)
        buf = _check(buf, off + (1 << 17));
      if (BTYPE == 1) {
        lmap = U.flmap;
        dmap = U.fdmap;
        ML = (1 << 9) - 1;
        MD = (1 << 5) - 1;
      }
      if (BTYPE == 2) {
        HLIT = bitsE(data, pos, 5) + 257;
        HDIST = bitsE(data, pos + 5, 5) + 1;
        HCLEN = bitsE(data, pos + 10, 4) + 4;
        pos += 14;
        for (var i = 0; i < 38; i += 2) {
          U.itree[i] = 0;
          U.itree[i + 1] = 0;
        }
        var tl = 1;
        for (var i = 0; i < HCLEN; i++) {
          var l = bitsE(data, pos + i * 3, 3);
          U.itree[(U.ordr[i] << 1) + 1] = l;
          if (l > tl)
            tl = l;
        }
        pos += 3 * HCLEN;
        makeCodes(U.itree, tl);
        codes2map(U.itree, tl, U.imap);
        lmap = U.lmap;
        dmap = U.dmap;
        pos = decodeTiny(U.imap, (1 << tl) - 1, HLIT + HDIST, data, pos, U.ttree);
        var mx0 = _copyOut(U.ttree, 0, HLIT, U.ltree);
        ML = (1 << mx0) - 1;
        var mx1 = _copyOut(U.ttree, HLIT, HDIST, U.dtree);
        MD = (1 << mx1) - 1;
        makeCodes(U.ltree, mx0);
        codes2map(U.ltree, mx0, lmap);
        makeCodes(U.dtree, mx1);
        codes2map(U.dtree, mx1, dmap);
      }
      while (true) {
        var code = lmap[get17(data, pos) & ML];
        pos += code & 15;
        var lit = code >>> 4;
        if (lit >>> 8 == 0) {
          buf[off++] = lit;
        } else if (lit == 256) {
          break;
        } else {
          var end = off + lit - 254;
          if (lit > 264) {
            var ebs = U.ldef[lit - 257];
            end = off + (ebs >>> 3) + bitsE(data, pos, ebs & 7);
            pos += ebs & 7;
          }
          var dcode = dmap[get17(data, pos) & MD];
          pos += dcode & 15;
          var dlit = dcode >>> 4;
          var dbs = U.ddef[dlit], dst = (dbs >>> 4) + bitsF(data, pos, dbs & 15);
          pos += dbs & 15;
          if (noBuf)
            buf = _check(buf, off + (1 << 17));
          while (off < end) {
            buf[off] = buf[off++ - dst];
            buf[off] = buf[off++ - dst];
            buf[off] = buf[off++ - dst];
            buf[off] = buf[off++ - dst];
          }
          off = end;
        }
      }
    }
    return buf.length == off ? buf : buf.slice(0, off);
  }
  function _check(buf, len) {
    var bl = buf.length;
    if (len <= bl)
      return buf;
    var nbuf = new Uint8Array(Math.max(bl << 1, len));
    nbuf.set(buf, 0);
    return nbuf;
  }
  function _decodeTiny(lmap, LL, len, data, pos, tree) {
    var bitsE = _bitsE, get17 = _get17;
    var i = 0;
    while (i < len) {
      var code = lmap[get17(data, pos) & LL];
      pos += code & 15;
      var lit = code >>> 4;
      if (lit <= 15) {
        tree[i] = lit;
        i++;
      } else {
        var ll = 0, n = 0;
        if (lit == 16) {
          n = 3 + bitsE(data, pos, 2);
          pos += 2;
          ll = tree[i - 1];
        } else if (lit == 17) {
          n = 3 + bitsE(data, pos, 3);
          pos += 3;
        } else if (lit == 18) {
          n = 11 + bitsE(data, pos, 7);
          pos += 7;
        }
        var ni = i + n;
        while (i < ni) {
          tree[i] = ll;
          i++;
        }
      }
    }
    return pos;
  }
  function _copyOut(src, off, len, tree) {
    var mx = 0, i = 0, tl = tree.length >>> 1;
    while (i < len) {
      var v = src[i + off];
      tree[i << 1] = 0;
      tree[(i << 1) + 1] = v;
      if (v > mx)
        mx = v;
      i++;
    }
    while (i < tl) {
      tree[i << 1] = 0;
      tree[(i << 1) + 1] = 0;
      i++;
    }
    return mx;
  }
  function makeCodes(tree, MAX_BITS) {
    var max_code = tree.length;
    var code, bits, n, i, len;
    var bl_count = U.bl_count;
    for (var i = 0; i <= MAX_BITS; i++)
      bl_count[i] = 0;
    for (i = 1; i < max_code; i += 2)
      bl_count[tree[i]]++;
    var next_code = U.next_code;
    code = 0;
    bl_count[0] = 0;
    for (bits = 1; bits <= MAX_BITS; bits++) {
      code = code + bl_count[bits - 1] << 1;
      next_code[bits] = code;
    }
    for (n = 0; n < max_code; n += 2) {
      len = tree[n + 1];
      if (len != 0) {
        tree[n] = next_code[len];
        next_code[len]++;
      }
    }
  }
  function codes2map(tree, MAX_BITS, map) {
    var max_code = tree.length;
    var r15 = U.rev15;
    for (var i = 0; i < max_code; i += 2)
      if (tree[i + 1] != 0) {
        var lit = i >> 1;
        var cl = tree[i + 1], val = lit << 4 | cl;
        var rest = MAX_BITS - cl, i0 = tree[i] << rest, i1 = i0 + (1 << rest);
        while (i0 != i1) {
          var p0 = r15[i0] >>> 15 - MAX_BITS;
          map[p0] = val;
          i0++;
        }
      }
  }
  function revCodes(tree, MAX_BITS) {
    var r15 = U.rev15, imb = 15 - MAX_BITS;
    for (var i = 0; i < tree.length; i += 2) {
      var i0 = tree[i] << MAX_BITS - tree[i + 1];
      tree[i] = r15[i0] >>> imb;
    }
  }
  function _bitsE(dt, pos, length) {
    return (dt[pos >>> 3] | dt[(pos >>> 3) + 1] << 8) >>> (pos & 7) & (1 << length) - 1;
  }
  function _bitsF(dt, pos, length) {
    return (dt[pos >>> 3] | dt[(pos >>> 3) + 1] << 8 | dt[(pos >>> 3) + 2] << 16) >>> (pos & 7) & (1 << length) - 1;
  }
  function _get17(dt, pos) {
    return (dt[pos >>> 3] | dt[(pos >>> 3) + 1] << 8 | dt[(pos >>> 3) + 2] << 16) >>> (pos & 7);
  }
  var U = function() {
    var u16 = Uint16Array, u32 = Uint32Array;
    return {
      next_code: new u16(16),
      bl_count: new u16(16),
      ordr: [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15],
      of0: [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 999, 999, 999],
      exb: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0],
      ldef: new u16(32),
      df0: [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 65535, 65535],
      dxb: [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0],
      ddef: new u32(32),
      flmap: new u16(512),
      fltree: [],
      fdmap: new u16(32),
      fdtree: [],
      lmap: new u16(32768),
      ltree: [],
      ttree: [],
      dmap: new u16(32768),
      dtree: [],
      imap: new u16(512),
      itree: [],
      rev15: new u16(1 << 15),
      lhst: new u32(286),
      dhst: new u32(30),
      ihst: new u32(19),
      lits: new u32(15e3),
      strt: new u16(1 << 16),
      prev: new u16(1 << 15)
    };
  }();
  (function() {
    var len = 1 << 15;
    for (var i = 0; i < len; i++) {
      var x = i;
      x = (x & 2863311530) >>> 1 | (x & 1431655765) << 1;
      x = (x & 3435973836) >>> 2 | (x & 858993459) << 2;
      x = (x & 4042322160) >>> 4 | (x & 252645135) << 4;
      x = (x & 4278255360) >>> 8 | (x & 16711935) << 8;
      U.rev15[i] = (x >>> 16 | x << 16) >>> 17;
    }
    function pushV(tgt, n, sv) {
      while (n-- != 0)
        tgt.push(0, sv);
    }
    for (var i = 0; i < 32; i++) {
      U.ldef[i] = U.of0[i] << 3 | U.exb[i];
      U.ddef[i] = U.df0[i] << 4 | U.dxb[i];
    }
    pushV(U.fltree, 144, 8);
    pushV(U.fltree, 255 - 143, 9);
    pushV(U.fltree, 279 - 255, 7);
    pushV(U.fltree, 287 - 279, 8);
    makeCodes(U.fltree, 9);
    codes2map(U.fltree, 9, U.flmap);
    revCodes(U.fltree, 9);
    pushV(U.fdtree, 32, 5);
    makeCodes(U.fdtree, 5);
    codes2map(U.fdtree, 5, U.fdmap);
    revCodes(U.fdtree, 5);
    pushV(U.itree, 19, 0);
    pushV(U.ltree, 286, 0);
    pushV(U.dtree, 30, 0);
    pushV(U.ttree, 320, 0);
  })();
  var crc = {
    table: function() {
      var tab = new Uint32Array(256);
      for (var n = 0; n < 256; n++) {
        var c = n;
        for (var k = 0; k < 8; k++) {
          if (c & 1)
            c = 3988292384 ^ c >>> 1;
          else
            c = c >>> 1;
        }
        tab[n] = c;
      }
      return tab;
    }(),
    update: function(c, buf, off, len) {
      for (var i = 0; i < len; i++)
        c = crc.table[(c ^ buf[off + i]) & 255] ^ c >>> 8;
      return c;
    },
    crc: function(b, o, l) {
      return crc.update(4294967295, b, o, l) ^ 4294967295;
    }
  };
  function inflateRaw(file, buf) {
    return inflate(file, buf);
  }
  var config = {
    numWorkers: 1,
    workerURL: "",
    useWorkers: false
  };
  var nextId = 0;
  var numWorkers = 0;
  var canUseWorkers = true;
  var workers = [];
  var availableWorkers = [];
  var waitingForWorkerQueue = [];
  var currentlyProcessingIdToRequestMap = new Map();
  function handleResult(e) {
    makeWorkerAvailable(e.target);
    const { id, error, data } = e.data;
    const request = currentlyProcessingIdToRequestMap.get(id);
    currentlyProcessingIdToRequestMap.delete(id);
    if (error) {
      request.reject(error);
    } else {
      request.resolve(data);
    }
  }
  function startWorker(url) {
    return new Promise((resolve, reject) => {
      const worker = new Worker(url);
      worker.onmessage = (e) => {
        if (e.data === "start") {
          worker.onerror = void 0;
          worker.onmessage = void 0;
          resolve(worker);
        } else {
          reject(new Error(`unexpected message: ${e.data}`));
        }
      };
      worker.onerror = reject;
    });
  }
  function dynamicRequire(mod, request) {
    return mod.require(request);
  }
  var workerHelper = function() {
    if (isNode) {
      const { Worker: Worker2 } = dynamicRequire(module, "worker_threads");
      return {
        async createWorker(url) {
          return new Worker2(url);
        },
        addEventListener(worker, fn) {
          worker.on("message", (data) => {
            fn({ target: worker, data });
          });
        },
        async terminate(worker) {
          await worker.terminate();
        }
      };
    } else {
      return {
        async createWorker(url) {
          try {
            const worker = await startWorker(url);
            return worker;
          } catch (e) {
            console.warn("could not load worker:", url);
          }
          let text;
          try {
            const req = await fetch(url, { mode: "cors" });
            if (!req.ok) {
              throw new Error(`could not load: ${url}`);
            }
            text = await req.text();
            url = URL.createObjectURL(new Blob([text], { type: "application/javascript" }));
            const worker = await startWorker(url);
            config.workerURL = url;
            return worker;
          } catch (e) {
            console.warn("could not load worker via fetch:", url);
          }
          if (text !== void 0) {
            try {
              url = `data:application/javascript;base64,${btoa(text)}`;
              const worker = await startWorker(url);
              config.workerURL = url;
              return worker;
            } catch (e) {
              console.warn("could not load worker via dataURI");
            }
          }
          console.warn("workers will not be used");
          throw new Error("can not start workers");
        },
        addEventListener(worker, fn) {
          worker.addEventListener("message", fn);
        },
        async terminate(worker) {
          worker.terminate();
        }
      };
    }
  }();
  function makeWorkerAvailable(worker) {
    availableWorkers.push(worker);
    processWaitingForWorkerQueue();
  }
  async function getAvailableWorker() {
    if (availableWorkers.length === 0 && numWorkers < config.numWorkers) {
      ++numWorkers;
      try {
        const worker = await workerHelper.createWorker(config.workerURL);
        workers.push(worker);
        availableWorkers.push(worker);
        workerHelper.addEventListener(worker, handleResult);
      } catch (e) {
        canUseWorkers = false;
      }
    }
    return availableWorkers.pop();
  }
  function inflateRawLocal(src, uncompressedSize, type, resolve) {
    const dst = new Uint8Array(uncompressedSize);
    inflateRaw(src, dst);
    resolve(type ? new Blob([dst], { type }) : dst.buffer);
  }
  async function processWaitingForWorkerQueue() {
    if (waitingForWorkerQueue.length === 0) {
      return;
    }
    if (config.useWorkers && canUseWorkers) {
      const worker = await getAvailableWorker();
      if (canUseWorkers) {
        if (worker) {
          if (waitingForWorkerQueue.length === 0) {
            makeWorkerAvailable(worker);
            return;
          }
          const { id, src, uncompressedSize, type, resolve, reject } = waitingForWorkerQueue.shift();
          currentlyProcessingIdToRequestMap.set(id, { id, resolve, reject });
          const transferables = [];
          worker.postMessage({
            type: "inflate",
            data: {
              id,
              type,
              src,
              uncompressedSize
            }
          }, transferables);
        }
        return;
      }
    }
    while (waitingForWorkerQueue.length) {
      const { src, uncompressedSize, type, resolve } = waitingForWorkerQueue.shift();
      let data = src;
      if (isBlob(src)) {
        data = await readBlobAsUint8Array(src);
      }
      inflateRawLocal(data, uncompressedSize, type, resolve);
    }
  }
  function inflateRawAsync(src, uncompressedSize, type) {
    return new Promise((resolve, reject) => {
      waitingForWorkerQueue.push({ src, uncompressedSize, type, resolve, reject, id: nextId++ });
      processWaitingForWorkerQueue();
    });
  }
  function dosDateTimeToDate(date, time) {
    const day = date & 31;
    const month = (date >> 5 & 15) - 1;
    const year = (date >> 9 & 127) + 1980;
    const millisecond = 0;
    const second = (time & 31) * 2;
    const minute = time >> 5 & 63;
    const hour = time >> 11 & 31;
    return new Date(year, month, day, hour, minute, second, millisecond);
  }
  var ZipEntry = class {
    constructor(reader, rawEntry) {
      this._reader = reader;
      this._rawEntry = rawEntry;
      this.name = rawEntry.name;
      this.nameBytes = rawEntry.nameBytes;
      this.size = rawEntry.uncompressedSize;
      this.compressedSize = rawEntry.compressedSize;
      this.comment = rawEntry.comment;
      this.commentBytes = rawEntry.commentBytes;
      this.compressionMethod = rawEntry.compressionMethod;
      this.lastModDate = dosDateTimeToDate(rawEntry.lastModFileDate, rawEntry.lastModFileTime);
      this.isDirectory = rawEntry.uncompressedSize === 0 && rawEntry.name.endsWith("/");
      this.encrypted = !!(rawEntry.generalPurposeBitFlag & 1);
      this.externalFileAttributes = rawEntry.externalFileAttributes;
      this.versionMadeBy = rawEntry.versionMadeBy;
    }
    async blob(type = "application/octet-stream") {
      return await readEntryDataAsBlob(this._reader, this._rawEntry, type);
    }
    async arrayBuffer() {
      return await readEntryDataAsArrayBuffer(this._reader, this._rawEntry);
    }
    async text() {
      const buffer = await this.arrayBuffer();
      return decodeBuffer(new Uint8Array(buffer));
    }
    async json() {
      const text = await this.text();
      return JSON.parse(text);
    }
  };
  var EOCDR_WITHOUT_COMMENT_SIZE = 22;
  var MAX_COMMENT_SIZE = 65535;
  var EOCDR_SIGNATURE = 101010256;
  var ZIP64_EOCDR_SIGNATURE = 101075792;
  async function readAs(reader, offset, length) {
    return await reader.read(offset, length);
  }
  async function readAsBlobOrTypedArray(reader, offset, length, type) {
    if (reader.sliceAsBlob) {
      return await reader.sliceAsBlob(offset, length, type);
    }
    return await reader.read(offset, length);
  }
  var crc$1 = {
    unsigned() {
      return 0;
    }
  };
  function getUint16LE(uint8View, offset) {
    return uint8View[offset] + uint8View[offset + 1] * 256;
  }
  function getUint32LE(uint8View, offset) {
    return uint8View[offset] + uint8View[offset + 1] * 256 + uint8View[offset + 2] * 65536 + uint8View[offset + 3] * 16777216;
  }
  function getUint64LE(uint8View, offset) {
    return getUint32LE(uint8View, offset) + getUint32LE(uint8View, offset + 4) * 4294967296;
  }
  var utf8Decoder = new TextDecoder();
  function decodeBuffer(uint8View, isUTF8) {
    if (isSharedArrayBuffer(uint8View.buffer)) {
      uint8View = new Uint8Array(uint8View);
    }
    return utf8Decoder.decode(uint8View);
  }
  async function findEndOfCentralDirector(reader, totalLength) {
    const size = Math.min(EOCDR_WITHOUT_COMMENT_SIZE + MAX_COMMENT_SIZE, totalLength);
    const readStart = totalLength - size;
    const data = await readAs(reader, readStart, size);
    for (let i = size - EOCDR_WITHOUT_COMMENT_SIZE; i >= 0; --i) {
      if (getUint32LE(data, i) !== EOCDR_SIGNATURE) {
        continue;
      }
      const eocdr = new Uint8Array(data.buffer, data.byteOffset + i, data.byteLength - i);
      const diskNumber = getUint16LE(eocdr, 4);
      if (diskNumber !== 0) {
        throw new Error(`multi-volume zip files are not supported. This is volume: ${diskNumber}`);
      }
      const entryCount = getUint16LE(eocdr, 10);
      const centralDirectorySize = getUint32LE(eocdr, 12);
      const centralDirectoryOffset = getUint32LE(eocdr, 16);
      const commentLength = getUint16LE(eocdr, 20);
      const expectedCommentLength = eocdr.length - EOCDR_WITHOUT_COMMENT_SIZE;
      if (commentLength !== expectedCommentLength) {
        throw new Error(`invalid comment length. expected: ${expectedCommentLength}, actual: ${commentLength}`);
      }
      const commentBytes = new Uint8Array(eocdr.buffer, eocdr.byteOffset + 22, commentLength);
      const comment = decodeBuffer(commentBytes);
      if (entryCount === 65535 || centralDirectoryOffset === 4294967295) {
        return await readZip64CentralDirectory(reader, readStart + i, comment, commentBytes);
      } else {
        return await readEntries(reader, centralDirectoryOffset, centralDirectorySize, entryCount, comment, commentBytes);
      }
    }
    throw new Error("could not find end of central directory. maybe not zip file");
  }
  var END_OF_CENTRAL_DIRECTORY_LOCATOR_SIGNATURE = 117853008;
  async function readZip64CentralDirectory(reader, offset, comment, commentBytes) {
    const zip64EocdlOffset = offset - 20;
    const eocdl = await readAs(reader, zip64EocdlOffset, 20);
    if (getUint32LE(eocdl, 0) !== END_OF_CENTRAL_DIRECTORY_LOCATOR_SIGNATURE) {
      throw new Error("invalid zip64 end of central directory locator signature");
    }
    const zip64EocdrOffset = getUint64LE(eocdl, 8);
    const zip64Eocdr = await readAs(reader, zip64EocdrOffset, 56);
    if (getUint32LE(zip64Eocdr, 0) !== ZIP64_EOCDR_SIGNATURE) {
      throw new Error("invalid zip64 end of central directory record signature");
    }
    const entryCount = getUint64LE(zip64Eocdr, 32);
    const centralDirectorySize = getUint64LE(zip64Eocdr, 40);
    const centralDirectoryOffset = getUint64LE(zip64Eocdr, 48);
    return readEntries(reader, centralDirectoryOffset, centralDirectorySize, entryCount, comment, commentBytes);
  }
  var CENTRAL_DIRECTORY_FILE_HEADER_SIGNATURE = 33639248;
  async function readEntries(reader, centralDirectoryOffset, centralDirectorySize, rawEntryCount, comment, commentBytes) {
    let readEntryCursor = 0;
    const allEntriesBuffer = await readAs(reader, centralDirectoryOffset, centralDirectorySize);
    const rawEntries = [];
    for (let e = 0; e < rawEntryCount; ++e) {
      const buffer = allEntriesBuffer.subarray(readEntryCursor, readEntryCursor + 46);
      const signature = getUint32LE(buffer, 0);
      if (signature !== CENTRAL_DIRECTORY_FILE_HEADER_SIGNATURE) {
        throw new Error(`invalid central directory file header signature: 0x${signature.toString(16)}`);
      }
      const rawEntry = {
        versionMadeBy: getUint16LE(buffer, 4),
        versionNeededToExtract: getUint16LE(buffer, 6),
        generalPurposeBitFlag: getUint16LE(buffer, 8),
        compressionMethod: getUint16LE(buffer, 10),
        lastModFileTime: getUint16LE(buffer, 12),
        lastModFileDate: getUint16LE(buffer, 14),
        crc32: getUint32LE(buffer, 16),
        compressedSize: getUint32LE(buffer, 20),
        uncompressedSize: getUint32LE(buffer, 24),
        fileNameLength: getUint16LE(buffer, 28),
        extraFieldLength: getUint16LE(buffer, 30),
        fileCommentLength: getUint16LE(buffer, 32),
        internalFileAttributes: getUint16LE(buffer, 36),
        externalFileAttributes: getUint32LE(buffer, 38),
        relativeOffsetOfLocalHeader: getUint32LE(buffer, 42)
      };
      if (rawEntry.generalPurposeBitFlag & 64) {
        throw new Error("strong encryption is not supported");
      }
      readEntryCursor += 46;
      const data = allEntriesBuffer.subarray(readEntryCursor, readEntryCursor + rawEntry.fileNameLength + rawEntry.extraFieldLength + rawEntry.fileCommentLength);
      rawEntry.nameBytes = data.slice(0, rawEntry.fileNameLength);
      rawEntry.name = decodeBuffer(rawEntry.nameBytes);
      const fileCommentStart = rawEntry.fileNameLength + rawEntry.extraFieldLength;
      const extraFieldBuffer = data.slice(rawEntry.fileNameLength, fileCommentStart);
      rawEntry.extraFields = [];
      let i = 0;
      while (i < extraFieldBuffer.length - 3) {
        const headerId = getUint16LE(extraFieldBuffer, i + 0);
        const dataSize = getUint16LE(extraFieldBuffer, i + 2);
        const dataStart = i + 4;
        const dataEnd = dataStart + dataSize;
        if (dataEnd > extraFieldBuffer.length) {
          throw new Error("extra field length exceeds extra field buffer size");
        }
        rawEntry.extraFields.push({
          id: headerId,
          data: extraFieldBuffer.slice(dataStart, dataEnd)
        });
        i = dataEnd;
      }
      rawEntry.commentBytes = data.slice(fileCommentStart, fileCommentStart + rawEntry.fileCommentLength);
      rawEntry.comment = decodeBuffer(rawEntry.commentBytes);
      readEntryCursor += data.length;
      if (rawEntry.uncompressedSize === 4294967295 || rawEntry.compressedSize === 4294967295 || rawEntry.relativeOffsetOfLocalHeader === 4294967295) {
        const zip64ExtraField = rawEntry.extraFields.find((e2) => e2.id === 1);
        if (!zip64ExtraField) {
          throw new Error("expected zip64 extended information extra field");
        }
        const zip64EiefBuffer = zip64ExtraField.data;
        let index = 0;
        if (rawEntry.uncompressedSize === 4294967295) {
          if (index + 8 > zip64EiefBuffer.length) {
            throw new Error("zip64 extended information extra field does not include uncompressed size");
          }
          rawEntry.uncompressedSize = getUint64LE(zip64EiefBuffer, index);
          index += 8;
        }
        if (rawEntry.compressedSize === 4294967295) {
          if (index + 8 > zip64EiefBuffer.length) {
            throw new Error("zip64 extended information extra field does not include compressed size");
          }
          rawEntry.compressedSize = getUint64LE(zip64EiefBuffer, index);
          index += 8;
        }
        if (rawEntry.relativeOffsetOfLocalHeader === 4294967295) {
          if (index + 8 > zip64EiefBuffer.length) {
            throw new Error("zip64 extended information extra field does not include relative header offset");
          }
          rawEntry.relativeOffsetOfLocalHeader = getUint64LE(zip64EiefBuffer, index);
          index += 8;
        }
      }
      const nameField = rawEntry.extraFields.find((e2) => e2.id === 28789 && e2.data.length >= 6 && e2.data[0] === 1 && getUint32LE(e2.data, 1), crc$1.unsigned(rawEntry.nameBytes));
      if (nameField) {
        rawEntry.fileName = decodeBuffer(nameField.data.slice(5));
      }
      if (rawEntry.compressionMethod === 0) {
        let expectedCompressedSize = rawEntry.uncompressedSize;
        if ((rawEntry.generalPurposeBitFlag & 1) !== 0) {
          expectedCompressedSize += 12;
        }
        if (rawEntry.compressedSize !== expectedCompressedSize) {
          throw new Error(`compressed size mismatch for stored file: ${rawEntry.compressedSize} != ${expectedCompressedSize}`);
        }
      }
      rawEntries.push(rawEntry);
    }
    const zip = {
      comment,
      commentBytes
    };
    return {
      zip,
      entries: rawEntries.map((e) => new ZipEntry(reader, e))
    };
  }
  async function readEntryDataHeader(reader, rawEntry) {
    if (rawEntry.generalPurposeBitFlag & 1) {
      throw new Error("encrypted entries not supported");
    }
    const buffer = await readAs(reader, rawEntry.relativeOffsetOfLocalHeader, 30);
    const totalLength = await reader.getLength();
    const signature = getUint32LE(buffer, 0);
    if (signature !== 67324752) {
      throw new Error(`invalid local file header signature: 0x${signature.toString(16)}`);
    }
    const fileNameLength = getUint16LE(buffer, 26);
    const extraFieldLength = getUint16LE(buffer, 28);
    const localFileHeaderEnd = rawEntry.relativeOffsetOfLocalHeader + buffer.length + fileNameLength + extraFieldLength;
    let decompress;
    if (rawEntry.compressionMethod === 0) {
      decompress = false;
    } else if (rawEntry.compressionMethod === 8) {
      decompress = true;
    } else {
      throw new Error(`unsupported compression method: ${rawEntry.compressionMethod}`);
    }
    const fileDataStart = localFileHeaderEnd;
    const fileDataEnd = fileDataStart + rawEntry.compressedSize;
    if (rawEntry.compressedSize !== 0) {
      if (fileDataEnd > totalLength) {
        throw new Error(`file data overflows file bounds: ${fileDataStart} +  ${rawEntry.compressedSize}  > ${totalLength}`);
      }
    }
    return {
      decompress,
      fileDataStart
    };
  }
  async function readEntryDataAsArrayBuffer(reader, rawEntry) {
    const { decompress, fileDataStart } = await readEntryDataHeader(reader, rawEntry);
    if (!decompress) {
      const dataView = await readAs(reader, fileDataStart, rawEntry.compressedSize);
      return isTypedArraySameAsArrayBuffer(dataView) ? dataView.buffer : dataView.slice().buffer;
    }
    const typedArrayOrBlob = await readAsBlobOrTypedArray(reader, fileDataStart, rawEntry.compressedSize);
    const result = await inflateRawAsync(typedArrayOrBlob, rawEntry.uncompressedSize);
    return result;
  }
  async function readEntryDataAsBlob(reader, rawEntry, type) {
    const { decompress, fileDataStart } = await readEntryDataHeader(reader, rawEntry);
    if (!decompress) {
      const typedArrayOrBlob2 = await readAsBlobOrTypedArray(reader, fileDataStart, rawEntry.compressedSize, type);
      if (isBlob(typedArrayOrBlob2)) {
        return typedArrayOrBlob2;
      }
      return new Blob([isSharedArrayBuffer(typedArrayOrBlob2.buffer) ? new Uint8Array(typedArrayOrBlob2) : typedArrayOrBlob2], { type });
    }
    const typedArrayOrBlob = await readAsBlobOrTypedArray(reader, fileDataStart, rawEntry.compressedSize);
    const result = await inflateRawAsync(typedArrayOrBlob, rawEntry.uncompressedSize, type);
    return result;
  }
  async function unzipRaw(source) {
    let reader;
    if (typeof Blob !== "undefined" && source instanceof Blob) {
      reader = new BlobReader(source);
    } else if (source instanceof ArrayBuffer || source && source.buffer && source.buffer instanceof ArrayBuffer) {
      reader = new ArrayBufferReader(source);
    } else if (isSharedArrayBuffer(source) || isSharedArrayBuffer(source.buffer)) {
      reader = new ArrayBufferReader(source);
    } else if (typeof source === "string") {
      const req = await fetch(source);
      if (!req.ok) {
        throw new Error(`failed http request ${source}, status: ${req.status}: ${req.statusText}`);
      }
      const blob = await req.blob();
      reader = new BlobReader(blob);
    } else if (typeof source.getLength === "function" && typeof source.read === "function") {
      reader = source;
    } else {
      throw new Error("unsupported source type");
    }
    const totalLength = await reader.getLength();
    if (totalLength > Number.MAX_SAFE_INTEGER) {
      throw new Error(`file too large. size: ${totalLength}. Only file sizes up 4503599627370496 bytes are supported`);
    }
    return await findEndOfCentralDirector(reader, totalLength);
  }
  async function unzip(source) {
    const { zip, entries } = await unzipRaw(source);
    return {
      zip,
      entries: Object.fromEntries(entries.map((v) => [v.name, v]))
    };
  }

  // src/core/modules/impl/wasm/WasmSrc.ts
  var import_redstone_isomorphic = __toModule(require_npm_browser());
  var WasmSrc = class {
    constructor(src) {
      this.src = src;
      this.logger = LoggerFactory.INST.create("WasmSrc");
      this.splitted = this.splitBuffer(src);
      this.logger.debug(`Buffer splitted into ${this.splitted.length} parts`);
    }
    wasmBinary() {
      return this.splitted[0];
    }
    async sourceCode() {
      const { entries } = await unzip(this.splitted[1]);
      const result = new Map();
      for (const [name, entry] of Object.entries(entries)) {
        if (entry.isDirectory) {
          continue;
        }
        const content = await entry.text();
        result.set(name, content);
      }
      return result;
    }
    additionalCode() {
      if (this.splitted.length == 2) {
        return null;
      }
      return this.splitted[2].toString();
    }
    splitBuffer(inputBuffer) {
      let header = "";
      const elements = parseInt(inputBuffer.toString("utf8", 0, 1));
      this.logger.debug(`Number of elements: ${elements}`);
      const l = inputBuffer.length;
      let delimiters = 0;
      let dataStart = 0;
      for (let i = 2; i < l; i++) {
        const element = inputBuffer.toString("utf8", i, i + 1);
        if (element == "|") {
          delimiters++;
        }
        if (delimiters == elements) {
          dataStart = i + 1;
          break;
        }
        header += element;
      }
      this.logger.debug(`Parsed:`, {
        header,
        dataStart
      });
      const lengths = header.split("|").map((l2) => parseInt(l2));
      this.logger.debug("Lengths", lengths);
      const result = [];
      for (const length of lengths) {
        const buffer = import_redstone_isomorphic.Buffer.alloc(length);
        const end = dataStart + length;
        inputBuffer.copy(buffer, 0, dataStart, end);
        dataStart = end;
        result.push(buffer);
      }
      return result;
    }
  };

  // src/core/modules/impl/ContractDefinitionLoader.ts
  var supportedSrcContentTypes = ["application/javascript", "application/wasm"];
  var ContractDefinitionLoader = class {
    constructor(arweave, cache) {
      this.arweave = arweave;
      this.cache = cache;
      this.logger = LoggerFactory.INST.create("ContractDefinitionLoader");
      this.arweaveWrapper = new ArweaveWrapper(arweave);
    }
    async load(contractTxId, evolvedSrcTxId) {
      var _a, _b, _c;
      if (!evolvedSrcTxId && ((_a = this.cache) == null ? void 0 : _a.contains(contractTxId))) {
        this.logger.debug("ContractDefinitionLoader: Hit from cache!");
        return Promise.resolve((_b = this.cache) == null ? void 0 : _b.get(contractTxId));
      }
      const benchmark = Benchmark.measure();
      const contract = await this.doLoad(contractTxId, evolvedSrcTxId);
      this.logger.info(`Contract definition loaded in: ${benchmark.elapsed()}`);
      (_c = this.cache) == null ? void 0 : _c.put(contractTxId, contract);
      return contract;
    }
    async doLoad(contractTxId, forcedSrcTxId) {
      const benchmark = Benchmark.measure();
      const contractTx = await this.arweaveWrapper.tx(contractTxId);
      const owner = await this.arweave.wallets.ownerToAddress(contractTx.owner);
      this.logger.debug("Contract tx and owner", benchmark.elapsed());
      benchmark.reset();
      const contractSrcTxId = forcedSrcTxId ? forcedSrcTxId : getTag(contractTx, SmartWeaveTags.CONTRACT_SRC_TX_ID);
      const minFee = getTag(contractTx, SmartWeaveTags.MIN_FEE);
      this.logger.debug("Tags decoding", benchmark.elapsed());
      benchmark.reset();
      const contractSrcTx = await this.arweaveWrapper.tx(contractSrcTxId);
      const srcContentType = getTag(contractSrcTx, SmartWeaveTags.CONTENT_TYPE);
      if (supportedSrcContentTypes.indexOf(srcContentType) == -1) {
        throw new Error(`Contract source content type ${srcContentType} not supported`);
      }
      const contractType = srcContentType == "application/javascript" ? "js" : "wasm";
      const src = contractType == "js" ? await this.arweaveWrapper.txDataString(contractSrcTxId) : await this.arweaveWrapper.txData(contractSrcTxId);
      let srcWasmLang;
      let wasmSrc;
      let srcMetaData;
      if (contractType == "wasm") {
        wasmSrc = new WasmSrc(src);
        srcWasmLang = getTag(contractSrcTx, SmartWeaveTags.WASM_LANG);
        if (!srcWasmLang) {
          throw new Error(`Wasm lang not set for wasm contract src ${contractSrcTxId}`);
        }
        srcMetaData = JSON.parse(getTag(contractSrcTx, SmartWeaveTags.WASM_META));
      }
      this.logger.debug("Contract src tx load", benchmark.elapsed());
      benchmark.reset();
      const s = await this.evalInitialState(contractTx);
      this.logger.debug("init state", s);
      const initState = JSON.parse(await this.evalInitialState(contractTx));
      this.logger.debug("Parsing src and init state", benchmark.elapsed());
      return {
        txId: contractTxId,
        srcTxId: contractSrcTxId,
        src: contractType == "js" ? src : null,
        srcBinary: contractType == "wasm" ? wasmSrc.wasmBinary() : null,
        srcWasmLang,
        initState,
        minFee,
        owner,
        contractType,
        metadata: srcMetaData,
        contractTx: contractTx.toJSON(),
        srcTx: contractSrcTx.toJSON()
      };
    }
    async evalInitialState(contractTx) {
      if (getTag(contractTx, SmartWeaveTags.INIT_STATE)) {
        return getTag(contractTx, SmartWeaveTags.INIT_STATE);
      } else if (getTag(contractTx, SmartWeaveTags.INIT_STATE_TX)) {
        const stateTX = getTag(contractTx, SmartWeaveTags.INIT_STATE_TX);
        return this.arweaveWrapper.txDataString(stateTX);
      } else {
        return this.arweaveWrapper.txDataString(contractTx.id);
      }
    }
  };

  // src/core/modules/impl/RedstoneGatewayContractDefinitionLoader.ts
  var import_redstone_isomorphic2 = __toModule(require_npm_browser());
  var import_transaction = __toModule(require_transaction());
  var RedstoneGatewayContractDefinitionLoader = class extends ContractDefinitionLoader {
    constructor(baseUrl, arweave, cache) {
      super(arweave, cache);
      this.baseUrl = baseUrl;
      this.rLogger = LoggerFactory.INST.create("RedstoneGatewayContractDefinitionLoader");
      this.baseUrl = stripTrailingSlash(baseUrl);
    }
    async doLoad(contractTxId, forcedSrcTxId) {
      if (forcedSrcTxId) {
        return await super.doLoad(contractTxId, forcedSrcTxId);
      }
      try {
        const result = await fetch(`${this.baseUrl}/gateway/contracts/${contractTxId}`).then((res) => {
          return res.ok ? res.json() : Promise.reject(res);
        }).catch((error) => {
          var _a, _b;
          if ((_a = error.body) == null ? void 0 : _a.message) {
            this.rLogger.error(error.body.message);
          }
          throw new Error(`Unable to retrieve contract data. Redstone gateway responded with status ${error.status}:${(_b = error.body) == null ? void 0 : _b.message}`);
        });
        if (result.srcBinary != null && !(result.srcBinary instanceof Buffer)) {
          result.srcBinary = Buffer.from(result.srcBinary.data);
        }
        if (result.srcBinary) {
          const wasmSrc = new WasmSrc(result.srcBinary);
          result.srcBinary = wasmSrc.wasmBinary();
          let sourceTx;
          if (result.srcTx) {
            sourceTx = new import_transaction.default(__spreadValues({}, result.srcTx));
          } else {
            sourceTx = await this.arweaveWrapper.tx(result.srcTxId);
          }
          const srcMetaData = JSON.parse(getTag(sourceTx, SmartWeaveTags.WASM_META));
          result.metadata = srcMetaData;
        }
        result.contractType = result.src ? "js" : "wasm";
        return result;
      } catch (e) {
        this.rLogger.warn("Falling back to default contracts loader", e);
        return await super.doLoad(contractTxId, forcedSrcTxId);
      }
    }
  };

  // src/core/modules/impl/ArweaveGatewayInteractionsLoader.ts
  var MAX_REQUEST = 100;
  function bundledTxsFilter(tx) {
    var _a, _b;
    return !((_a = tx.node.parent) == null ? void 0 : _a.id) && !((_b = tx.node.bundledIn) == null ? void 0 : _b.id);
  }
  var _ArweaveGatewayInteractionsLoader = class {
    constructor(arweave) {
      this.arweave = arweave;
      this.logger = LoggerFactory.INST.create("ArweaveGatewayInteractionsLoader");
      this.arweaveWrapper = new ArweaveWrapper(arweave);
    }
    async load(contractId, fromBlockHeight, toBlockHeight, evaluationOptions) {
      this.logger.debug("Loading interactions for", { contractId, fromBlockHeight, toBlockHeight });
      const mainTransactionsVariables = {
        tags: [
          {
            name: SmartWeaveTags.APP_NAME,
            values: ["SmartWeaveAction"]
          },
          {
            name: SmartWeaveTags.CONTRACT_TX_ID,
            values: [contractId]
          }
        ],
        blockFilter: {
          min: fromBlockHeight,
          max: toBlockHeight
        },
        first: MAX_REQUEST
      };
      const loadingBenchmark = Benchmark.measure();
      let interactions = await this.loadPages(mainTransactionsVariables);
      loadingBenchmark.stop();
      if (evaluationOptions.internalWrites) {
        const innerWritesVariables = {
          tags: [
            {
              name: SmartWeaveTags.INTERACT_WRITE,
              values: [contractId]
            }
          ],
          blockFilter: {
            min: fromBlockHeight,
            max: toBlockHeight
          },
          first: MAX_REQUEST
        };
        const innerWritesInteractions = await this.loadPages(innerWritesVariables);
        this.logger.debug("Inner writes interactions length:", innerWritesInteractions.length);
        interactions = interactions.concat(innerWritesInteractions);
      }
      this.logger.info("All loaded interactions:", {
        from: fromBlockHeight,
        to: toBlockHeight,
        loaded: interactions.length,
        time: loadingBenchmark.elapsed()
      });
      return interactions;
    }
    async loadPages(variables) {
      let transactions = await this.getNextPage(variables);
      const txInfos = transactions.edges.filter((tx) => bundledTxsFilter(tx));
      while (transactions.pageInfo.hasNextPage) {
        const cursor = transactions.edges[MAX_REQUEST - 1].cursor;
        variables = __spreadProps(__spreadValues({}, variables), {
          after: cursor
        });
        transactions = await this.getNextPage(variables);
        txInfos.push(...transactions.edges.filter((tx) => bundledTxsFilter(tx)));
      }
      return txInfos;
    }
    async getNextPage(variables) {
      const benchmark = Benchmark.measure();
      let response = await this.arweaveWrapper.gql(_ArweaveGatewayInteractionsLoader.query, variables);
      this.logger.debug("GQL page load:", benchmark.elapsed());
      while (response.status === 403) {
        this.logger.warn(`GQL rate limiting, waiting ${_ArweaveGatewayInteractionsLoader._30seconds}ms before next try.`);
        await sleep(_ArweaveGatewayInteractionsLoader._30seconds);
        response = await this.arweaveWrapper.gql(_ArweaveGatewayInteractionsLoader.query, variables);
      }
      if (response.status !== 200) {
        throw new Error(`Unable to retrieve transactions. Arweave gateway responded with status ${response.status}.`);
      }
      if (response.data.errors) {
        this.logger.error(response.data.errors);
        throw new Error("Error while loading interaction transactions");
      }
      const data = response.data;
      const txs = data.data.transactions;
      return txs;
    }
  };
  var ArweaveGatewayInteractionsLoader = _ArweaveGatewayInteractionsLoader;
  ArweaveGatewayInteractionsLoader.query = `query Transactions($tags: [TagFilter!]!, $blockFilter: BlockFilter!, $first: Int!, $after: String) {
    transactions(tags: $tags, block: $blockFilter, first: $first, sort: HEIGHT_ASC, after: $after) {
      pageInfo {
        hasNextPage
      }
      edges {
        node {
          id
          owner { address }
          recipient
          tags {
            name
            value
          }
          block {
            height
            id
            timestamp
          }
          fee { winston }
          quantity { winston }
          parent { id }
          bundledIn { id }
        }
        cursor
      }
    }
  }`;
  ArweaveGatewayInteractionsLoader._30seconds = 30 * 1e3;

  // src/core/modules/impl/RedstoneGatewayInteractionsLoader.ts
  var import_redstone_isomorphic3 = __toModule(require_npm_browser());
  var SourceType;
  (function(SourceType3) {
    SourceType3["ARWEAVE"] = "arweave";
    SourceType3["REDSTONE_SEQUENCER"] = "redstone-sequencer";
  })(SourceType || (SourceType = {}));
  var RedstoneGatewayInteractionsLoader = class {
    constructor(baseUrl, confirmationStatus = null, source = null) {
      this.baseUrl = baseUrl;
      this.confirmationStatus = confirmationStatus;
      this.source = source;
      this.logger = LoggerFactory.INST.create("RedstoneGatewayInteractionsLoader");
      this.baseUrl = stripTrailingSlash(baseUrl);
      Object.assign(this, confirmationStatus);
      this.source = source;
    }
    async load(contractId, fromBlockHeight, toBlockHeight, evaluationOptions, upToTransactionId) {
      this.logger.debug("Loading interactions: for ", { contractId, fromBlockHeight, toBlockHeight });
      const interactions = [];
      let page = 0;
      let totalPages = 0;
      const benchmarkTotalTime = Benchmark.measure();
      do {
        const benchmarkRequestTime = Benchmark.measure();
        const response = await fetch(`${this.baseUrl}/gateway/interactions?${new URLSearchParams(__spreadValues(__spreadValues(__spreadValues(__spreadValues({
          contractId,
          from: fromBlockHeight.toString(),
          to: toBlockHeight.toString(),
          page: (++page).toString(),
          minimize: "true"
        }, upToTransactionId ? { upToTransactionId } : ""), this.confirmationStatus && this.confirmationStatus.confirmed ? { confirmationStatus: "confirmed" } : ""), this.confirmationStatus && this.confirmationStatus.notCorrupted ? { confirmationStatus: "not_corrupted" } : ""), this.source ? { source: this.source } : ""))}`).then((res) => {
          return res.ok ? res.json() : Promise.reject(res);
        }).catch((error) => {
          var _a;
          if ((_a = error.body) == null ? void 0 : _a.message) {
            this.logger.error(error.body.message);
          }
          throw new Error(`Unable to retrieve transactions. Redstone gateway responded with status ${error.status}.`);
        });
        totalPages = response.paging.pages;
        this.logger.debug(`Loading interactions: page ${page} of ${totalPages} loaded in ${benchmarkRequestTime.elapsed()}`);
        response.interactions.forEach((interaction) => interactions.push({
          cursor: "",
          node: __spreadProps(__spreadValues({}, interaction.interaction), {
            confirmationStatus: interaction.status
          })
        }));
        this.logger.debug(`Loaded interactions length: ${interactions.length}`);
      } while (page < totalPages);
      this.logger.debug("All loaded interactions:", {
        from: fromBlockHeight,
        to: toBlockHeight,
        loaded: interactions.length,
        time: benchmarkTotalTime.elapsed()
      });
      return interactions;
    }
  };

  // src/core/modules/impl/DefaultStateEvaluator.ts
  var DefaultStateEvaluator = class {
    constructor(arweave, executionContextModifiers = []) {
      this.arweave = arweave;
      this.executionContextModifiers = executionContextModifiers;
      this.logger = LoggerFactory.INST.create("DefaultStateEvaluator");
      this.tagsParser = new TagsParser();
    }
    async eval(executionContext, currentTx) {
      return this.doReadState(executionContext.sortedInteractions, new EvalStateResult(executionContext.contractDefinition.initState, {}), executionContext, currentTx);
    }
    async doReadState(missingInteractions, baseState, executionContext, currentTx) {
      const { ignoreExceptions, stackTrace, internalWrites } = executionContext.evaluationOptions;
      const { contract, contractDefinition, sortedInteractions } = executionContext;
      let currentState = baseState.state;
      const validity = baseState.validity;
      executionContext == null ? void 0 : executionContext.handler.initState(currentState);
      this.logger.info(`Evaluating state for ${contractDefinition.txId} [${missingInteractions.length} non-cached of ${sortedInteractions.length} all]`);
      let errorMessage = null;
      let lastConfirmedTxState = null;
      const missingInteractionsLength = missingInteractions.length;
      executionContext.handler.initState(currentState);
      for (let i = 0; i < missingInteractionsLength; i++) {
        const missingInteraction = missingInteractions[i];
        const singleInteractionBenchmark = Benchmark.measure();
        const interactionTx = missingInteraction.node;
        this.logger.debug(`[${contractDefinition.txId}][${missingInteraction.node.id}][${missingInteraction.node.block.height}]: ${missingInteractions.indexOf(missingInteraction) + 1}/${missingInteractions.length} [of all:${sortedInteractions.length}]`);
        const isInteractWrite = this.tagsParser.isInteractWrite(missingInteraction, contractDefinition.txId);
        if (isInteractWrite && internalWrites) {
          const writingContractTxId = this.tagsParser.getContractTag(missingInteraction);
          this.logger.debug("Loading writing contract", writingContractTxId);
          const interactionCall = contract.getCallStack().addInteractionData({ interaction: null, interactionTx, currentTx });
          const writingContract = executionContext.smartweave.contract(writingContractTxId, executionContext.contract, interactionTx);
          this.logger.debug("Reading state of the calling contract", interactionTx.block.height);
          await writingContract.readState(interactionTx.block.height, [
            ...currentTx || [],
            {
              contractTxId: contractDefinition.txId,
              interactionTxId: missingInteraction.node.id
            }
          ]);
          const newState = await this.latestAvailableState(contractDefinition.txId, interactionTx.block.height);
          this.logger.debug("New state:", {
            height: interactionTx.block.height,
            newState,
            txId: contractDefinition.txId
          });
          if (newState !== null) {
            currentState = newState.cachedValue.state;
            executionContext == null ? void 0 : executionContext.handler.initState(currentState);
            validity[interactionTx.id] = newState.cachedValue.validity[interactionTx.id];
            const toCache = new EvalStateResult(currentState, validity);
            await this.onStateUpdate(interactionTx, executionContext, toCache);
            if (canBeCached(interactionTx)) {
              lastConfirmedTxState = {
                tx: interactionTx,
                state: toCache
              };
            }
          } else {
            validity[interactionTx.id] = false;
          }
          interactionCall.update({
            cacheHit: false,
            intermediaryCacheHit: false,
            outputState: stackTrace.saveState ? currentState : void 0,
            executionTime: singleInteractionBenchmark.elapsed(true),
            valid: validity[interactionTx.id],
            errorMessage,
            gasUsed: 0
          });
          this.logger.debug("New state after internal write", { contractTxId: contractDefinition.txId, newState });
        } else {
          const inputTag = this.tagsParser.getInputTag(missingInteraction, executionContext.contractDefinition.txId);
          if (!inputTag) {
            this.logger.error(`Skipping tx - Input tag not found for ${interactionTx.id}`);
            continue;
          }
          const input = this.parseInput(inputTag);
          if (!input) {
            this.logger.error(`Skipping tx - invalid Input tag - ${interactionTx.id}`);
            continue;
          }
          const interaction = {
            input,
            caller: interactionTx.owner.address
          };
          const interactionData = {
            interaction,
            interactionTx,
            currentTx
          };
          this.logger.debug("Interaction:", interaction);
          const interactionCall = contract.getCallStack().addInteractionData(interactionData);
          const result = await executionContext.handler.handle(executionContext, new EvalStateResult(currentState, validity), interactionData);
          errorMessage = result.errorMessage;
          this.logResult(result, interactionTx, executionContext);
          this.logger.debug("Interaction evaluation", singleInteractionBenchmark.elapsed());
          interactionCall.update({
            cacheHit: false,
            intermediaryCacheHit: false,
            outputState: stackTrace.saveState ? currentState : void 0,
            executionTime: singleInteractionBenchmark.elapsed(true),
            valid: validity[interactionTx.id],
            errorMessage,
            gasUsed: result.gasUsed
          });
          if (result.type === "exception" && ignoreExceptions !== true) {
            throw new Error(`Exception while processing ${JSON.stringify(interaction)}:
${result.errorMessage}`);
          }
          validity[interactionTx.id] = result.type === "ok";
          currentState = result.state;
          const toCache = new EvalStateResult(currentState, validity);
          if (canBeCached(interactionTx)) {
            lastConfirmedTxState = {
              tx: interactionTx,
              state: toCache
            };
          }
          await this.onStateUpdate(interactionTx, executionContext, toCache);
        }
        for (const { modify } of this.executionContextModifiers) {
          executionContext = await modify(currentState, executionContext);
        }
      }
      const evalStateResult = new EvalStateResult(currentState, validity);
      if (lastConfirmedTxState !== null) {
        await this.onStateEvaluated(lastConfirmedTxState.tx, executionContext, lastConfirmedTxState.state);
      }
      return evalStateResult;
    }
    logResult(result, currentTx, executionContext) {
      if (result.type === "exception") {
        this.logger.error(`Executing of interaction: [${executionContext.contractDefinition.txId} -> ${currentTx.id}] threw exception:`, `${result.errorMessage}`);
      }
      if (result.type === "error") {
        this.logger.warn(`Executing of interaction: [${executionContext.contractDefinition.txId} -> ${currentTx.id}] returned error:`, result.errorMessage);
      }
    }
    parseInput(inputTag) {
      try {
        return JSON.parse(inputTag.value);
      } catch (e) {
        this.logger.error(e);
        return null;
      }
    }
  };

  // src/utils/utils.ts
  var import_cloneDeep = __toModule(require_cloneDeep());
  var import_fast_copy = __toModule(require_fast_copy());
  var sleep = (ms) => {
    return new Promise((resolve) => setTimeout(resolve, ms));
  };
  var deepCopy = (input, useFastCopy = false) => {
    return useFastCopy ? (0, import_fast_copy.default)(input) : (0, import_cloneDeep.default)(input);
  };
  var mapReplacer = (key, value) => {
    if (value instanceof Map) {
      return {
        dataType: "Map",
        value: Array.from(value.entries())
      };
    } else {
      return value;
    }
  };
  var mapReviver = (key, value) => {
    if (typeof value === "object" && value !== null) {
      if (value.dataType === "Map") {
        return new Map(value.value);
      }
    }
    return value;
  };
  var asc = (a, b) => a - b;
  var ascS = (a, b) => +a - +b;
  var desc = (a, b) => b - a;
  var descS = (a, b) => +b - +a;
  function timeout(s) {
    let timeoutId = null;
    const timeoutPromise = new Promise((resolve, reject) => {
      timeoutId = setTimeout(() => {
        clearTimeout(timeoutId);
        reject("timeout");
      }, s * 1e3);
    });
    return {
      timeoutId,
      timeoutPromise
    };
  }
  function stripTrailingSlash(str) {
    return str.endsWith("/") ? str.slice(0, -1) : str;
  }

  // src/utils/ArweaveWrapper.ts
  var import_arweave = __toModule(require_web());
  var import_transaction2 = __toModule(require_transaction());
  var import_redstone_isomorphic4 = __toModule(require_npm_browser());
  var ArweaveWrapper = class {
    constructor(arweave) {
      this.arweave = arweave;
      this.logger = LoggerFactory.INST.create("ArweaveWrapper");
      this.baseUrl = `${arweave.api.config.protocol}://${arweave.api.config.host}:${arweave.api.config.port}`;
      this.logger.debug("baseurl", this.baseUrl);
    }
    async info() {
      try {
        const response = await fetch(`${this.baseUrl}/info`).then((res) => {
          return res.ok ? res.json() : Promise.reject(res);
        }).catch((error) => {
          var _a, _b;
          if ((_a = error.body) == null ? void 0 : _a.message) {
            this.logger.error(error.body.message);
          }
          throw new Error(`Unable to retrieve info. ${error.status}: ${(_b = error.body) == null ? void 0 : _b.message}`);
        });
        return response;
      } catch (e) {
        this.logger.error("Error while loading network info", e);
        throw e;
      }
    }
    async gql(query, variables) {
      try {
        const data = JSON.stringify({
          query,
          variables
        });
        const response = await fetch(`${this.baseUrl}/graphql`, {
          method: "POST",
          body: data,
          headers: {
            "Accept-Encoding": "gzip, deflate, br",
            "Content-Type": "application/json",
            Accept: "application/json"
          }
        }).then((res) => {
          return res.ok ? res.json() : Promise.reject(res);
        }).catch((error) => {
          var _a, _b;
          if ((_a = error.body) == null ? void 0 : _a.message) {
            this.logger.error(error.body.message);
          }
          throw new Error(`Unable to retrieve gql page. ${error.status}: ${(_b = error.body) == null ? void 0 : _b.message}`);
        });
        return {
          data: response,
          status: 200
        };
      } catch (e) {
        this.logger.error("Error while loading gql", e);
        throw e;
      }
    }
    async tx(id) {
      const response = await fetch(`${this.baseUrl}/tx/${id}`).then((res) => {
        return res.ok ? res.json() : Promise.reject(res);
      }).catch((error) => {
        var _a, _b;
        if ((_a = error.body) == null ? void 0 : _a.message) {
          this.logger.error(error.body.message);
        }
        throw new Error(`Unable to retrieve tx ${id}. ${error.status}. ${(_b = error.body) == null ? void 0 : _b.message}`);
      });
      return new import_transaction2.default(__spreadValues({}, response));
    }
    async txData(id) {
      const response = await fetch(`${this.baseUrl}/${id}`);
      if (!response.ok) {
        this.logger.warn(`Unable to load data from arweave.net/${id} endpoint, falling back to arweave.js`);
        const txData = await this.arweave.transactions.getData(id, {
          decode: true
        });
        return import_redstone_isomorphic4.Buffer.from(txData);
      } else {
        const buffer = await response.arrayBuffer();
        return import_redstone_isomorphic4.Buffer.from(buffer);
      }
    }
    async txDataString(id) {
      const buffer = await this.txData(id);
      return import_arweave.default.utils.bufferToString(buffer);
    }
  };

  // src/cache/impl/MemBlockHeightCache.ts
  var MemBlockHeightSwCache = class {
    constructor(maxStoredBlockHeights = Number.MAX_SAFE_INTEGER) {
      this.maxStoredBlockHeights = maxStoredBlockHeights;
      this.logger = LoggerFactory.INST.create("MemBlockHeightSwCache");
      this.storage = {};
    }
    async getLast(key) {
      if (!await this.contains(key)) {
        return null;
      }
      const cached = this.storage[key];
      const highestBlockHeight = [...cached.keys()].sort(asc).pop();
      return {
        cachedHeight: highestBlockHeight,
        cachedValue: deepCopy(cached.get(highestBlockHeight))
      };
    }
    async getLessOrEqual(key, blockHeight) {
      if (!await this.contains(key)) {
        return null;
      }
      const cached = this.storage[key];
      const highestBlockHeight = [...cached.keys()].sort(desc).find((cachedBlockHeight) => {
        return cachedBlockHeight <= blockHeight;
      });
      return highestBlockHeight === void 0 ? null : {
        cachedHeight: highestBlockHeight,
        cachedValue: deepCopy(cached.get(highestBlockHeight))
      };
    }
    async put({ cacheKey, blockHeight }, value) {
      this.putSync({ cacheKey, blockHeight }, value);
    }
    putSync({ cacheKey, blockHeight }, value) {
      if (!this.containsSync(cacheKey)) {
        this.storage[cacheKey] = new Map();
      }
      const cached = this.storage[cacheKey];
      if (cached.size >= this.maxStoredBlockHeights) {
        const toRemove = [...cached.keys()].sort(asc).shift();
        cached.delete(toRemove);
      }
      cached.set(blockHeight, value);
    }
    async contains(key) {
      return this.containsSync(key);
    }
    containsSync(key) {
      return Object.prototype.hasOwnProperty.call(this.storage, key);
    }
    async get(key, blockHeight, returnDeepCopy = true) {
      if (!await this.contains(key)) {
        return null;
      }
      if (!this.storage[key].has(blockHeight)) {
        return null;
      }
      return {
        cachedHeight: blockHeight,
        cachedValue: returnDeepCopy ? deepCopy(this.storage[key].get(blockHeight)) : this.storage[key].get(blockHeight)
      };
    }
    flush() {
      return Promise.resolve(void 0);
    }
  };

  // src/cache/impl/FileBlockHeightCache.ts
  var import_fs = __toModule(require_fs());
  var import_path = __toModule(require_path());

  // node_modules/safe-stable-stringify/esm/wrapper.js
  var import__ = __toModule(require_safe_stable_stringify());
  var configure = import__.default.configure;
  var wrapper_default = import__.default;

  // src/cache/impl/FileBlockHeightCache.ts
  var FileBlockHeightSwCache = class extends MemBlockHeightSwCache {
    constructor(basePath = import_path.default.join(__dirname, "storage", "state"), maxStoredInMemoryBlockHeights = Number.MAX_SAFE_INTEGER) {
      super(maxStoredInMemoryBlockHeights);
      this.basePath = basePath;
      this.fLogger = LoggerFactory.INST.create("FileBlockHeightSwCache");
      this.isFlushing = false;
      this.isDirty = false;
      this.saveCache = this.saveCache.bind(this);
      this.flush = this.flush.bind(this);
      if (!import_fs.default.existsSync(this.basePath)) {
        import_fs.default.mkdirSync(this.basePath);
      }
      const contracts = import_fs.default.readdirSync(this.basePath);
      this.fLogger.info("Loading cache from files");
      contracts.forEach((contract) => {
        const cacheDirPath = import_path.default.join(this.basePath, contract);
        if (this.storage[contract] == null) {
          this.storage[contract] = new Map();
        }
        const benchmark = Benchmark.measure();
        const files = import_fs.default.readdirSync(cacheDirPath);
        files.forEach((file) => {
          const cacheFilePath = import_path.default.join(cacheDirPath, file);
          const height = file.split(".")[0];
          const cacheValue = JSON.parse(import_fs.default.readFileSync(import_path.default.join(cacheFilePath), "utf-8"));
          this.putSync({ cacheKey: contract, blockHeight: +height }, cacheValue);
        });
        this.fLogger.info(`loading cache for ${contract}`, benchmark.elapsed());
        this.fLogger.debug(`Amount of elements loaded for ${contract} to mem: ${this.storage[contract].size}`);
      });
      this.fLogger.debug("Storage keys", this.storage);
      process.on("exit", async () => {
        await this.flush();
        process.exit();
      });
      process.on("SIGINT", async () => {
        await this.flush();
        process.exit();
      });
    }
    async saveCache() {
      this.isFlushing = true;
      this.fLogger.info(`==== Persisting cache ====`);
      try {
        const directoryPath = this.basePath;
        for (const key of Object.keys(this.storage)) {
          const directory = key;
          if (!import_fs.default.existsSync(import_path.default.join(directoryPath, directory))) {
            import_fs.default.mkdirSync(import_path.default.join(directoryPath, directory));
          }
          const toStore = await this.getLast(key);
          if (toStore !== null) {
            const { cachedHeight, cachedValue } = toStore;
            import_fs.default.writeFileSync(import_path.default.join(directoryPath, directory, `${cachedHeight}.cache.json`), wrapper_default(cachedValue));
          }
        }
        this.isDirty = false;
      } catch (e) {
        this.fLogger.error("Error while flushing cache", e);
      } finally {
        this.isFlushing = false;
        this.fLogger.info(`==== Cache persisted ====`);
      }
    }
    async put({ cacheKey, blockHeight }, value) {
      this.isDirty = true;
      return super.put({ cacheKey, blockHeight }, value);
    }
    async flush() {
      if (this.isFlushing || !this.isDirty) {
        return;
      }
      await this.saveCache();
    }
  };

  // src/cache/impl/KnexStateCache.ts
  var KnexStateCache = class extends MemBlockHeightSwCache {
    constructor(knex, maxStoredInMemoryBlockHeights = Number.MAX_SAFE_INTEGER, cache) {
      super(maxStoredInMemoryBlockHeights);
      this.knex = knex;
      this.kLogger = LoggerFactory.INST.create("KnexBlockHeightSwCache");
      this.lastFlushHeight = new Map();
      this.isFlushing = false;
      this.isDirty = false;
      this.saveCache = this.saveCache.bind(this);
      this.flush = this.flush.bind(this);
      this.kLogger.info(`Loaded ${cache.length} cache entries from db`);
      cache.forEach((entry) => {
        this.putSync({
          cacheKey: entry.contract_id,
          blockHeight: entry.height
        }, JSON.parse(entry.state));
        this.lastFlushHeight.set(entry.contract_id, entry.height);
      });
      process.on("exit", async () => {
        await this.flush();
        process.exit();
      });
      process.on("SIGINT", async () => {
        await this.flush();
        process.exit();
      });
    }
    static async init(knex, maxStoredInMemoryBlockHeights = Number.MAX_SAFE_INTEGER) {
      if (!await knex.schema.hasTable("states")) {
        await knex.schema.createTable("states", (table) => {
          table.string("contract_id", 64).notNullable().index();
          table.integer("height").notNullable().index();
          table.text("state").notNullable();
          table.unique(["contract_id", "height"], { indexName: "states_composite_index" });
        });
      }
      const cache = await knex.select(["contract_id", "height", "state"]).from("states").max("height").groupBy(["contract_id"]);
      return new KnexStateCache(knex, maxStoredInMemoryBlockHeights, cache);
    }
    async saveCache() {
      this.isFlushing = true;
      this.kLogger.info(`==== Persisting cache ====`);
      try {
        const contracts = Object.keys(this.storage);
        for (const contractTxId of contracts) {
          const toStore = await this.getLast(contractTxId);
          if (toStore !== null) {
            const { cachedHeight, cachedValue } = toStore;
            if (this.lastFlushHeight.has(contractTxId) && this.lastFlushHeight.get(contractTxId) >= cachedHeight) {
              continue;
            }
            const jsonState = wrapper_default(cachedValue);
            await this.knex.insert({
              contract_id: contractTxId,
              height: cachedHeight,
              state: jsonState
            }).into("states").onConflict(["contract_id", "height"]).merge();
            this.lastFlushHeight.set(contractTxId, cachedHeight);
          }
        }
        this.isDirty = false;
      } catch (e) {
        this.kLogger.error("Error while flushing cache", e);
      } finally {
        this.isFlushing = false;
        this.kLogger.info(`==== Cache persisted ====`);
      }
    }
    async put({ cacheKey, blockHeight }, value) {
      this.isDirty = true;
      return super.put({ cacheKey, blockHeight }, value);
    }
    async flush() {
      if (this.isFlushing || !this.isDirty) {
        return;
      }
      await this.saveCache();
    }
  };

  // src/cache/impl/RemoteBlockHeightCache.ts
  var import_axios = __toModule(require_axios2());
  var RemoteBlockHeightCache = class {
    constructor(type, baseURL) {
      this.type = type;
      this.baseURL = baseURL;
      this.axios = import_axios.default.create({
        baseURL
      });
    }
    async getLast(key) {
      const response = await this.axios.get(`/last/${this.type}/${key}`);
      return response.data || null;
    }
    async getLessOrEqual(key, blockHeight) {
      const response = await this.axios.get(`/less-or-equal/${this.type}/${key}/${blockHeight}`);
      return response.data || null;
    }
    async put({ cacheKey, blockHeight }, value) {
      if (!value) {
        return;
      }
      await this.axios.put(`/${this.type}/${cacheKey}/${blockHeight}`, value);
    }
    async contains(key) {
      const response = await this.axios.get(`/contains/${this.type}/${key}`);
      return response.data;
    }
    async get(key, blockHeight) {
      const response = await this.axios.get(`/${this.type}/${key}/${blockHeight}`);
      return response.data || null;
    }
    flush() {
      return Promise.resolve(void 0);
    }
  };

  // src/cache/impl/MemCache.ts
  var MemCache = class {
    constructor() {
      this.storage = {};
    }
    clearAll() {
      Object.keys(this.storage).forEach((key) => {
        delete this.storage[key];
      });
    }
    contains(key) {
      return Object.prototype.hasOwnProperty.call(this.storage, key);
    }
    get(key) {
      return this.storage[key];
    }
    put(key, value) {
      this.storage[key] = value;
    }
    remove(key) {
      delete this.storage[key];
    }
  };

  // src/cache/BlockHeightSwCache.ts
  var BlockHeightKey3 = class {
    constructor(cacheKey, blockHeight) {
      this.cacheKey = cacheKey;
      this.blockHeight = blockHeight;
    }
  };
  var BlockHeightCacheResult2 = class {
    constructor(cachedHeight, cachedValue) {
      this.cachedHeight = cachedHeight;
      this.cachedValue = cachedValue;
    }
  };

  // src/core/modules/impl/CacheableStateEvaluator.ts
  var CacheableStateEvaluator = class extends DefaultStateEvaluator {
    constructor(arweave, cache, executionContextModifiers = []) {
      super(arweave, executionContextModifiers);
      this.cache = cache;
      this.cLogger = LoggerFactory.INST.create("CacheableStateEvaluator");
    }
    async eval(executionContext, currentTx) {
      var _a, _b;
      const requestedBlockHeight = executionContext.blockHeight;
      this.cLogger.debug(`Requested state block height: ${requestedBlockHeight}`);
      const cachedState = executionContext.cachedState;
      if ((cachedState == null ? void 0 : cachedState.cachedHeight) === requestedBlockHeight) {
        (_a = executionContext.handler) == null ? void 0 : _a.initState(cachedState.cachedValue.state);
        return cachedState.cachedValue;
      }
      this.cLogger.debug("executionContext.sortedInteractions", executionContext.sortedInteractions.length);
      const sortedInteractionsUpToBlock = executionContext.sortedInteractions.filter((tx) => {
        return tx.node.block.height <= executionContext.blockHeight;
      });
      let missingInteractions = sortedInteractionsUpToBlock.slice();
      this.cLogger.debug("missingInteractions", missingInteractions.length);
      if (sortedInteractionsUpToBlock.length > 0) {
        if (cachedState != null) {
          this.cLogger.debug(`Cached state for ${executionContext.contractDefinition.txId}`, {
            cachedHeight: cachedState.cachedHeight,
            requestedBlockHeight
          });
          missingInteractions = sortedInteractionsUpToBlock.filter(({ node }) => node.block.height > cachedState.cachedHeight && node.block.height <= requestedBlockHeight);
        }
        this.cLogger.debug(`Interactions until [${requestedBlockHeight}]`, {
          total: sortedInteractionsUpToBlock.length,
          cached: sortedInteractionsUpToBlock.length - missingInteractions.length
        });
        for (const entry of currentTx || []) {
          if (entry.contractTxId === executionContext.contractDefinition.txId) {
            const index = missingInteractions.findIndex((tx) => tx.node.id === entry.interactionTxId);
            if (index !== -1) {
              this.cLogger.debug("Inf. Loop fix - removing interaction", {
                height: missingInteractions[index].node.block.height,
                contractTxId: entry.contractTxId,
                interactionTxId: entry.interactionTxId
              });
              missingInteractions.splice(index);
            }
          }
        }
        if (missingInteractions.length === 0 && cachedState) {
          this.cLogger.debug(`State up to requested height [${requestedBlockHeight}] fully cached!`);
          (_b = executionContext.handler) == null ? void 0 : _b.initState(cachedState.cachedValue.state);
          return cachedState.cachedValue;
        }
      }
      const baseState = cachedState == null ? executionContext.contractDefinition.initState : cachedState.cachedValue.state;
      const baseValidity = cachedState == null ? {} : cachedState.cachedValue.validity;
      return await this.doReadState(missingInteractions, new EvalStateResult(baseState, baseValidity), executionContext, currentTx);
    }
    async onStateEvaluated(transaction, executionContext, state) {
      const contractTxId = executionContext.contractDefinition.txId;
      this.cLogger.debug(`onStateEvaluated: cache update for contract ${contractTxId} [${transaction.block.height}]`);
      await this.putInCache(contractTxId, transaction, state, executionContext.blockHeight, executionContext.containsInteractionsFromSequencer);
      if (!executionContext.evaluationOptions.manualCacheFlush) {
        await this.cache.flush();
      }
    }
    async onStateUpdate(transaction, executionContext, state) {
      if (executionContext.evaluationOptions.updateCacheForEachInteraction || executionContext.evaluationOptions.internalWrites) {
        await this.putInCache(executionContext.contractDefinition.txId, transaction, state, executionContext.blockHeight, executionContext.containsInteractionsFromSequencer);
      }
    }
    async latestAvailableState(contractTxId, blockHeight) {
      this.cLogger.debug("Searching for", { contractTxId, blockHeight });
      const stateCache = await this.cache.getLessOrEqual(contractTxId, blockHeight);
      this.cLogger.debug("Latest available state at", stateCache == null ? void 0 : stateCache.cachedHeight);
      if (stateCache == null) {
        return null;
      }
      return new BlockHeightCacheResult2(stateCache.cachedHeight, stateCache.cachedValue);
    }
    async onInternalWriteStateUpdate(transaction, contractTxId, state) {
      this.cLogger.debug("Internal write state update:", {
        height: transaction.block.height,
        contractTxId,
        state
      });
      await this.putInCache(contractTxId, transaction, state);
    }
    async onContractCall(transaction, executionContext, state) {
      await this.putInCache(executionContext.contractDefinition.txId, transaction, state);
    }
    async putInCache(contractTxId, transaction, state, requestedBlockHeight = null, containsInteractionsFromSequencer = false) {
      if (transaction.dry) {
        return;
      }
      if (transaction.confirmationStatus !== void 0 && transaction.confirmationStatus !== "confirmed") {
        return;
      }
      const blockHeight = transaction.block.height;
      if (requestedBlockHeight !== null && blockHeight >= requestedBlockHeight - 1 && containsInteractionsFromSequencer) {
        this.cLogger.debug("skipping caching of the last blocks");
        return;
      }
      const transactionId = transaction.id;
      const stateToCache = new EvalStateResult(state.state, state.validity, transactionId, transaction.block.id);
      await this.cache.put(new BlockHeightKey3(contractTxId, blockHeight), stateToCache);
    }
    async flushCache() {
      return await this.cache.flush();
    }
  };

  // src/core/modules/impl/ContractHandlerApi.ts
  var ContractHandlerApi = class {
    constructor(swGlobal, contractFunction, contractDefinition) {
      this.swGlobal = swGlobal;
      this.contractFunction = contractFunction;
      this.contractDefinition = contractDefinition;
      this.logger = LoggerFactory.INST.create("ContractHandlerApi");
      this.contractLogger = LoggerFactory.INST.create(swGlobal.contract.id);
      this.assignReadContractState = this.assignReadContractState.bind(this);
      this.assignViewContractState = this.assignViewContractState.bind(this);
      this.assignWrite = this.assignWrite.bind(this);
      this.assignRefreshState = this.assignRefreshState.bind(this);
    }
    async handle(executionContext, currentResult, interactionData) {
      const { timeoutId, timeoutPromise } = timeout(executionContext.evaluationOptions.maxInteractionEvaluationTimeSeconds);
      try {
        const { interaction, interactionTx, currentTx } = interactionData;
        const stateCopy = deepCopy(currentResult.state, executionContext.evaluationOptions.useFastCopy);
        this.swGlobal._activeTx = interactionTx;
        this.swGlobal.caller = interaction.caller;
        this.assignReadContractState(executionContext, currentTx, currentResult, interactionTx);
        this.assignViewContractState(executionContext);
        this.assignWrite(executionContext, currentTx);
        this.assignRefreshState(executionContext);
        const handlerResult = await Promise.race([timeoutPromise, this.contractFunction(stateCopy, interaction)]);
        if (handlerResult && (handlerResult.state || handlerResult.result)) {
          return {
            type: "ok",
            result: handlerResult.result,
            state: handlerResult.state || currentResult.state
          };
        }
        throw new Error(`Unexpected result from contract: ${JSON.stringify(handlerResult)}`);
      } catch (err) {
        switch (err.name) {
          case "ContractError":
            return {
              type: "error",
              errorMessage: err.message,
              state: currentResult.state,
              result: null
            };
          default:
            return {
              type: "exception",
              errorMessage: `${err && err.stack || err && err.message || err}`,
              state: currentResult.state,
              result: null
            };
        }
      } finally {
        if (timeoutId !== null) {
          clearTimeout(timeoutId);
        }
      }
    }
    assignWrite(executionContext, currentTx) {
      this.swGlobal.contracts.write = async (contractTxId, input) => {
        if (!executionContext.evaluationOptions.internalWrites) {
          throw new Error("Internal writes feature switched off. Change EvaluationOptions.internalWrites flag to 'true'");
        }
        this.logger.debug("swGlobal.write call:", {
          from: this.contractDefinition.txId,
          to: contractTxId,
          input
        });
        const calleeContract = executionContext.smartweave.contract(contractTxId, executionContext.contract, this.swGlobal._activeTx);
        const result = await calleeContract.dryWriteFromTx(input, this.swGlobal._activeTx, [
          ...currentTx || [],
          {
            contractTxId: this.contractDefinition.txId,
            interactionTxId: this.swGlobal.transaction.id
          }
        ]);
        this.logger.debug("Cache result?:", !this.swGlobal._activeTx.dry);
        await executionContext.smartweave.stateEvaluator.onInternalWriteStateUpdate(this.swGlobal._activeTx, contractTxId, {
          state: result.state,
          validity: {}
        });
        return result;
      };
    }
    assignViewContractState(executionContext) {
      this.swGlobal.contracts.viewContractState = async (contractTxId, input) => {
        this.logger.debug("swGlobal.viewContractState call:", {
          from: this.contractDefinition.txId,
          to: contractTxId,
          input
        });
        const childContract = executionContext.smartweave.contract(contractTxId, executionContext.contract, this.swGlobal._activeTx);
        return await childContract.viewStateForTx(input, this.swGlobal._activeTx);
      };
    }
    assignReadContractState(executionContext, currentTx, currentResult, interactionTx) {
      this.swGlobal.contracts.readContractState = async (contractTxId, height, returnValidity) => {
        const requestedHeight = height || this.swGlobal.block.height;
        this.logger.debug("swGlobal.readContractState call:", {
          from: this.contractDefinition.txId,
          to: contractTxId,
          height: requestedHeight,
          transaction: this.swGlobal.transaction.id
        });
        const { stateEvaluator } = executionContext.smartweave;
        const childContract = executionContext.smartweave.contract(contractTxId, executionContext.contract, interactionTx);
        await stateEvaluator.onContractCall(interactionTx, executionContext, currentResult);
        const stateWithValidity = await childContract.readState(requestedHeight, [
          ...currentTx || [],
          {
            contractTxId: this.contractDefinition.txId,
            interactionTxId: this.swGlobal.transaction.id
          }
        ]);
        return returnValidity ? deepCopy(stateWithValidity) : deepCopy(stateWithValidity.state);
      };
    }
    assignRefreshState(executionContext) {
      this.swGlobal.contracts.refreshState = async () => {
        const stateEvaluator = executionContext.smartweave.stateEvaluator;
        const result = await stateEvaluator.latestAvailableState(this.swGlobal.contract.id, this.swGlobal.block.height);
        return result == null ? void 0 : result.cachedValue.state;
      };
    }
    initState(state) {
    }
  };

  // node_modules/@assemblyscript/loader/index.js
  var ID_OFFSET = -8;
  var SIZE_OFFSET = -4;
  var ARRAYBUFFER_ID = 0;
  var STRING_ID = 1;
  var ARRAYBUFFERVIEW = 1 << 0;
  var ARRAY = 1 << 1;
  var STATICARRAY = 1 << 2;
  var VAL_ALIGN_OFFSET = 6;
  var VAL_SIGNED = 1 << 11;
  var VAL_FLOAT = 1 << 12;
  var VAL_MANAGED = 1 << 14;
  var ARRAYBUFFERVIEW_BUFFER_OFFSET = 0;
  var ARRAYBUFFERVIEW_DATASTART_OFFSET = 4;
  var ARRAYBUFFERVIEW_BYTELENGTH_OFFSET = 8;
  var ARRAYBUFFERVIEW_SIZE = 12;
  var ARRAY_LENGTH_OFFSET = 12;
  var ARRAY_SIZE = 16;
  var E_NO_EXPORT_TABLE = "Operation requires compiling with --exportTable";
  var E_NO_EXPORT_RUNTIME = "Operation requires compiling with --exportRuntime";
  var F_NO_EXPORT_RUNTIME = () => {
    throw Error(E_NO_EXPORT_RUNTIME);
  };
  var BIGINT = typeof BigUint64Array !== "undefined";
  var THIS = Symbol();
  var STRING_SMALLSIZE = 192;
  var STRING_CHUNKSIZE = 1024;
  var utf16 = new TextDecoder("utf-16le", { fatal: true });
  Object.hasOwn = Object.hasOwn || function(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
  };
  function getStringImpl(buffer, ptr) {
    let len = new Uint32Array(buffer)[ptr + SIZE_OFFSET >>> 2] >>> 1;
    const wtf16 = new Uint16Array(buffer, ptr, len);
    if (len <= STRING_SMALLSIZE)
      return String.fromCharCode(...wtf16);
    try {
      return utf16.decode(wtf16);
    } catch (e) {
      let str = "", off = 0;
      while (len - off > STRING_CHUNKSIZE) {
        str += String.fromCharCode(...wtf16.subarray(off, off += STRING_CHUNKSIZE));
      }
      return str + String.fromCharCode(...wtf16.subarray(off));
    }
  }
  function preInstantiate(imports) {
    const extendedExports = {};
    function getString(memory, ptr) {
      if (!memory)
        return "<yet unknown>";
      return getStringImpl(memory.buffer, ptr);
    }
    const env = imports.env = imports.env || {};
    env.abort = env.abort || function abort(msg, file, line, colm) {
      const memory = extendedExports.memory || env.memory;
      throw Error(`abort: ${getString(memory, msg)} at ${getString(memory, file)}:${line}:${colm}`);
    };
    env.trace = env.trace || function trace(msg, n, ...args) {
      const memory = extendedExports.memory || env.memory;
      console.log(`trace: ${getString(memory, msg)}${n ? " " : ""}${args.slice(0, n).join(", ")}`);
    };
    env.seed = env.seed || Date.now;
    imports.Math = imports.Math || Math;
    imports.Date = imports.Date || Date;
    return extendedExports;
  }
  function postInstantiate(extendedExports, instance) {
    const exports = instance.exports;
    const memory = exports.memory;
    const table = exports.table;
    const __new = exports.__new || F_NO_EXPORT_RUNTIME;
    const __pin = exports.__pin || F_NO_EXPORT_RUNTIME;
    const __unpin = exports.__unpin || F_NO_EXPORT_RUNTIME;
    const __collect = exports.__collect || F_NO_EXPORT_RUNTIME;
    const __rtti_base = exports.__rtti_base;
    const getRttiCount = __rtti_base ? (arr) => arr[__rtti_base >>> 2] : F_NO_EXPORT_RUNTIME;
    extendedExports.__new = __new;
    extendedExports.__pin = __pin;
    extendedExports.__unpin = __unpin;
    extendedExports.__collect = __collect;
    function getRttInfo(id) {
      const U32 = new Uint32Array(memory.buffer);
      if ((id >>>= 0) >= getRttiCount(U32))
        throw Error(`invalid id: ${id}`);
      return U32[(__rtti_base + 4 >>> 2) + (id << 1)];
    }
    function getRttBase(id) {
      const U32 = new Uint32Array(memory.buffer);
      if ((id >>>= 0) >= getRttiCount(U32))
        throw Error(`invalid id: ${id}`);
      return U32[(__rtti_base + 4 >>> 2) + (id << 1) + 1];
    }
    function getArrayInfo(id) {
      const info = getRttInfo(id);
      if (!(info & (ARRAYBUFFERVIEW | ARRAY | STATICARRAY)))
        throw Error(`not an array: ${id}, flags=${info}`);
      return info;
    }
    function getValueAlign(info) {
      return 31 - Math.clz32(info >>> VAL_ALIGN_OFFSET & 31);
    }
    function __newString(str) {
      if (str == null)
        return 0;
      const length = str.length;
      const ptr = __new(length << 1, STRING_ID);
      const U16 = new Uint16Array(memory.buffer);
      for (var i = 0, p = ptr >>> 1; i < length; ++i)
        U16[p + i] = str.charCodeAt(i);
      return ptr;
    }
    extendedExports.__newString = __newString;
    function __newArrayBuffer(buf) {
      if (buf == null)
        return 0;
      const bufview = new Uint8Array(buf);
      const ptr = __new(bufview.length, ARRAYBUFFER_ID);
      const U8 = new Uint8Array(memory.buffer);
      U8.set(bufview, ptr);
      return ptr;
    }
    extendedExports.__newArrayBuffer = __newArrayBuffer;
    function __getString(ptr) {
      if (!ptr)
        return null;
      const buffer = memory.buffer;
      const id = new Uint32Array(buffer)[ptr + ID_OFFSET >>> 2];
      if (id !== STRING_ID)
        throw Error(`not a string: ${ptr}`);
      return getStringImpl(buffer, ptr);
    }
    extendedExports.__getString = __getString;
    function getView(alignLog2, signed, float) {
      const buffer = memory.buffer;
      if (float) {
        switch (alignLog2) {
          case 2:
            return new Float32Array(buffer);
          case 3:
            return new Float64Array(buffer);
        }
      } else {
        switch (alignLog2) {
          case 0:
            return new (signed ? Int8Array : Uint8Array)(buffer);
          case 1:
            return new (signed ? Int16Array : Uint16Array)(buffer);
          case 2:
            return new (signed ? Int32Array : Uint32Array)(buffer);
          case 3:
            return new (signed ? BigInt64Array : BigUint64Array)(buffer);
        }
      }
      throw Error(`unsupported align: ${alignLog2}`);
    }
    function __newArray(id, valuesOrCapacity = 0) {
      const input = valuesOrCapacity;
      const info = getArrayInfo(id);
      const align = getValueAlign(info);
      const isArrayLike = typeof input !== "number";
      const length = isArrayLike ? input.length : input;
      const buf = __new(length << align, info & STATICARRAY ? id : ARRAYBUFFER_ID);
      let result;
      if (info & STATICARRAY) {
        result = buf;
      } else {
        __pin(buf);
        const arr = __new(info & ARRAY ? ARRAY_SIZE : ARRAYBUFFERVIEW_SIZE, id);
        __unpin(buf);
        const U32 = new Uint32Array(memory.buffer);
        U32[arr + ARRAYBUFFERVIEW_BUFFER_OFFSET >>> 2] = buf;
        U32[arr + ARRAYBUFFERVIEW_DATASTART_OFFSET >>> 2] = buf;
        U32[arr + ARRAYBUFFERVIEW_BYTELENGTH_OFFSET >>> 2] = length << align;
        if (info & ARRAY)
          U32[arr + ARRAY_LENGTH_OFFSET >>> 2] = length;
        result = arr;
      }
      if (isArrayLike) {
        const view = getView(align, info & VAL_SIGNED, info & VAL_FLOAT);
        const start = buf >>> align;
        if (info & VAL_MANAGED) {
          for (let i = 0; i < length; ++i) {
            view[start + i] = input[i];
          }
        } else {
          view.set(input, start);
        }
      }
      return result;
    }
    extendedExports.__newArray = __newArray;
    function __getArrayView(arr) {
      const U32 = new Uint32Array(memory.buffer);
      const id = U32[arr + ID_OFFSET >>> 2];
      const info = getArrayInfo(id);
      const align = getValueAlign(info);
      let buf = info & STATICARRAY ? arr : U32[arr + ARRAYBUFFERVIEW_DATASTART_OFFSET >>> 2];
      const length = info & ARRAY ? U32[arr + ARRAY_LENGTH_OFFSET >>> 2] : U32[buf + SIZE_OFFSET >>> 2] >>> align;
      return getView(align, info & VAL_SIGNED, info & VAL_FLOAT).subarray(buf >>>= align, buf + length);
    }
    extendedExports.__getArrayView = __getArrayView;
    function __getArray(arr) {
      const input = __getArrayView(arr);
      const len = input.length;
      const out = new Array(len);
      for (let i = 0; i < len; i++)
        out[i] = input[i];
      return out;
    }
    extendedExports.__getArray = __getArray;
    function __getArrayBuffer(ptr) {
      const buffer = memory.buffer;
      const length = new Uint32Array(buffer)[ptr + SIZE_OFFSET >>> 2];
      return buffer.slice(ptr, ptr + length);
    }
    extendedExports.__getArrayBuffer = __getArrayBuffer;
    function __getFunction(ptr) {
      if (!table)
        throw Error(E_NO_EXPORT_TABLE);
      const index = new Uint32Array(memory.buffer)[ptr >>> 2];
      return table.get(index);
    }
    extendedExports.__getFunction = __getFunction;
    function getTypedArray(Type, alignLog2, ptr) {
      return new Type(getTypedArrayView(Type, alignLog2, ptr));
    }
    function getTypedArrayView(Type, alignLog2, ptr) {
      const buffer = memory.buffer;
      const U32 = new Uint32Array(buffer);
      return new Type(buffer, U32[ptr + ARRAYBUFFERVIEW_DATASTART_OFFSET >>> 2], U32[ptr + ARRAYBUFFERVIEW_BYTELENGTH_OFFSET >>> 2] >>> alignLog2);
    }
    function attachTypedArrayFunctions(ctor, name, align) {
      extendedExports[`__get${name}`] = getTypedArray.bind(null, ctor, align);
      extendedExports[`__get${name}View`] = getTypedArrayView.bind(null, ctor, align);
    }
    [
      Int8Array,
      Uint8Array,
      Uint8ClampedArray,
      Int16Array,
      Uint16Array,
      Int32Array,
      Uint32Array,
      Float32Array,
      Float64Array
    ].forEach((ctor) => {
      attachTypedArrayFunctions(ctor, ctor.name, 31 - Math.clz32(ctor.BYTES_PER_ELEMENT));
    });
    if (BIGINT) {
      [BigUint64Array, BigInt64Array].forEach((ctor) => {
        attachTypedArrayFunctions(ctor, ctor.name.slice(3), 3);
      });
    }
    function __instanceof(ptr, baseId) {
      const U32 = new Uint32Array(memory.buffer);
      let id = U32[ptr + ID_OFFSET >>> 2];
      if (id <= getRttiCount(U32)) {
        do {
          if (id == baseId)
            return true;
          id = getRttBase(id);
        } while (id);
      }
      return false;
    }
    extendedExports.__instanceof = __instanceof;
    extendedExports.memory = extendedExports.memory || memory;
    extendedExports.table = extendedExports.table || table;
    return demangle(exports, extendedExports);
  }
  function isResponse(src) {
    return typeof Response !== "undefined" && src instanceof Response;
  }
  function isModule(src) {
    return src instanceof WebAssembly.Module;
  }
  async function instantiate(source, imports = {}) {
    if (isResponse(source = await source))
      return instantiateStreaming(source, imports);
    const module2 = isModule(source) ? source : await WebAssembly.compile(source);
    const extended = preInstantiate(imports);
    const instance = await WebAssembly.instantiate(module2, imports);
    const exports = postInstantiate(extended, instance);
    return { module: module2, instance, exports };
  }
  function instantiateSync(source, imports = {}) {
    const module2 = isModule(source) ? source : new WebAssembly.Module(source);
    const extended = preInstantiate(imports);
    const instance = new WebAssembly.Instance(module2, imports);
    const exports = postInstantiate(extended, instance);
    return { module: module2, instance, exports };
  }
  async function instantiateStreaming(source, imports = {}) {
    if (!WebAssembly.instantiateStreaming) {
      return instantiate(isResponse(source = await source) ? source.arrayBuffer() : source, imports);
    }
    const extended = preInstantiate(imports);
    const result = await WebAssembly.instantiateStreaming(source, imports);
    const exports = postInstantiate(extended, result.instance);
    return __spreadProps(__spreadValues({}, result), { exports });
  }
  function demangle(exports, extendedExports = {}) {
    const setArgumentsLength = exports["__argumentsLength"] ? (length) => {
      exports["__argumentsLength"].value = length;
    } : exports["__setArgumentsLength"] || exports["__setargc"] || (() => {
    });
    for (let internalName of Object.keys(exports)) {
      const elem = exports[internalName];
      let parts = internalName.split(".");
      let curr = extendedExports;
      while (parts.length > 1) {
        let part = parts.shift();
        if (!Object.hasOwn(curr, part))
          curr[part] = {};
        curr = curr[part];
      }
      let name = parts[0];
      let hash = name.indexOf("#");
      if (hash >= 0) {
        const className = name.substring(0, hash);
        const classElem = curr[className];
        if (typeof classElem === "undefined" || !classElem.prototype) {
          const ctor = function(...args) {
            return ctor.wrap(ctor.prototype.constructor(0, ...args));
          };
          ctor.prototype = {
            valueOf() {
              return this[THIS];
            }
          };
          ctor.wrap = function(thisValue) {
            return Object.create(ctor.prototype, { [THIS]: { value: thisValue, writable: false } });
          };
          if (classElem)
            Object.getOwnPropertyNames(classElem).forEach((name2) => Object.defineProperty(ctor, name2, Object.getOwnPropertyDescriptor(classElem, name2)));
          curr[className] = ctor;
        }
        name = name.substring(hash + 1);
        curr = curr[className].prototype;
        if (/^(get|set):/.test(name)) {
          if (!Object.hasOwn(curr, name = name.substring(4))) {
            let getter = exports[internalName.replace("set:", "get:")];
            let setter = exports[internalName.replace("get:", "set:")];
            Object.defineProperty(curr, name, {
              get() {
                return getter(this[THIS]);
              },
              set(value) {
                setter(this[THIS], value);
              },
              enumerable: true
            });
          }
        } else {
          if (name === "constructor") {
            (curr[name] = function(...args) {
              setArgumentsLength(args.length);
              return elem(...args);
            }).original = elem;
          } else {
            (curr[name] = function(...args) {
              setArgumentsLength(args.length);
              return elem(this[THIS], ...args);
            }).original = elem;
          }
        }
      } else {
        if (/^(get|set):/.test(name)) {
          if (!Object.hasOwn(curr, name = name.substring(4))) {
            Object.defineProperty(curr, name, {
              get: exports[internalName.replace("set:", "get:")],
              set: exports[internalName.replace("get:", "set:")],
              enumerable: true
            });
          }
        } else if (typeof elem === "function" && elem !== setArgumentsLength) {
          (curr[name] = (...args) => {
            setArgumentsLength(args.length);
            return elem(...args);
          }).original = elem;
        } else {
          curr[name] = elem;
        }
      }
    }
    return extendedExports;
  }
  var loader_default = {
    instantiate,
    instantiateSync,
    instantiateStreaming,
    demangle
  };

  // src/core/modules/impl/WasmContractHandlerApi.ts
  var WasmContractHandlerApi = class {
    constructor(swGlobal, contractDefinition, wasmExports) {
      this.swGlobal = swGlobal;
      this.contractDefinition = contractDefinition;
      this.wasmExports = wasmExports;
      this.logger = LoggerFactory.INST.create("WasmContractHandlerApi");
      this.contractLogger = LoggerFactory.INST.create(swGlobal.contract.id);
    }
    async handle(executionContext, currentResult, interactionData) {
      try {
        const { interaction, interactionTx, currentTx } = interactionData;
        this.swGlobal._activeTx = interactionTx;
        this.swGlobal.caller = interaction.caller;
        this.swGlobal.gasLimit = executionContext.evaluationOptions.gasLimit;
        this.swGlobal.gasUsed = 0;
        this.assignReadContractState(executionContext, currentTx, currentResult, interactionTx);
        this.assignWrite(executionContext, currentTx);
        const handlerResult = await this.doHandle(interaction);
        return {
          type: "ok",
          result: handlerResult,
          state: this.doGetCurrentState(),
          gasUsed: this.swGlobal.gasUsed
        };
      } catch (e) {
        const result = {
          errorMessage: e.message,
          state: currentResult.state,
          result: null
        };
        if (e.message.startsWith("[RE:")) {
          this.logger.fatal(e);
          return __spreadProps(__spreadValues({}, result), {
            type: "exception"
          });
        } else {
          return __spreadProps(__spreadValues({}, result), {
            type: "error"
          });
        }
      }
    }
    initState(state) {
      switch (this.contractDefinition.srcWasmLang) {
        case "assemblyscript": {
          const statePtr = this.wasmExports.__newString(wrapper_default(state));
          this.wasmExports.initState(statePtr);
          break;
        }
        case "rust": {
          this.wasmExports.initState(state);
          break;
        }
        case "go": {
          this.wasmExports.initState(wrapper_default(state));
          break;
        }
        default: {
          throw new Error(`Support for ${this.contractDefinition.srcWasmLang} not implemented yet.`);
        }
      }
    }
    async doHandle(action) {
      switch (this.contractDefinition.srcWasmLang) {
        case "assemblyscript": {
          const actionPtr = this.wasmExports.__newString(wrapper_default(action.input));
          const resultPtr = this.wasmExports.handle(actionPtr);
          const result = this.wasmExports.__getString(resultPtr);
          return JSON.parse(result);
        }
        case "rust": {
          let handleResult2 = await this.wasmExports.handle(action.input);
          if (!handleResult2) {
            return;
          }
          if (Object.prototype.hasOwnProperty.call(handleResult2, "Ok")) {
            return handleResult2.Ok;
          } else {
            this.logger.debug("Error from rust", handleResult2.Err);
            let errorKey;
            let errorArgs = "";
            if (typeof handleResult2.Err === "string" || handleResult2.Err instanceof String) {
              errorKey = handleResult2.Err;
            } else {
              errorKey = Object.keys(handleResult2.Err)[0];
              errorArgs = " " + handleResult2.Err[errorKey];
            }
            if (errorKey == "RuntimeError") {
              throw new Error(`[RE:RE]${errorArgs}`);
            } else {
              throw new Error(`[CE:${errorKey}${errorArgs}]`);
            }
          }
        }
        case "go": {
          const result = await this.wasmExports.handle(wrapper_default(action.input));
          return JSON.parse(result);
        }
        default: {
          throw new Error(`Support for ${this.contractDefinition.srcWasmLang} not implemented yet.`);
        }
      }
    }
    doGetCurrentState() {
      switch (this.contractDefinition.srcWasmLang) {
        case "assemblyscript": {
          const currentStatePtr = this.wasmExports.currentState();
          return JSON.parse(this.wasmExports.__getString(currentStatePtr));
        }
        case "rust": {
          return this.wasmExports.currentState();
        }
        case "go": {
          const result = this.wasmExports.currentState();
          return JSON.parse(result);
        }
        default: {
          throw new Error(`Support for ${this.contractDefinition.srcWasmLang} not implemented yet.`);
        }
      }
    }
    assignReadContractState(executionContext, currentTx, currentResult, interactionTx) {
      this.swGlobal.contracts.readContractState = async (contractTxId, height, returnValidity) => {
        const requestedHeight = height || this.swGlobal.block.height;
        this.logger.debug("swGlobal.readContractState call:", {
          from: this.contractDefinition.txId,
          to: contractTxId,
          height: requestedHeight,
          transaction: this.swGlobal.transaction.id
        });
        const { stateEvaluator } = executionContext.smartweave;
        const childContract = executionContext.smartweave.contract(contractTxId, executionContext.contract, interactionTx);
        await stateEvaluator.onContractCall(interactionTx, executionContext, currentResult);
        const stateWithValidity = await childContract.readState(requestedHeight, [
          ...currentTx || [],
          {
            contractTxId: this.contractDefinition.txId,
            interactionTxId: this.swGlobal.transaction.id
          }
        ]);
        return returnValidity ? deepCopy(stateWithValidity) : deepCopy(stateWithValidity.state);
      };
    }
    assignWrite(executionContext, currentTx) {
      this.swGlobal.contracts.write = async (contractTxId, input) => {
        if (!executionContext.evaluationOptions.internalWrites) {
          throw new Error("Internal writes feature switched off. Change EvaluationOptions.internalWrites flag to 'true'");
        }
        this.logger.debug("swGlobal.write call:", {
          from: this.contractDefinition.txId,
          to: contractTxId,
          input
        });
        const calleeContract = executionContext.smartweave.contract(contractTxId, executionContext.contract, this.swGlobal._activeTx);
        const result = await calleeContract.dryWriteFromTx(input, this.swGlobal._activeTx, [
          ...currentTx || [],
          {
            contractTxId: this.contractDefinition.txId,
            interactionTxId: this.swGlobal.transaction.id
          }
        ]);
        this.logger.debug("Cache result?:", !this.swGlobal._activeTx.dry);
        await executionContext.smartweave.stateEvaluator.onInternalWriteStateUpdate(this.swGlobal._activeTx, contractTxId, {
          state: result.state,
          validity: {}
        });
        return result;
      };
    }
  };

  // src/core/modules/impl/wasm/as-wasm-imports.ts
  var asWasmImports = (swGlobal, wasmInstance) => {
    const wasmLogger = LoggerFactory.INST.create("WASM:AS");
    return {
      metering: {
        usegas: swGlobal.useGas
      },
      console: {
        "console.log": function(msgPtr) {
          wasmLogger.debug(`${swGlobal.contract.id}: ${wasmInstance.exports.__getString(msgPtr)}`);
        },
        "console.logO": function(msgPtr, objPtr) {
          wasmLogger.debug(`${swGlobal.contract.id}: ${wasmInstance.exports.__getString(msgPtr)}`, JSON.parse(wasmInstance.exports.__getString(objPtr)));
        }
      },
      block: {
        "Block.height": function() {
          return swGlobal.block.height;
        },
        "Block.indep_hash": function() {
          return wasmInstance.exports.__newString(swGlobal.block.indep_hash);
        },
        "Block.timestamp": function() {
          return swGlobal.block.timestamp;
        }
      },
      transaction: {
        "Transaction.id": function() {
          return wasmInstance.exports.__newString(swGlobal.transaction.id);
        },
        "Transaction.owner": function() {
          return wasmInstance.exports.__newString(swGlobal.transaction.owner);
        },
        "Transaction.target": function() {
          return wasmInstance.exports.__newString(swGlobal.transaction.target);
        }
      },
      contract: {
        "Contract.id": function() {
          return wasmInstance.exports.__newString(swGlobal.contract.id);
        },
        "Contract.owner": function() {
          return wasmInstance.exports.__newString(swGlobal.contract.owner);
        }
      },
      api: {
        _readContractState: (fnIndex, contractTxIdPtr) => {
          const contractTxId = wasmInstance.exports.__getString(contractTxIdPtr);
          const callbackFn = getFn(fnIndex);
          console.log("Simulating read state of", contractTxId);
          return setTimeout(() => {
            console.log("calling callback");
            callbackFn(wasmInstance.exports.__newString(JSON.stringify({
              contractTxId
            })));
          }, 1e3);
        },
        clearTimeout
      },
      env: {
        abort(messagePtr, fileNamePtr, line, column) {
          const message = wasmInstance.exports.__getString(messagePtr);
          wasmLogger.error("--------------------- Error message from AssemblyScript ----------------------\n");
          wasmLogger.error("  " + message);
          wasmLogger.error('    In file "' + wasmInstance.exports.__getString(fileNamePtr) + '"');
          wasmLogger.error(`    on line ${line}, column ${column}.`);
          wasmLogger.error("------------------------------------------------------------------------------\n");
          throw new Error(message);
        }
      }
    };
    function getFn(idx) {
      return wasmInstance.exports.table.get(idx);
    }
  };

  // src/core/modules/impl/wasm/rust-wasm-imports.ts
  var rustWasmImports = (swGlobal, wbindgenImports, wasmInstance, dtorValue) => {
    const wasmLogger = LoggerFactory.INST.create("WASM:Rust");
    const rawImports = {
      metering: {
        usegas: swGlobal.useGas
      },
      console: {
        log: function(value) {
          wasmLogger.debug(`${swGlobal.contract.id}: ${value}`);
        }
      },
      Block: {
        height: function() {
          return swGlobal.block.height;
        },
        indep_hash: function() {
          return swGlobal.block.indep_hash;
        },
        timestamp: function() {
          return swGlobal.block.timestamp;
        }
      },
      Transaction: {
        id: function() {
          return swGlobal.transaction.id;
        },
        owner: function() {
          return swGlobal.transaction.owner;
        },
        target: function() {
          return swGlobal.transaction.target;
        }
      },
      Contract: {
        id: function() {
          return swGlobal.contract.id;
        },
        owner: function() {
          return swGlobal.contract.owner;
        }
      },
      SmartWeave: {
        caller: function() {
          return swGlobal.caller;
        },
        readContractState: async function(contractTxId) {
          return await swGlobal.contracts.readContractState(contractTxId);
        },
        write: async function(contractId, input) {
          return await swGlobal.contracts.write(contractId, input);
        }
      }
    };
    const baseImports = {
      __wbg_log_: function(arg0, arg1) {
        rawImports.console.log(getStringFromWasm0(arg0, arg1));
      },
      __wbindgen_json_parse: function(arg0, arg1) {
        var ret = JSON.parse(getStringFromWasm0(arg0, arg1));
        return addHeapObject(ret);
      },
      __wbindgen_json_serialize: function(arg0, arg1) {
        const obj = getObject(arg1);
        var ret = JSON.stringify(obj === void 0 ? null : obj);
        var ptr0 = passStringToWasm0(ret, wasmInstance.exports.__wbindgen_malloc, wasmInstance.exports.__wbindgen_realloc);
        var len0 = WASM_VECTOR_LEN;
        getInt32Memory0()[arg0 / 4 + 1] = len0;
        getInt32Memory0()[arg0 / 4 + 0] = ptr0;
      },
      __wbindgen_object_drop_ref: function(arg0) {
        takeObject(arg0);
      },
      __wbindgen_cb_drop: function(arg0) {
        const obj = takeObject(arg0).original;
        if (obj.cnt-- == 1) {
          obj.a = 0;
          return true;
        }
        var ret = false;
        return ret;
      },
      __wbg_readContractState: function(arg0, arg1) {
        var ret = rawImports.SmartWeave.readContractState(getStringFromWasm0(arg0, arg1));
        return addHeapObject(ret);
      },
      __wbg_viewContractState: function(arg0, arg1) {
      },
      __wbg_caller: function(arg0) {
        var ret = rawImports.SmartWeave.caller();
        var ptr0 = passStringToWasm0(ret, wasmInstance.exports.__wbindgen_malloc, wasmInstance.exports.__wbindgen_realloc);
        var len0 = WASM_VECTOR_LEN;
        getInt32Memory0()[arg0 / 4 + 1] = len0;
        getInt32Memory0()[arg0 / 4 + 0] = ptr0;
      },
      __wbg_write: function(arg0, arg1, arg2) {
        var ret = rawImports.SmartWeave.write(getStringFromWasm0(arg0, arg1), takeObject(arg2));
        return addHeapObject(ret);
      },
      __wbg_refreshState: function(arg0, arg1) {
      },
      __wbg_indephash: function(arg0) {
        var ret = rawImports.Block.indep_hash();
        var ptr0 = passStringToWasm0(ret, wasmInstance.exports.__wbindgen_malloc, wasmInstance.exports.__wbindgen_realloc);
        var len0 = WASM_VECTOR_LEN;
        getInt32Memory0()[arg0 / 4 + 1] = len0;
        getInt32Memory0()[arg0 / 4 + 0] = ptr0;
      },
      __wbg_height: function() {
        var ret = rawImports.Block.height();
        return ret;
      },
      __wbg_timestamp: function() {
        var ret = rawImports.Block.timestamp();
        return ret;
      },
      __wbg_id: function() {
        var ret = rawImports.Transaction.id();
        return ret;
      },
      __wbg_contractOwner: function(arg0) {
        var ret = rawImports.Contract.owner();
        var ptr0 = passStringToWasm0(ret, wasmInstance.exports.__wbindgen_malloc, wasmInstance.exports.__wbindgen_realloc);
        var len0 = WASM_VECTOR_LEN;
        getInt32Memory0()[arg0 / 4 + 1] = len0;
        getInt32Memory0()[arg0 / 4 + 0] = ptr0;
      },
      __wbg_contractId: function() {
        var ret = rawImports.Contract.id();
        return ret;
      },
      __wbg_owner: function(arg0) {
        var ret = rawImports.Transaction.owner();
        var ptr0 = passStringToWasm0(ret, wasmInstance.exports.__wbindgen_malloc, wasmInstance.exports.__wbindgen_realloc);
        var len0 = WASM_VECTOR_LEN;
        getInt32Memory0()[arg0 / 4 + 1] = len0;
        getInt32Memory0()[arg0 / 4 + 0] = ptr0;
      },
      __wbg_target: function(arg0) {
        var ret = rawImports.Transaction.target();
        var ptr0 = passStringToWasm0(ret, wasmInstance.exports.__wbindgen_malloc, wasmInstance.exports.__wbindgen_realloc);
        var len0 = WASM_VECTOR_LEN;
        getInt32Memory0()[arg0 / 4 + 1] = len0;
        getInt32Memory0()[arg0 / 4 + 0] = ptr0;
      },
      __wbg_call: function() {
        return handleError(function(arg0, arg1, arg2) {
          var ret = getObject(arg0).call(getObject(arg1), getObject(arg2));
          return addHeapObject(ret);
        }, arguments);
      },
      __wbg_new: function(arg0, arg1) {
        try {
          var state0 = { a: arg0, b: arg1 };
          var cb0 = (arg02, arg12) => {
            const a = state0.a;
            state0.a = 0;
            try {
              return __wbg_adapter_42(a, state0.b, arg02, arg12);
            } finally {
              state0.a = a;
            }
          };
          var ret = new Promise(cb0);
          return addHeapObject(ret);
        } finally {
          state0.a = state0.b = 0;
        }
      },
      __wbg_resolve: function(arg0) {
        var ret = Promise.resolve(getObject(arg0));
        return addHeapObject(ret);
      },
      __wbg_then_a: function(arg0, arg1) {
        var ret = getObject(arg0).then(getObject(arg1));
        return addHeapObject(ret);
      },
      __wbg_then_5: function(arg0, arg1, arg2) {
        var ret = getObject(arg0).then(getObject(arg1), getObject(arg2));
        return addHeapObject(ret);
      },
      __wbindgen_debug_string: function(arg0, arg1) {
        var ret = debugString(getObject(arg1));
        var ptr0 = passStringToWasm0(ret, wasmInstance.exports.__wbindgen_malloc, wasmInstance.exports.__wbindgen_realloc);
        var len0 = WASM_VECTOR_LEN;
        getInt32Memory0()[arg0 / 4 + 1] = len0;
        getInt32Memory0()[arg0 / 4 + 0] = ptr0;
      },
      __wbindgen_throw: function(arg0, arg1) {
        throw new Error(getStringFromWasm0(arg0, arg1));
      },
      __wbindgen_closure_wrapper: function(arg0, arg1, arg2) {
        var ret = makeMutClosure(arg0, arg1, dtorValue, __wbg_adapter_14);
        return addHeapObject(ret);
      },
      __wbindgen_string_new: function(arg0, arg1) {
        var ret = getStringFromWasm0(arg0, arg1);
        return addHeapObject(ret);
      }
    };
    const baseImportsKeys = Object.keys(baseImports);
    let module2 = wbindgenImports.reduce((acc, wbindgenKey) => {
      const baseImportsKey = baseImportsKeys.find((key) => wbindgenKey.startsWith(key));
      if (baseImportsKey === void 0) {
        throw new Error(`Cannot find import mapping for ${wbindgenKey}`);
      }
      acc[wbindgenKey] = baseImports[baseImportsKey];
      return acc;
    }, {});
    let imports = {};
    imports["__wbindgen_placeholder__"] = module2;
    let cachedTextDecoder = new TextDecoder("utf-8", { ignoreBOM: true, fatal: true });
    cachedTextDecoder.decode();
    let cachegetUint8Memory0 = null;
    function getUint8Memory0() {
      if (cachegetUint8Memory0 === null || cachegetUint8Memory0.buffer !== wasmInstance.exports.memory.buffer) {
        cachegetUint8Memory0 = new Uint8Array(wasmInstance.exports.memory.buffer);
      }
      return cachegetUint8Memory0;
    }
    function getStringFromWasm0(ptr, len) {
      return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));
    }
    const heap = new Array(32).fill(void 0);
    heap.push(void 0, null, true, false);
    let heap_next = heap.length;
    function addHeapObject(obj) {
      if (heap_next === heap.length)
        heap.push(heap.length + 1);
      const idx = heap_next;
      heap_next = heap[idx];
      heap[idx] = obj;
      return idx;
    }
    function getObject(idx) {
      return heap[idx];
    }
    let WASM_VECTOR_LEN = 0;
    let cachedTextEncoder = new TextEncoder("utf-8");
    const encodeString = typeof cachedTextEncoder.encodeInto === "function" ? function(arg, view) {
      return cachedTextEncoder.encodeInto(arg, view);
    } : function(arg, view) {
      const buf = cachedTextEncoder.encode(arg);
      view.set(buf);
      return {
        read: arg.length,
        written: buf.length
      };
    };
    function passStringToWasm0(arg, malloc, realloc) {
      if (realloc === void 0) {
        const buf = cachedTextEncoder.encode(arg);
        const ptr2 = malloc(buf.length);
        getUint8Memory0().subarray(ptr2, ptr2 + buf.length).set(buf);
        WASM_VECTOR_LEN = buf.length;
        return ptr2;
      }
      let len = arg.length;
      let ptr = malloc(len);
      const mem = getUint8Memory0();
      let offset = 0;
      for (; offset < len; offset++) {
        const code = arg.charCodeAt(offset);
        if (code > 127)
          break;
        mem[ptr + offset] = code;
      }
      if (offset !== len) {
        if (offset !== 0) {
          arg = arg.slice(offset);
        }
        ptr = realloc(ptr, len, len = offset + arg.length * 3);
        const view = getUint8Memory0().subarray(ptr + offset, ptr + len);
        const ret = encodeString(arg, view);
        offset += ret.written;
      }
      WASM_VECTOR_LEN = offset;
      return ptr;
    }
    let cachegetInt32Memory0 = null;
    function getInt32Memory0() {
      if (cachegetInt32Memory0 === null || cachegetInt32Memory0.buffer !== wasmInstance.exports.memory.buffer) {
        cachegetInt32Memory0 = new Int32Array(wasmInstance.exports.memory.buffer);
      }
      return cachegetInt32Memory0;
    }
    function dropObject(idx) {
      if (idx < 36)
        return;
      heap[idx] = heap_next;
      heap_next = idx;
    }
    function takeObject(idx) {
      const ret = getObject(idx);
      dropObject(idx);
      return ret;
    }
    function debugString(val) {
      const type = typeof val;
      if (type == "number" || type == "boolean" || val == null) {
        return `${val}`;
      }
      if (type == "string") {
        return `"${val}"`;
      }
      if (type == "symbol") {
        const description = val.description;
        if (description == null) {
          return "Symbol";
        } else {
          return `Symbol(${description})`;
        }
      }
      if (type == "function") {
        const name = val.name;
        if (typeof name == "string" && name.length > 0) {
          return `Function(${name})`;
        } else {
          return "Function";
        }
      }
      if (Array.isArray(val)) {
        const length = val.length;
        let debug = "[";
        if (length > 0) {
          debug += debugString(val[0]);
        }
        for (let i = 1; i < length; i++) {
          debug += ", " + debugString(val[i]);
        }
        debug += "]";
        return debug;
      }
      const builtInMatches = /\[object ([^\]]+)\]/.exec(toString.call(val));
      let className;
      if (builtInMatches.length > 1) {
        className = builtInMatches[1];
      } else {
        return toString.call(val);
      }
      if (className == "Object") {
        try {
          return "Object(" + JSON.stringify(val) + ")";
        } catch (_) {
          return "Object";
        }
      }
      if (val instanceof Error) {
        return `${val.name}: ${val.message}
${val.stack}`;
      }
      return className;
    }
    function makeMutClosure(arg0, arg1, dtor, f) {
      const state = { a: arg0, b: arg1, cnt: 1, dtor };
      const real = (...args) => {
        state.cnt++;
        const a = state.a;
        state.a = 0;
        try {
          return f(a, state.b, ...args);
        } finally {
          if (--state.cnt === 0) {
            wasmInstance.exports.__wbindgen_export_2.get(state.dtor)(a, state.b);
          } else {
            state.a = a;
          }
        }
      };
      real.original = state;
      return real;
    }
    function __wbg_adapter_14(arg0, arg1, arg2) {
      wasmInstance.modifiedExports._dyn_core__ops__function__FnMut__A____Output___R_as_wasm_bindgen__closure__WasmClosure___describe__invoke__(arg0, arg1, addHeapObject(arg2));
    }
    module2.handle = function(interaction) {
      var ret = wasmInstance.exports.handle(addHeapObject(interaction));
      return takeObject(ret);
    };
    let stack_pointer = 32;
    function addBorrowedObject(obj) {
      if (stack_pointer == 1)
        throw new Error("out of js stack");
      heap[--stack_pointer] = obj;
      return stack_pointer;
    }
    module2.initState = function(state) {
      try {
        wasmInstance.exports.initState(addBorrowedObject(state));
      } finally {
        heap[stack_pointer++] = void 0;
      }
    };
    module2.currentState = function() {
      var ret = wasmInstance.exports.currentState();
      return takeObject(ret);
    };
    module2.lang = function() {
      try {
        const retptr = wasmInstance.exports.__wbindgen_add_to_stack_pointer(-16);
        wasmInstance.exports.lang(retptr);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        return getStringFromWasm0(r0, r1);
      } finally {
        wasmInstance.exports.__wbindgen_add_to_stack_pointer(16);
        wasmInstance.exports.__wbindgen_free(r0, r1);
      }
    };
    module2.type = function() {
      var ret = wasmInstance.exports.type();
      return ret;
    };
    function handleError(f, args) {
      try {
        return f.apply(this, args);
      } catch (e) {
        wasmInstance.exports.__wbindgen_exn_store(addHeapObject(e));
      }
    }
    function __wbg_adapter_42(arg0, arg1, arg2, arg3) {
      wasmInstance.modifiedExports.wasm_bindgen__convert__closures__invoke2_mut__(arg0, arg1, addHeapObject(arg2), addHeapObject(arg3));
    }
    class StateWrapper {
      __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasmInstance.exports.__wbg_statewrapper_free(ptr);
      }
    }
    module2.StateWrapper = StateWrapper;
    imports.metering = rawImports.metering;
    return { imports, exports: module2 };
  };

  // src/core/modules/impl/wasm/go-wasm-imports.ts
  var encoder = new TextEncoder();
  var decoder = new TextDecoder("utf-8");
  var logLine = [];
  var globalJsModule;
  (function(global2) {
    globalJsModule = global2;
    globalJsModule.redstone = {
      go: {}
    };
  }).call(void 0, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
  var Go = class {
    constructor(swGlobal) {
      this._callbackTimeouts = new Map();
      this._nextCallbackTimeoutID = 1;
      const wasmLogger = LoggerFactory.INST.create("WASM:Go");
      let go = this;
      globalJsModule.redstone.go = {
        WasmModule: {
          registerWasmModule: function(moduleId) {
            go._id = moduleId;
            go.exports = globalJsModule[moduleId];
            delete globalJsModule[moduleId];
            globalJsModule.redstone.go[moduleId] = {};
            globalJsModule.redstone.go[moduleId].imports = {
              console: {
                log: function(...args) {
                  wasmLogger.debug(args[0], ...args.slice(1));
                }
              },
              Transaction: {
                id: function() {
                  return swGlobal.transaction.id;
                },
                owner: function() {
                  return swGlobal.transaction.owner;
                },
                target: function() {
                  return swGlobal.transaction.target;
                }
              },
              Block: {
                indep_hash: function() {
                  return swGlobal.block.indep_hash;
                },
                height: function() {
                  return swGlobal.block.height;
                },
                timestamp: function() {
                  return swGlobal.block.timestamp;
                }
              },
              Contract: {
                id: function() {
                  return swGlobal.contract.id;
                },
                owner: function() {
                  return swGlobal.contract.owner;
                }
              },
              SmartWeave: {
                readContractState: async function(contractTxId) {
                  return await swGlobal.contracts.readContractState(contractTxId);
                }
              }
            };
          }
        }
      };
      const mem = () => {
        return new DataView(this._inst.exports.memory.buffer);
      };
      const setInt64 = (addr, v) => {
        mem().setUint32(addr + 0, v, true);
        mem().setUint32(addr + 4, Math.floor(v / 4294967296), true);
      };
      const getInt64 = (addr) => {
        const low = mem().getUint32(addr + 0, true);
        const high = mem().getInt32(addr + 4, true);
        return low + high * 4294967296;
      };
      const loadValue = (addr) => {
        const f = mem().getFloat64(addr, true);
        if (f === 0) {
          return void 0;
        }
        if (!isNaN(f)) {
          return f;
        }
        const id = mem().getUint32(addr, true);
        return this._values[id];
      };
      const storeValue = (addr, v) => {
        const nanHead = 2146959360;
        if (typeof v === "number") {
          if (isNaN(v)) {
            mem().setUint32(addr + 4, nanHead, true);
            mem().setUint32(addr, 0, true);
            return;
          }
          if (v === 0) {
            mem().setUint32(addr + 4, nanHead, true);
            mem().setUint32(addr, 1, true);
            return;
          }
          mem().setFloat64(addr, v, true);
          return;
        }
        switch (v) {
          case void 0:
            mem().setFloat64(addr, 0, true);
            return;
          case null:
            mem().setUint32(addr + 4, nanHead, true);
            mem().setUint32(addr, 2, true);
            return;
          case true:
            mem().setUint32(addr + 4, nanHead, true);
            mem().setUint32(addr, 3, true);
            return;
          case false:
            mem().setUint32(addr + 4, nanHead, true);
            mem().setUint32(addr, 4, true);
            return;
        }
        let id = this._ids.get(v);
        if (id === void 0) {
          id = this._idPool.pop();
          if (id === void 0) {
            id = this._values.length;
          }
          this._values[id] = v;
          this._goRefCounts[id] = 0;
          this._ids.set(v, id);
        }
        this._goRefCounts[id]++;
        let typeFlag = 1;
        switch (typeof v) {
          case "string":
            typeFlag = 2;
            break;
          case "symbol":
            typeFlag = 3;
            break;
          case "function":
            typeFlag = 4;
            break;
        }
        mem().setUint32(addr + 4, nanHead | typeFlag, true);
        mem().setUint32(addr, id, true);
      };
      const loadSlice = (array, len, cap = null) => {
        return new Uint8Array(this._inst.exports.memory.buffer, array, len);
      };
      const loadSliceOfValues = (array, len, cap) => {
        const a = new Array(len);
        for (let i = 0; i < len; i++) {
          a[i] = loadValue(array + i * 8);
        }
        return a;
      };
      const loadString = (ptr, len) => {
        return decoder.decode(new DataView(this._inst.exports.memory.buffer, ptr, len));
      };
      const timeOrigin = Date.now() - performance.now();
      this.importObject = {
        wasi_snapshot_preview1: {
          fd_write: function(fd, iovs_ptr, iovs_len, nwritten_ptr) {
            let nwritten = 0;
            if (fd == 1) {
              for (let iovs_i = 0; iovs_i < iovs_len; iovs_i++) {
                let iov_ptr = iovs_ptr + iovs_i * 8;
                let ptr = mem().getUint32(iov_ptr + 0, true);
                let len = mem().getUint32(iov_ptr + 4, true);
                nwritten += len;
                for (let i = 0; i < len; i++) {
                  let c = mem().getUint8(ptr + i);
                  if (c == 13) {
                  } else if (c == 10) {
                    let line = decoder.decode(new Uint8Array(logLine));
                    logLine = [];
                    console.log(line);
                  } else {
                    logLine.push(c);
                  }
                }
              }
            } else {
              console.error("invalid file descriptor:", fd);
            }
            mem().setUint32(nwritten_ptr, nwritten, true);
            return 0;
          },
          fd_close: () => 0,
          fd_fdstat_get: () => 0,
          fd_seek: () => 0,
          proc_exit: (code) => {
            if (global.process) {
              process.exit(code);
            } else {
              throw "trying to exit with code " + code;
            }
          },
          random_get: (bufPtr, bufLen) => {
            crypto.getRandomValues(loadSlice(bufPtr, bufLen, null));
            return 0;
          }
        },
        env: {
          "runtime.ticks": () => {
            return timeOrigin + performance.now();
          },
          "runtime.sleepTicks": (timeout2) => {
            setTimeout(this._inst.exports.go_scheduler, timeout2);
          },
          "syscall/js.finalizeRef": (v_addr) => {
            const id = mem().getUint32(v_addr, true);
            this._goRefCounts[id]--;
            if (this._goRefCounts[id] === 0) {
              const v = this._values[id];
              this._values[id] = null;
              this._ids.delete(v);
              this._idPool.push(id);
            }
          },
          "syscall/js.stringVal": (ret_ptr, value_ptr, value_len) => {
            const s = loadString(value_ptr, value_len);
            storeValue(ret_ptr, s);
          },
          "syscall/js.valueGet": (retval, v_addr, p_ptr, p_len) => {
            let prop = loadString(p_ptr, p_len);
            let value = loadValue(v_addr);
            let result = Reflect.get(value, prop);
            storeValue(retval, result);
          },
          "syscall/js.valueSet": (v_addr, p_ptr, p_len, x_addr) => {
            const v = loadValue(v_addr);
            const p = loadString(p_ptr, p_len);
            const x = loadValue(x_addr);
            Reflect.set(v, p, x);
          },
          "syscall/js.valueDelete": (v_addr, p_ptr, p_len) => {
            const v = loadValue(v_addr);
            const p = loadString(p_ptr, p_len);
            Reflect.deleteProperty(v, p);
          },
          "syscall/js.valueIndex": (ret_addr, v_addr, i) => {
            storeValue(ret_addr, Reflect.get(loadValue(v_addr), i));
          },
          "syscall/js.valueSetIndex": (v_addr, i, x_addr) => {
            Reflect.set(loadValue(v_addr), i, loadValue(x_addr));
          },
          "syscall/js.valueCall": (ret_addr, v_addr, m_ptr, m_len, args_ptr, args_len, args_cap) => {
            const v = loadValue(v_addr);
            const name = loadString(m_ptr, m_len);
            const args = loadSliceOfValues(args_ptr, args_len, args_cap);
            try {
              const m = Reflect.get(v, name);
              storeValue(ret_addr, Reflect.apply(m, v, args));
              mem().setUint8(ret_addr + 8, 1);
            } catch (err) {
              storeValue(ret_addr, err);
              mem().setUint8(ret_addr + 8, 0);
            }
          },
          "syscall/js.valueInvoke": (ret_addr, v_addr, args_ptr, args_len, args_cap) => {
            try {
              const v = loadValue(v_addr);
              const args = loadSliceOfValues(args_ptr, args_len, args_cap);
              storeValue(ret_addr, Reflect.apply(v, void 0, args));
              mem().setUint8(ret_addr + 8, 1);
            } catch (err) {
              storeValue(ret_addr, err);
              mem().setUint8(ret_addr + 8, 0);
            }
          },
          "syscall/js.valueNew": (ret_addr, v_addr, args_ptr, args_len, args_cap) => {
            const v = loadValue(v_addr);
            const args = loadSliceOfValues(args_ptr, args_len, args_cap);
            try {
              storeValue(ret_addr, Reflect.construct(v, args));
              mem().setUint8(ret_addr + 8, 1);
            } catch (err) {
              storeValue(ret_addr, err);
              mem().setUint8(ret_addr + 8, 0);
            }
          },
          "syscall/js.valueLength": (v_addr) => {
            return loadValue(v_addr).length;
          },
          "syscall/js.valuePrepareString": (ret_addr, v_addr) => {
            const s = String(loadValue(v_addr));
            const str = encoder.encode(s);
            storeValue(ret_addr, str);
            setInt64(ret_addr + 8, str.length);
          },
          "syscall/js.valueLoadString": (v_addr, slice_ptr, slice_len, slice_cap) => {
            const str = loadValue(v_addr);
            loadSlice(slice_ptr, slice_len, slice_cap).set(str);
          },
          "syscall/js.valueInstanceOf": (v_addr, t_addr) => {
            return loadValue(v_addr) instanceof loadValue(t_addr);
          },
          "syscall/js.copyBytesToGo": (ret_addr, dest_addr, dest_len, dest_cap, source_addr) => {
            let num_bytes_copied_addr = ret_addr;
            let returned_status_addr = ret_addr + 4;
            const dst = loadSlice(dest_addr, dest_len);
            const src = loadValue(source_addr);
            if (!(src instanceof Uint8Array)) {
              mem().setUint8(returned_status_addr, 0);
              return;
            }
            const toCopy = src.subarray(0, dst.length);
            dst.set(toCopy);
            setInt64(num_bytes_copied_addr, toCopy.length);
            mem().setUint8(returned_status_addr, 1);
          },
          "syscall/js.copyBytesToJS": (ret_addr, dest_addr, source_addr, source_len, source_cap) => {
            let num_bytes_copied_addr = ret_addr;
            let returned_status_addr = ret_addr + 4;
            const dst = loadValue(dest_addr);
            const src = loadSlice(source_addr, source_len);
            if (!(dst instanceof Uint8Array)) {
              mem().setUint8(returned_status_addr, 0);
              return;
            }
            const toCopy = src.subarray(0, dst.length);
            dst.set(toCopy);
            setInt64(num_bytes_copied_addr, toCopy.length);
            mem().setUint8(returned_status_addr, 1);
          }
        }
      };
    }
    async run(instance) {
      this._inst = instance;
      this._values = [
        NaN,
        0,
        null,
        true,
        false,
        global,
        this
      ];
      this._goRefCounts = [];
      this._ids = new Map();
      this._idPool = [];
      this.exited = false;
      const mem = new DataView(this._inst.exports.memory.buffer);
      while (true) {
        const callbackPromise = new Promise((resolve) => {
          this._resolveCallbackPromise = () => {
            if (this.exited) {
              throw new Error("bad callback: Go program has already exited");
            }
            setTimeout(resolve, 0);
          };
        });
        this._inst.exports._start();
        if (this.exited) {
          break;
        }
        await callbackPromise;
      }
    }
    _resume() {
      if (this.exited) {
        throw new Error("Go program has already exited");
      }
      this._inst.exports.resume();
      if (this.exited) {
        this._resolveExitPromise();
      }
    }
    _makeFuncWrapper(id) {
      const go = this;
      return function() {
        const event = { id, this: this, args: arguments };
        go._pendingEvent = event;
        go._resume();
        return event.result;
      };
    }
    _resolveExitPromise() {
    }
  };

  // src/core/modules/impl/HandlerExecutorFactory.ts
  var import_bignumber = __toModule(require_bignumber());
  var ContractError = class extends Error {
    constructor(message) {
      super(message);
      this.name = "ContractError";
    }
  };
  var HandlerExecutorFactory = class {
    constructor(arweave) {
      this.arweave = arweave;
      this.logger = LoggerFactory.INST.create("HandlerExecutorFactory");
      this.cache = new MemCache();
    }
    async create(contractDefinition, evaluationOptions) {
      const swGlobal = new SmartWeaveGlobal5(this.arweave, {
        id: contractDefinition.txId,
        owner: contractDefinition.owner
      });
      if (contractDefinition.contractType == "wasm") {
        this.logger.info("Creating handler for wasm contract", contractDefinition.txId);
        const benchmark = Benchmark.measure();
        let wasmInstance;
        let jsExports = null;
        const wasmResponse = generateResponse(contractDefinition.srcBinary);
        switch (contractDefinition.srcWasmLang) {
          case "assemblyscript": {
            const wasmInstanceExports = {
              exports: null
            };
            wasmInstance = await loader_default.instantiateStreaming(wasmResponse, asWasmImports(swGlobal, wasmInstanceExports));
            wasmInstanceExports.exports = wasmInstance.exports;
            break;
          }
          case "rust": {
            const wasmInstanceExports = {
              exports: null,
              modifiedExports: {
                wasm_bindgen__convert__closures__invoke2_mut__: null,
                _dyn_core__ops__function__FnMut__A____Output___R_as_wasm_bindgen__closure__WasmClosure___describe__invoke__: null
              }
            };
            const wasmModule = await getWasmModule(wasmResponse, contractDefinition.srcBinary);
            const moduleImports = WebAssembly.Module.imports(wasmModule);
            const wbindgenImports = moduleImports.filter((imp) => {
              return imp.module === "__wbindgen_placeholder__";
            }).map((imp) => imp.name);
            const { imports, exports } = rustWasmImports(swGlobal, wbindgenImports, wasmInstanceExports, contractDefinition.metadata.dtor);
            jsExports = exports;
            wasmInstance = await WebAssembly.instantiate(wasmModule, imports);
            wasmInstanceExports.exports = wasmInstance.exports;
            const moduleExports = Object.keys(wasmInstance.exports);
            moduleExports.forEach((moduleExport) => {
              if (moduleExport.startsWith("wasm_bindgen__convert__closures__invoke2_mut__")) {
                wasmInstanceExports.modifiedExports.wasm_bindgen__convert__closures__invoke2_mut__ = wasmInstance.exports[moduleExport];
              }
              if (moduleExport.startsWith("_dyn_core__ops__function__FnMut__A____Output___R_as_wasm_bindgen__closure__WasmClosure___describe__invoke__")) {
                wasmInstanceExports.modifiedExports._dyn_core__ops__function__FnMut__A____Output___R_as_wasm_bindgen__closure__WasmClosure___describe__invoke__ = wasmInstance.exports[moduleExport];
              }
            });
            break;
          }
          case "go": {
            const go = new Go(swGlobal);
            go.importObject.metering = {
              usegas: function(value) {
                swGlobal.useGas(value);
              }
            };
            const wasmModule = await getWasmModule(wasmResponse, contractDefinition.srcBinary);
            wasmInstance = await WebAssembly.instantiate(wasmModule, go.importObject);
            go.run(wasmInstance);
            jsExports = go.exports;
            break;
          }
          default: {
            throw new Error(`Support for ${contractDefinition.srcWasmLang} not implemented yet.`);
          }
        }
        this.logger.info(`WASM ${contractDefinition.srcWasmLang} handler created in ${benchmark.elapsed()}`);
        return new WasmContractHandlerApi(swGlobal, contractDefinition, jsExports || wasmInstance.exports);
      } else {
        this.logger.info("Creating handler for js contract", contractDefinition.txId);
        const normalizedSource = normalizeContractSource(contractDefinition.src, evaluationOptions.useVM2);
        if (evaluationOptions.useVM2) {
          const vmScript = new import_vm2.VMScript(normalizedSource);
          const vm = new import_vm2.NodeVM({
            console: "off",
            sandbox: {
              SmartWeave: swGlobal,
              BigNumber: import_bignumber.default,
              logger: this.logger,
              ContractError,
              ContractAssert: function(cond, message) {
                if (!cond)
                  throw new ContractError(message);
              }
            },
            compiler: "javascript",
            eval: false,
            wasm: false,
            allowAsync: true,
            wrapper: "commonjs"
          });
          return new ContractHandlerApi(swGlobal, vm.run(vmScript), contractDefinition);
        } else {
          const contractFunction = new Function(normalizedSource);
          const handler = contractFunction(swGlobal, import_bignumber.default, LoggerFactory.INST.create(swGlobal.contract.id));
          return new ContractHandlerApi(swGlobal, handler, contractDefinition);
        }
      }
    }
  };
  function generateResponse(wasmBinary) {
    const init = { status: 200, statusText: "OK", headers: { "Content-Type": "application/wasm" } };
    return new Response(wasmBinary, init);
  }
  async function getWasmModule(wasmResponse, binary) {
    if (WebAssembly.compileStreaming) {
      return await WebAssembly.compileStreaming(wasmResponse);
    } else {
      return await WebAssembly.compile(binary);
    }
  }

  // src/core/modules/impl/LexicographicalInteractionsSorter.ts
  var defaultArweaveMs = "".padEnd(13, "9");
  var LexicographicalInteractionsSorter = class {
    constructor(arweave) {
      this.arweave = arweave;
      this.logger = LoggerFactory.INST.create("LexicographicalInteractionsSorter");
    }
    async sort(transactions) {
      const copy2 = [...transactions];
      const addKeysFuncs = copy2.map((tx) => this.addSortKey(tx));
      await Promise.all(addKeysFuncs);
      return copy2.sort((a, b) => a.sortKey.localeCompare(b.sortKey));
    }
    async addSortKey(txInfo) {
      const { node } = txInfo;
      if (txInfo.node.sortKey !== void 0 && txInfo.node.source == SourceType.REDSTONE_SEQUENCER) {
        this.logger.debug("Using sortkey from sequencer", txInfo.node.sortKey);
        txInfo.sortKey = txInfo.node.sortKey;
      } else {
        txInfo.sortKey = await this.createSortKey(node.block.id, node.id, node.block.height);
      }
    }
    async createSortKey(blockId, transactionId, blockHeight) {
      const blockHashBytes = this.arweave.utils.b64UrlToBuffer(blockId);
      const txIdBytes = this.arweave.utils.b64UrlToBuffer(transactionId);
      const concatenated = this.arweave.utils.concatBuffers([blockHashBytes, txIdBytes]);
      const hashed = arrayToHex(await this.arweave.crypto.hash(concatenated));
      const blockHeightString = `${blockHeight}`.padStart(12, "0");
      return `${blockHeightString},${defaultArweaveMs},${hashed}`;
    }
  };

  // src/core/modules/impl/DefaultCreateContract.ts
  var import_redstone_wasm_metering = __toModule(require_redstone_wasm_metering());
  var import_fs2 = __toModule(require_fs());

  // src/core/modules/impl/wasm/wasm-bindgen-tools.ts
  function matchMutClosureDtor(source) {
    const regexp = /var ret = makeMutClosure\(arg0, arg1, (\d+?), __wbg_adapter/;
    const match = source.match(regexp);
    return match[1];
  }

  // src/core/modules/impl/DefaultCreateContract.ts
  var import_lodash = __toModule(require_lodash());
  var wasmTypeMapping = new Map([
    [1, "assemblyscript"],
    [2, "rust"],
    [3, "go"]
  ]);
  var DefaultCreateContract = class {
    constructor(arweave) {
      this.arweave = arweave;
      this.logger = LoggerFactory.INST.create("DefaultCreateContract");
      this.deployFromSourceTx = this.deployFromSourceTx.bind(this);
    }
    async deploy(contractData, useBundler = false) {
      this.logger.debug("Creating new contract");
      const { wallet, src, initState, tags, transfer, wasmSrcCodeDir, wasmGlueCode } = contractData;
      const contractType = src instanceof Buffer ? "wasm" : "js";
      let srcTx;
      let wasmLang = null;
      let wasmVersion = null;
      const metadata = {};
      const data = [];
      if (contractType == "wasm") {
        const meteredWasmBinary = import_redstone_wasm_metering.default.meterWASM(src, {
          meterType: "i32"
        });
        data.push(meteredWasmBinary);
        const wasmModule = await WebAssembly.compile(src);
        const moduleImports = WebAssembly.Module.imports(wasmModule);
        let lang;
        if (this.isGoModule(moduleImports)) {
          const go = new Go(null);
          const module2 = new WebAssembly.Instance(wasmModule, go.importObject);
          go.run(module2);
          lang = go.exports.lang();
          wasmVersion = go.exports.version();
        } else {
          const module2 = await WebAssembly.instantiate(src, dummyImports(moduleImports));
          if (!module2.instance.exports.lang) {
            throw new Error(`No info about source type in wasm binary. Did you forget to export "lang" function?`);
          }
          lang = module2.instance.exports.lang();
          wasmVersion = module2.instance.exports.version();
          if (!wasmTypeMapping.has(lang)) {
            throw new Error(`Unknown wasm source type ${lang}`);
          }
        }
        wasmLang = wasmTypeMapping.get(lang);
        if (wasmSrcCodeDir == null) {
          throw new Error("No path to original wasm contract source code");
        }
        const zippedSourceCode = await this.zipContents(wasmSrcCodeDir);
        data.push(zippedSourceCode);
        if (wasmLang == "rust") {
          if (!wasmGlueCode) {
            throw new Error("No path to generated wasm-bindgen js code");
          }
          const wasmBindgenSrc = import_fs2.default.readFileSync(wasmGlueCode, "utf-8");
          const dtor = matchMutClosureDtor(wasmBindgenSrc);
          metadata["dtor"] = (0, import_lodash.parseInt)(dtor);
          data.push(Buffer.from(wasmBindgenSrc));
        }
      }
      const allData = contractType == "wasm" ? this.joinBuffers(data) : src;
      srcTx = await this.arweave.createTransaction({ data: allData }, wallet);
      srcTx.addTag(SmartWeaveTags.APP_NAME, "SmartWeaveContractSource");
      srcTx.addTag(SmartWeaveTags.APP_VERSION, "0.3.0");
      srcTx.addTag(SmartWeaveTags.SDK, "RedStone");
      srcTx.addTag(SmartWeaveTags.CONTENT_TYPE, contractType == "js" ? "application/javascript" : "application/wasm");
      if (contractType == "wasm") {
        srcTx.addTag(SmartWeaveTags.WASM_LANG, wasmLang);
        srcTx.addTag(SmartWeaveTags.WASM_LANG_VERSION, wasmVersion);
        srcTx.addTag(SmartWeaveTags.WASM_META, JSON.stringify(metadata));
      }
      await this.arweave.transactions.sign(srcTx, wallet);
      this.logger.debug("Posting transaction with source");
      let responseOk = true;
      if (!useBundler) {
        const response = await this.arweave.transactions.post(srcTx);
        responseOk = response.status === 200 || response.status === 208;
      }
      if (responseOk) {
        return await this.deployFromSourceTx({
          srcTxId: srcTx.id,
          wallet,
          initState,
          tags,
          transfer
        }, useBundler, srcTx);
      } else {
        throw new Error(`Unable to write Contract Source`);
      }
    }
    async deployFromSourceTx(contractData, useBundler = false, srcTx = null) {
      this.logger.debug("Creating new contract from src tx");
      const { wallet, srcTxId, initState, tags, transfer } = contractData;
      let contractTX = await this.arweave.createTransaction({ data: initState }, wallet);
      if (+(transfer == null ? void 0 : transfer.winstonQty) > 0 && transfer.target.length) {
        this.logger.debug("Creating additional transaction with AR transfer", transfer);
        contractTX = await this.arweave.createTransaction({
          data: initState,
          target: transfer.target,
          quantity: transfer.winstonQty
        }, wallet);
      }
      if (tags == null ? void 0 : tags.length) {
        for (const tag of tags) {
          contractTX.addTag(tag.name.toString(), tag.value.toString());
        }
      }
      contractTX.addTag(SmartWeaveTags.APP_NAME, "SmartWeaveContract");
      contractTX.addTag(SmartWeaveTags.APP_VERSION, "0.3.0");
      contractTX.addTag(SmartWeaveTags.CONTRACT_SRC_TX_ID, srcTxId);
      contractTX.addTag(SmartWeaveTags.SDK, "RedStone");
      contractTX.addTag(SmartWeaveTags.CONTENT_TYPE, "application/json");
      await this.arweave.transactions.sign(contractTX, wallet);
      let responseOk;
      if (useBundler) {
        const result = await this.post(contractTX, srcTx);
        this.logger.debug(result);
        responseOk = true;
      } else {
        const response = await this.arweave.transactions.post(contractTX);
        responseOk = response.status === 200 || response.status === 208;
      }
      if (responseOk) {
        return contractTX.id;
      } else {
        throw new Error(`Unable to write Contract`);
      }
    }
    async post(contractTx, srcTx = null) {
      let body = {
        contractTx
      };
      if (srcTx) {
        body = __spreadProps(__spreadValues({}, body), {
          srcTx
        });
      }
      const response = await fetch(`https://gateway.redstone.finance/gateway/contracts/deploy`, {
        method: "POST",
        body: JSON.stringify(body),
        headers: {
          "Accept-Encoding": "gzip, deflate, br",
          "Content-Type": "application/json",
          Accept: "application/json"
        }
      });
      if (response.ok) {
        return response.json();
      } else {
        throw new Error(`Error while posting contract ${response.statusText}`);
      }
    }
    isGoModule(moduleImports) {
      return moduleImports.some((moduleImport) => {
        return moduleImport.module == "env" && moduleImport.name.startsWith("syscall/js");
      });
    }
    joinBuffers(buffers) {
      const length = buffers.length;
      const result = [];
      result.push(Buffer.from(length.toString()));
      result.push(Buffer.from("|"));
      buffers.forEach((b) => {
        result.push(Buffer.from(b.length.toString()));
        result.push(Buffer.from("|"));
      });
      result.push(...buffers);
      return result.reduce((prev, b) => Buffer.concat([prev, b]));
    }
    async zipContents(source) {
      const archiver = require_archiver(), streamBuffers = require_streambuffer();
      const outputStreamBuffer = new streamBuffers.WritableStreamBuffer({
        initialSize: 1e3 * 1024,
        incrementAmount: 1e3 * 1024
      });
      const archive = archiver("zip", {
        zlib: { level: 9 }
      });
      archive.on("error", function(err) {
        throw err;
      });
      archive.pipe(outputStreamBuffer);
      archive.directory(source.toString(), source.toString());
      await archive.finalize();
      outputStreamBuffer.end();
      return outputStreamBuffer.getContents();
    }
  };
  function dummyImports(moduleImports) {
    const imports = {};
    moduleImports.forEach((moduleImport) => {
      if (!Object.prototype.hasOwnProperty.call(imports, moduleImport.module)) {
        imports[moduleImport.module] = {};
      }
      imports[moduleImport.module][moduleImport.name] = function() {
      };
    });
    return imports;
  }

  // src/core/modules/impl/TagsParser.ts
  var TagsParser = class {
    constructor() {
      this.logger = LoggerFactory.INST.create("TagsParser");
    }
    getInputTag(interactionTransaction, contractTxId) {
      if (TagsParser.hasMultipleInteractions(interactionTransaction)) {
        this.logger.debug("Interaction transaction is using multiple input tx tag format.");
        const contractTagIndex = interactionTransaction.node.tags.findIndex((tag) => tag.name === SmartWeaveTags.CONTRACT_TX_ID && tag.value === contractTxId);
        if (interactionTransaction.node.tags.length - 1 === contractTagIndex) {
          this.logger.warn("Wrong tags format: 'Contract' is the last tag");
          return void 0;
        }
        const inputTag = interactionTransaction.node.tags[contractTagIndex + 1];
        if (inputTag.name !== SmartWeaveTags.INPUT) {
          this.logger.warn(`No 'Input' tag found after 'Contract' tag. Instead ${inputTag.name} was found`);
          return void 0;
        }
        return inputTag;
      } else {
        return interactionTransaction.node.tags.find((tag) => tag.name === SmartWeaveTags.INPUT);
      }
    }
    isInteractWrite(interactionTransaction, contractTxId) {
      return interactionTransaction.node.tags.some((tag) => tag.name === SmartWeaveTags.INTERACT_WRITE && tag.value === contractTxId);
    }
    getInteractWritesContracts(interactionTransaction) {
      return interactionTransaction.node.tags.filter((tag) => tag.name === SmartWeaveTags.INTERACT_WRITE).map((t) => t.value);
    }
    getContractTag(interactionTransaction) {
      var _a;
      return (_a = interactionTransaction.node.tags.find((tag) => tag.name === SmartWeaveTags.CONTRACT_TX_ID)) == null ? void 0 : _a.value;
    }
    getContractsWithInputs(interactionTransaction) {
      const result = new Map();
      const contractTags = interactionTransaction.node.tags.filter((tag) => tag.name === SmartWeaveTags.CONTRACT_TX_ID);
      contractTags.forEach((contractTag) => {
        result.set(contractTag.value, this.getInputTag(interactionTransaction, contractTag.value));
      });
      return result;
    }
    static hasMultipleInteractions(interactionTransaction) {
      return interactionTransaction.node.tags.filter((tag) => tag.name === SmartWeaveTags.CONTRACT_TX_ID).length > 1;
    }
  };

  // src/core/modules/impl/normalize-source.ts
  function normalizeContractSource(contractSrc, useVM2) {
    const lines = contractSrc.trim().split("\n");
    const first = lines[0];
    const last = lines[lines.length - 1];
    if ((/\(\s*\(\)\s*=>\s*{/g.test(first) || /\s*\(\s*function\s*\(\)\s*{/g.test(first)) && /}\s*\)\s*\(\)\s*;/g.test(last)) {
      lines.shift();
      lines.pop();
      contractSrc = lines.join("\n");
    }
    contractSrc = contractSrc.replace(/export\s+async\s+function\s+handle/gmu, "async function handle").replace(/export\s+function\s+handle/gmu, "function handle");
    if (useVM2) {
      return `
    ${contractSrc}
    module.exports = handle;`;
    } else {
      return `
    const [SmartWeave, BigNumber, logger] = arguments;
    class ContractError extends Error { constructor(message) { super(message); this.name = 'ContractError' } };
    function ContractAssert(cond, message) { if (!cond) throw new ContractError(message) };
    ${contractSrc};
    return handle;
  `;
    }
  }

  // src/core/modules/impl/StateCache.ts
  function canBeCached(tx) {
    if (tx.confirmationStatus === void 0) {
      return true;
    } else {
      return tx.confirmationStatus === "confirmed";
    }
  }

  // src/core/SmartWeaveTags.ts
  var SmartWeaveTags;
  (function(SmartWeaveTags2) {
    SmartWeaveTags2["APP_NAME"] = "App-Name";
    SmartWeaveTags2["APP_VERSION"] = "App-Version";
    SmartWeaveTags2["CONTRACT_TX_ID"] = "Contract";
    SmartWeaveTags2["INPUT"] = "Input";
    SmartWeaveTags2["CONTENT_TYPE"] = "Content-Type";
    SmartWeaveTags2["CONTRACT_SRC_TX_ID"] = "Contract-Src";
    SmartWeaveTags2["SDK"] = "SDK";
    SmartWeaveTags2["MIN_FEE"] = "Min-Fee";
    SmartWeaveTags2["INIT_STATE"] = "Init-State";
    SmartWeaveTags2["INIT_STATE_TX"] = "Init-State-TX";
    SmartWeaveTags2["INTERACT_WRITE"] = "Interact-Write";
    SmartWeaveTags2["WASM_LANG"] = "Wasm-Lang";
    SmartWeaveTags2["WASM_LANG_VERSION"] = "Wasm-Lang-Version";
    SmartWeaveTags2["WASM_META"] = "Wasm-Meta";
  })(SmartWeaveTags || (SmartWeaveTags = {}));

  // src/core/ContractDefinition.ts
  var ContractMetadata = class {
  };

  // src/core/ContractCallStack.ts
  var ContractCallStack = class {
    constructor(contractTxId, depth, label = "") {
      this.contractTxId = contractTxId;
      this.depth = depth;
      this.label = label;
      this.interactions = new Map();
    }
    addInteractionData(interactionData) {
      const { interaction, interactionTx } = interactionData;
      const interactionCall = InteractionCall2.create(new InteractionInput(interactionTx.id, interactionTx.block.height, interactionTx.block.timestamp, interaction == null ? void 0 : interaction.caller, interaction == null ? void 0 : interaction.input.function, interaction == null ? void 0 : interaction.input, interactionTx.dry, new Map()));
      this.interactions.set(interactionTx.id, interactionCall);
      return interactionCall;
    }
    getInteraction(txId) {
      return this.interactions.get(txId);
    }
    print() {
      return JSON.stringify(this, mapReplacer);
    }
  };
  var InteractionCall2 = class {
    constructor(interactionInput) {
      this.interactionInput = interactionInput;
    }
    static create(interactionInput) {
      return new InteractionCall2(interactionInput);
    }
    update(interactionOutput) {
      this.interactionOutput = interactionOutput;
    }
  };
  var InteractionInput = class {
    constructor(txId, blockHeight, blockTimestamp, caller, functionName, functionArguments, dryWrite, foreignContractCalls = new Map()) {
      this.txId = txId;
      this.blockHeight = blockHeight;
      this.blockTimestamp = blockTimestamp;
      this.caller = caller;
      this.functionName = functionName;
      this.functionArguments = functionArguments;
      this.dryWrite = dryWrite;
      this.foreignContractCalls = foreignContractCalls;
    }
  };
  var InteractionOutput = class {
    constructor(cacheHit, intermediaryCacheHit, outputState, executionTime, valid, errorMessage = "", gasUsed) {
      this.cacheHit = cacheHit;
      this.intermediaryCacheHit = intermediaryCacheHit;
      this.outputState = outputState;
      this.executionTime = executionTime;
      this.valid = valid;
      this.errorMessage = errorMessage;
      this.gasUsed = gasUsed;
    }
  };

  // src/plugins/CacheableContractInteractionsLoader.ts
  var CacheableContractInteractionsLoader = class {
    constructor(baseImplementation, cache) {
      this.baseImplementation = baseImplementation;
      this.cache = cache;
      this.logger = LoggerFactory.INST.create("CacheableContractInteractionsLoader");
    }
    async load(contractId, fromBlockHeight, toBlockHeight, evaluationOptions) {
      const benchmark = Benchmark.measure();
      this.logger.debug("Loading interactions", {
        contractId,
        fromBlockHeight,
        toBlockHeight
      });
      const { cachedHeight, cachedValue } = await this.cache.getLast(contractId) || {
        cachedHeight: -1,
        cachedValue: []
      };
      if (cachedHeight >= toBlockHeight) {
        this.logger.debug("Reusing interactions cached at higher block height:", cachedHeight);
        return cachedValue.filter((interaction) => interaction.node.block.height >= fromBlockHeight && interaction.node.block.height <= toBlockHeight);
      }
      this.logger.trace("Cached:", {
        cachedHeight,
        cachedValue
      });
      const missingInteractions = await this.baseImplementation.load(contractId, Math.max(cachedHeight + 1, fromBlockHeight), toBlockHeight, evaluationOptions);
      const result = cachedValue.filter((interaction) => interaction.node.block.height >= fromBlockHeight).concat(missingInteractions);
      const valueToCache = cachedValue.concat(missingInteractions);
      this.logger.debug("Interactions load result:", {
        cached: cachedValue.length,
        missing: missingInteractions.length,
        total: valueToCache.length,
        result: result.length
      });
      await this.cache.put(new BlockHeightKey3(contractId, toBlockHeight), valueToCache);
      this.logger.debug(`Interactions loaded in ${benchmark.elapsed()}`);
      return result;
    }
  };

  // src/plugins/CacheableExecutorFactory.ts
  var CacheableExecutorFactory = class {
    constructor(arweave, baseImplementation, cache) {
      this.arweave = arweave;
      this.baseImplementation = baseImplementation;
      this.cache = cache;
      this.logger = LoggerFactory.INST.create("CacheableExecutorFactory");
    }
    async create(contractDefinition, evaluationOptions) {
      return await this.baseImplementation.create(contractDefinition, evaluationOptions);
    }
  };

  // src/plugins/DebuggableExecutorFactor.ts
  var DebuggableExecutorFactory = class {
    constructor(baseImplementation, sourceCode) {
      this.baseImplementation = baseImplementation;
      this.sourceCode = sourceCode;
    }
    async create(contractDefinition, evaluationOptions) {
      if (Object.prototype.hasOwnProperty.call(this.sourceCode, contractDefinition.txId)) {
        contractDefinition = __spreadProps(__spreadValues({}, contractDefinition), {
          src: this.sourceCode[contractDefinition.txId]
        });
      }
      return await this.baseImplementation.create(contractDefinition, evaluationOptions);
    }
  };

  // src/plugins/Evolve.ts
  function isEvolveCompatible(state) {
    if (!state) {
      return false;
    }
    const settings = evalSettings(state);
    return state.evolve !== void 0 || settings.has("evolve");
  }
  var Evolve = class {
    constructor(definitionLoader, executorFactory) {
      this.definitionLoader = definitionLoader;
      this.executorFactory = executorFactory;
      this.logger = LoggerFactory.INST.create("Evolve");
      this.modify = this.modify.bind(this);
    }
    async modify(state, executionContext) {
      const contractTxId = executionContext.contractDefinition.txId;
      this.logger.debug(`trying to evolve for: ${contractTxId}`);
      const evolvedSrcTxId = Evolve.evolvedSrcTxId(state);
      const currentSrcTxId = executionContext.contractDefinition.srcTxId;
      if (evolvedSrcTxId) {
        this.logger.debug("Checking evolve:", {
          current: currentSrcTxId,
          evolvedSrcTxId
        });
        if (currentSrcTxId !== evolvedSrcTxId) {
          try {
            this.logger.info("Evolving to: ", evolvedSrcTxId);
            const newContractDefinition = await this.definitionLoader.load(contractTxId, evolvedSrcTxId);
            const newHandler = await this.executorFactory.create(newContractDefinition, executionContext.evaluationOptions);
            executionContext.contractDefinition = newContractDefinition;
            executionContext.handler = newHandler;
            this.logger.debug("evolved to:", {
              evolve: evolvedSrcTxId,
              newSrcTxId: executionContext.contractDefinition.srcTxId,
              current: currentSrcTxId,
              txId: executionContext.contractDefinition.txId
            });
            return executionContext;
          } catch (e) {
            throw new SmartWeaveError(SmartWeaveErrorType.CONTRACT_NOT_FOUND, {
              message: `Contract having txId: ${contractTxId} not found`,
              requestedTxId: contractTxId
            });
          }
        }
      }
      return executionContext;
    }
    static evolvedSrcTxId(state) {
      if (!isEvolveCompatible(state)) {
        return void 0;
      }
      const settings = evalSettings(state);
      const evolve = state.evolve || settings.get("evolve");
      let canEvolve = state.canEvolve || settings.get("canEvolve");
      if (canEvolve === void 0 || canEvolve === null) {
        canEvolve = true;
      }
      if (evolve && /[a-z0-9_-]{43}/i.test(evolve) && canEvolve) {
        return evolve;
      }
      return void 0;
    }
  };
  function evalSettings(state) {
    let settings = new Map();
    if (state.settings) {
      if (isIterable(state.settings)) {
        settings = new Map(state.settings);
      } else if (isObject(state.settings)) {
        settings = new Map(Object.entries(state.settings));
      }
    }
    return settings;
  }
  function isIterable(obj) {
    if (obj == null) {
      return false;
    }
    return typeof obj[Symbol.iterator] === "function";
  }
  function isObject(obj) {
    return typeof obj === "object" && obj !== null && !Array.isArray(obj);
  }

  // src/core/web/SmartWeaveWebFactory.ts
  var SmartWeaveWebFactory = class {
    static remoteCached(arweave, cacheBaseURL) {
      return this.remoteCacheBased(arweave, cacheBaseURL).build();
    }
    static remoteCacheBased(arweave, cacheBaseURL) {
      const definitionLoader = new ContractDefinitionLoader(arweave, new MemCache());
      const interactionsLoader = new CacheableContractInteractionsLoader(new ArweaveGatewayInteractionsLoader(arweave), new RemoteBlockHeightCache("INTERACTIONS", cacheBaseURL));
      const executorFactory = new CacheableExecutorFactory(arweave, new HandlerExecutorFactory(arweave), new MemCache());
      const stateEvaluator = new CacheableStateEvaluator(arweave, new RemoteBlockHeightCache("STATE", cacheBaseURL), [new Evolve(definitionLoader, executorFactory)]);
      const interactionsSorter = new LexicographicalInteractionsSorter(arweave);
      return SmartWeave.builder(arweave).setDefinitionLoader(definitionLoader).setInteractionsLoader(interactionsLoader).setInteractionsSorter(interactionsSorter).setExecutorFactory(executorFactory).setStateEvaluator(stateEvaluator);
    }
    static memCached(arweave, maxStoredBlockHeights = 10) {
      return this.memCachedBased(arweave, maxStoredBlockHeights).build();
    }
    static memCachedBased(arweave, maxStoredBlockHeights = 10, stateCache) {
      const definitionLoader = new ContractDefinitionLoader(arweave, new MemCache());
      const interactionsLoader = new ArweaveGatewayInteractionsLoader(arweave);
      const executorFactory = new CacheableExecutorFactory(arweave, new HandlerExecutorFactory(arweave), new MemCache());
      const stateEvaluator = new CacheableStateEvaluator(arweave, stateCache ? stateCache : new MemBlockHeightSwCache(maxStoredBlockHeights), [new Evolve(definitionLoader, executorFactory)]);
      const interactionsSorter = new LexicographicalInteractionsSorter(arweave);
      return SmartWeave.builder(arweave).setDefinitionLoader(definitionLoader).setCacheableInteractionsLoader(interactionsLoader).setInteractionsSorter(interactionsSorter).setExecutorFactory(executorFactory).setStateEvaluator(stateEvaluator);
    }
  };

  // src/core/node/SmartWeaveNodeFactory.ts
  var SmartWeaveNodeFactory = class extends SmartWeaveWebFactory {
    static fileCached(arweave, cacheBasePath, maxStoredInMemoryBlockHeights = 10) {
      return this.fileCachedBased(arweave, cacheBasePath, maxStoredInMemoryBlockHeights).build();
    }
    static fileCachedBased(arweave, cacheBasePath, maxStoredInMemoryBlockHeights = 10) {
      const definitionLoader = new ContractDefinitionLoader(arweave, new MemCache());
      const gatewayInteractionsLoader = new ArweaveGatewayInteractionsLoader(arweave);
      const executorFactory = new CacheableExecutorFactory(arweave, new HandlerExecutorFactory(arweave), new MemCache());
      const stateEvaluator = new CacheableStateEvaluator(arweave, new FileBlockHeightSwCache(cacheBasePath, maxStoredInMemoryBlockHeights), [new Evolve(definitionLoader, executorFactory)]);
      const interactionsSorter = new LexicographicalInteractionsSorter(arweave);
      return SmartWeave.builder(arweave).setDefinitionLoader(definitionLoader).setCacheableInteractionsLoader(gatewayInteractionsLoader).setInteractionsSorter(interactionsSorter).setExecutorFactory(executorFactory).setStateEvaluator(stateEvaluator);
    }
    static async knexCached(arweave, dbConnection, maxStoredInMemoryBlockHeights = 10) {
      return (await this.knexCachedBased(arweave, dbConnection, maxStoredInMemoryBlockHeights)).build();
    }
    static async knexCachedBased(arweave, dbConnection, maxStoredInMemoryBlockHeights = 10) {
      const definitionLoader = new ContractDefinitionLoader(arweave, new MemCache());
      const gatewayInteractionsLoader = new ArweaveGatewayInteractionsLoader(arweave);
      const executorFactory = new CacheableExecutorFactory(arweave, new HandlerExecutorFactory(arweave), new MemCache());
      const stateEvaluator = new CacheableStateEvaluator(arweave, await KnexStateCache.init(dbConnection, maxStoredInMemoryBlockHeights), [new Evolve(definitionLoader, executorFactory)]);
      const interactionsSorter = new LexicographicalInteractionsSorter(arweave);
      return SmartWeave.builder(arweave).setDefinitionLoader(definitionLoader).setCacheableInteractionsLoader(gatewayInteractionsLoader).setInteractionsSorter(interactionsSorter).setExecutorFactory(executorFactory).setStateEvaluator(stateEvaluator);
    }
  };

  // src/contract/HandlerBasedContract.ts
  var HandlerBasedContract = class {
    constructor(_contractTxId, smartweave, _parentContract = null, _callingInteraction = null) {
      this._contractTxId = _contractTxId;
      this.smartweave = smartweave;
      this._parentContract = _parentContract;
      this._callingInteraction = _callingInteraction;
      this.logger = LoggerFactory.INST.create("HandlerBasedContract");
      this._evaluationOptions = new DefaultEvaluationOptions();
      this._networkInfo = null;
      this._rootBlockHeight = null;
      this._innerWritesEvaluator = new InnerWritesEvaluator();
      this._benchmarkStats = null;
      this.waitForConfirmation = this.waitForConfirmation.bind(this);
      this._arweaveWrapper = new ArweaveWrapper(smartweave.arweave);
      if (_parentContract != null) {
        this._networkInfo = _parentContract.getNetworkInfo();
        this._rootBlockHeight = _parentContract.getRootBlockHeight();
        this._evaluationOptions = _parentContract.evaluationOptions();
        this._callDepth = _parentContract.callDepth() + 1;
        const interaction = _parentContract.getCallStack().getInteraction(_callingInteraction.id);
        if (this._callDepth > this._evaluationOptions.maxCallDepth) {
          throw Error(`Max call depth of ${this._evaluationOptions.maxCallDepth} has been exceeded for interaction ${JSON.stringify(interaction.interactionInput)}`);
        }
        if (this._networkInfo == null) {
          throw Error("Calling contract should have the network info already set!");
        }
        this.logger.debug("Calling interaction id", _callingInteraction.id);
        const callStack = new ContractCallStack(_contractTxId, this._callDepth);
        interaction.interactionInput.foreignContractCalls.set(_contractTxId, callStack);
        this._callStack = callStack;
      } else {
        this._callDepth = 0;
        this._callStack = new ContractCallStack(_contractTxId, 0);
      }
    }
    async readState(blockHeight, currentTx) {
      return this.readStateSequencer(blockHeight, void 0, currentTx);
    }
    async readStateSequencer(blockHeight, upToTransactionId, currentTx) {
      var _a, _b;
      this.logger.info("Read state for", {
        contractTxId: this._contractTxId,
        currentTx
      });
      const initBenchmark = Benchmark.measure();
      this.maybeResetRootContract(blockHeight);
      const { stateEvaluator } = this.smartweave;
      const executionContext = await this.createExecutionContext(this._contractTxId, blockHeight, false, upToTransactionId);
      this.logger.info("Execution Context", {
        blockHeight: executionContext.blockHeight,
        srcTxId: (_a = executionContext.contractDefinition) == null ? void 0 : _a.srcTxId,
        missingInteractions: executionContext.sortedInteractions.length,
        cachedStateHeight: (_b = executionContext.cachedState) == null ? void 0 : _b.cachedHeight,
        upToTransactionId
      });
      initBenchmark.stop();
      const stateBenchmark = Benchmark.measure();
      const result = await stateEvaluator.eval(executionContext, currentTx || []);
      stateBenchmark.stop();
      const total = initBenchmark.elapsed(true) + stateBenchmark.elapsed(true);
      this._benchmarkStats = {
        gatewayCommunication: initBenchmark.elapsed(true),
        stateEvaluation: stateBenchmark.elapsed(true),
        total
      };
      this.logger.info("Benchmark", {
        "Gateway communication  ": initBenchmark.elapsed(),
        "Contract evaluation    ": stateBenchmark.elapsed(),
        "Total:                 ": `${total.toFixed(0)}ms`
      });
      return result;
    }
    async viewState(input, blockHeight, tags = [], transfer = emptyTransfer) {
      this.logger.info("View state for", this._contractTxId);
      return await this.callContract(input, void 0, blockHeight, tags, transfer);
    }
    async viewStateForTx(input, interactionTx) {
      this.logger.info(`View state for ${this._contractTxId}`, interactionTx);
      return await this.callContractForTx(input, interactionTx);
    }
    async dryWrite(input, caller, tags, transfer) {
      this.logger.info("Dry-write for", this._contractTxId);
      return await this.callContract(input, caller, void 0, tags, transfer);
    }
    async dryWriteFromTx(input, transaction, currentTx) {
      this.logger.info(`Dry-write from transaction ${transaction.id} for ${this._contractTxId}`);
      return await this.callContractForTx(input, transaction, currentTx || []);
    }
    async writeInteraction(input, tags = [], transfer = emptyTransfer, strict = false) {
      this.logger.info("Write interaction input", input);
      if (!this.wallet) {
        throw new Error("Wallet not connected. Use 'connect' method first.");
      }
      const { arweave } = this.smartweave;
      const interactionTx = await this.createInteraction(input, tags, transfer, strict);
      const response = await arweave.transactions.post(interactionTx);
      if (response.status !== 200) {
        this.logger.error("Error while posting transaction", response);
        return null;
      }
      if (this._evaluationOptions.waitForConfirmation) {
        this.logger.info("Waiting for confirmation of", interactionTx.id);
        const benchmark = Benchmark.measure();
        await this.waitForConfirmation(interactionTx.id);
        this.logger.info("Transaction confirmed after", benchmark.elapsed());
      }
      return interactionTx.id;
    }
    async bundleInteraction(input, tags = [], transfer = emptyTransfer, strict = false) {
      this.logger.info("Bundle interaction input", input);
      if (!this.wallet) {
        throw new Error("Wallet not connected. Use 'connect' method first.");
      }
      const interactionTx = await this.createInteraction(input, tags, transfer, strict);
      const response = await fetch(`${this._evaluationOptions.bundlerAddress}gateway/sequencer/register`, {
        method: "POST",
        body: JSON.stringify(interactionTx),
        headers: {
          "Accept-Encoding": "gzip, deflate, br",
          "Content-Type": "application/json",
          Accept: "application/json"
        }
      }).then((res) => {
        this.logger.debug(res);
        return res.ok ? res.json() : Promise.reject(res);
      }).catch((error) => {
        var _a;
        this.logger.error(error);
        if ((_a = error.body) == null ? void 0 : _a.message) {
          this.logger.error(error.body.message);
        }
        throw new Error(`Unable to bundle interaction: ${JSON.stringify(error)}`);
      });
      return {
        bundlrResponse: response,
        originalTxId: interactionTx.id
      };
    }
    async createInteraction(input, tags, transfer, strict) {
      if (this._evaluationOptions.internalWrites) {
        const handlerResult = await this.callContract(input, void 0, void 0, tags, transfer);
        if (strict && handlerResult.type !== "ok") {
          throw Error(`Cannot create interaction: ${handlerResult.errorMessage}`);
        }
        const callStack = this.getCallStack();
        const innerWrites = this._innerWritesEvaluator.eval(callStack);
        this.logger.debug("Input", input);
        this.logger.debug("Callstack", callStack.print());
        innerWrites.forEach((contractTxId) => {
          tags.push({
            name: SmartWeaveTags.INTERACT_WRITE,
            value: contractTxId
          });
        });
        this.logger.debug("Tags with inner calls", tags);
      } else {
        if (strict) {
          const handlerResult = await this.callContract(input, void 0, void 0, tags, transfer);
          if (handlerResult.type !== "ok") {
            throw Error(`Cannot create interaction: ${handlerResult.errorMessage}`);
          }
        }
      }
      const interactionTx = await createTx(this.smartweave.arweave, this.wallet, this._contractTxId, input, tags, transfer.target, transfer.winstonQty);
      return interactionTx;
    }
    txId() {
      return this._contractTxId;
    }
    getCallStack() {
      return this._callStack;
    }
    getNetworkInfo() {
      return this._networkInfo;
    }
    connect(wallet) {
      this.wallet = wallet;
      return this;
    }
    setEvaluationOptions(options) {
      this._evaluationOptions = __spreadValues(__spreadValues({}, this._evaluationOptions), options);
      return this;
    }
    getRootBlockHeight() {
      return this._rootBlockHeight;
    }
    async waitForConfirmation(transactionId) {
      const { arweave } = this.smartweave;
      const status = await arweave.transactions.getStatus(transactionId);
      if (status.confirmed === null) {
        this.logger.info(`Transaction ${transactionId} not yet confirmed. Waiting another 20 seconds before next check.`);
        await sleep(2e4);
        await this.waitForConfirmation(transactionId);
      } else {
        this.logger.info(`Transaction ${transactionId} confirmed`, status);
        return status;
      }
    }
    async createExecutionContext(contractTxId, blockHeight, forceDefinitionLoad = false, upToTransactionId = void 0) {
      var _a;
      const { definitionLoader, interactionsLoader, interactionsSorter, executorFactory, stateEvaluator } = this.smartweave;
      let currentNetworkInfo;
      const benchmark = Benchmark.measure();
      if (this._parentContract == null) {
        if (blockHeight) {
          this._networkInfo = {
            height: blockHeight
          };
        } else {
          this.logger.debug("Reading network info for root call");
          currentNetworkInfo = await this._arweaveWrapper.info();
          this._networkInfo = currentNetworkInfo;
        }
      } else {
        this.logger.debug("Reusing network info from the calling contract");
        currentNetworkInfo = this._parentContract._networkInfo;
      }
      if (blockHeight == null) {
        blockHeight = currentNetworkInfo.height;
      }
      this.logger.debug("network info", benchmark.elapsed());
      benchmark.reset();
      const cachedState = await stateEvaluator.latestAvailableState(contractTxId, blockHeight);
      let cachedBlockHeight = -1;
      if (cachedState != null) {
        cachedBlockHeight = cachedState.cachedHeight;
      }
      this.logger.debug("cache lookup", benchmark.elapsed());
      benchmark.reset();
      const evolvedSrcTxId = Evolve.evolvedSrcTxId((_a = cachedState == null ? void 0 : cachedState.cachedValue) == null ? void 0 : _a.state);
      let contractDefinition, interactions = [], sortedInteractions = [], handler;
      if (cachedBlockHeight != blockHeight) {
        [contractDefinition, interactions] = await Promise.all([
          definitionLoader.load(contractTxId, evolvedSrcTxId),
          interactionsLoader.load(contractTxId, cachedBlockHeight + 1, this._rootBlockHeight || this._networkInfo.height, this._evaluationOptions, upToTransactionId)
        ]);
        this.logger.debug("contract and interactions load", benchmark.elapsed());
        sortedInteractions = await interactionsSorter.sort(interactions);
        this.logger.trace("Sorted interactions", sortedInteractions);
        handler = await executorFactory.create(contractDefinition, this._evaluationOptions);
      } else {
        this.logger.debug("State fully cached, not loading interactions.");
        if (forceDefinitionLoad || evolvedSrcTxId) {
          contractDefinition = await definitionLoader.load(contractTxId, evolvedSrcTxId);
          handler = await executorFactory.create(contractDefinition, this._evaluationOptions);
        }
      }
      const containsInteractionsFromSequencer = interactions.some((i) => i.node.source == SourceType.REDSTONE_SEQUENCER);
      this.logger.debug("containsInteractionsFromSequencer", containsInteractionsFromSequencer);
      return {
        contractDefinition,
        blockHeight,
        sortedInteractions,
        handler,
        smartweave: this.smartweave,
        contract: this,
        evaluationOptions: this._evaluationOptions,
        currentNetworkInfo,
        cachedState,
        containsInteractionsFromSequencer,
        upToTransactionId
      };
    }
    async createExecutionContextFromTx(contractTxId, transaction) {
      const benchmark = Benchmark.measure();
      const { definitionLoader, interactionsLoader, interactionsSorter, executorFactory, stateEvaluator } = this.smartweave;
      const blockHeight = transaction.block.height;
      const caller = transaction.owner.address;
      const cachedState = await stateEvaluator.latestAvailableState(contractTxId, blockHeight);
      let cachedBlockHeight = -1;
      if (cachedState != null) {
        cachedBlockHeight = cachedState.cachedHeight;
      }
      let contractDefinition, interactions = [], sortedInteractions = [];
      if (cachedBlockHeight != blockHeight) {
        [contractDefinition, interactions] = await Promise.all([
          definitionLoader.load(contractTxId),
          await interactionsLoader.load(contractTxId, 0, blockHeight, this._evaluationOptions)
        ]);
        sortedInteractions = await interactionsSorter.sort(interactions);
      } else {
        this.logger.debug("State fully cached, not loading interactions.");
        contractDefinition = await definitionLoader.load(contractTxId);
      }
      const handler = await executorFactory.create(contractDefinition, this._evaluationOptions);
      this.logger.debug("Creating execution context from tx:", benchmark.elapsed());
      const containsInteractionsFromSequencer = interactions.some((i) => i.node.source == SourceType.REDSTONE_SEQUENCER);
      return {
        contractDefinition,
        blockHeight,
        sortedInteractions,
        handler,
        smartweave: this.smartweave,
        contract: this,
        evaluationOptions: this._evaluationOptions,
        caller,
        cachedState,
        containsInteractionsFromSequencer
      };
    }
    maybeResetRootContract(blockHeight) {
      if (this._parentContract == null) {
        this.logger.debug("Clearing network info and call stack for the root contract");
        this._networkInfo = null;
        this._callStack = new ContractCallStack(this.txId(), 0);
        this._rootBlockHeight = blockHeight;
      }
    }
    async callContract(input, caller, blockHeight, tags = [], transfer = emptyTransfer) {
      var _a;
      this.logger.info("Call contract input", input);
      this.maybeResetRootContract();
      if (!this.wallet) {
        this.logger.warn("Wallet not set.");
      }
      const { arweave, stateEvaluator } = this.smartweave;
      let executionContext = await this.createExecutionContext(this._contractTxId, blockHeight, true);
      if (!executionContext.currentBlockData) {
        const currentBlockData = ((_a = executionContext.currentNetworkInfo) == null ? void 0 : _a.current) ? await arweave.blocks.get(executionContext.currentNetworkInfo.current) : await arweave.blocks.getCurrent();
        executionContext = __spreadProps(__spreadValues({}, executionContext), {
          currentBlockData
        });
      }
      const effectiveCaller = caller || (this.wallet ? await arweave.wallets.jwkToAddress(this.wallet) : "");
      executionContext = __spreadProps(__spreadValues({}, executionContext), {
        caller: effectiveCaller
      });
      const evalStateResult = await stateEvaluator.eval(executionContext, []);
      const interaction = {
        input,
        caller: executionContext.caller
      };
      this.logger.debug("interaction", interaction);
      const tx = await createTx(arweave, this.wallet, this._contractTxId, input, tags, transfer.target, transfer.winstonQty);
      const dummyTx = createDummyTx(tx, executionContext.caller, executionContext.currentBlockData);
      const handleResult2 = await this.evalInteraction({
        interaction,
        interactionTx: dummyTx,
        currentTx: []
      }, executionContext, evalStateResult);
      if (handleResult2.type !== "ok") {
        this.logger.fatal("Error while interacting with contract", {
          type: handleResult2.type,
          error: handleResult2.errorMessage
        });
      }
      return handleResult2;
    }
    async callContractForTx(input, interactionTx, currentTx) {
      this.maybeResetRootContract();
      const executionContext = await this.createExecutionContextFromTx(this._contractTxId, interactionTx);
      const evalStateResult = await this.smartweave.stateEvaluator.eval(executionContext, currentTx);
      this.logger.debug("callContractForTx - evalStateResult", {
        result: evalStateResult.state,
        txId: this._contractTxId
      });
      const interaction = {
        input,
        caller: this._parentContract.txId()
      };
      const interactionData = {
        interaction,
        interactionTx,
        currentTx
      };
      return await this.evalInteraction(interactionData, executionContext, evalStateResult);
    }
    async evalInteraction(interactionData, executionContext, evalStateResult) {
      const interactionCall = this.getCallStack().addInteractionData(interactionData);
      const benchmark = Benchmark.measure();
      const result = await executionContext.handler.handle(executionContext, evalStateResult, interactionData);
      interactionCall.update({
        cacheHit: false,
        intermediaryCacheHit: false,
        outputState: this._evaluationOptions.stackTrace.saveState ? result.state : void 0,
        executionTime: benchmark.elapsed(true),
        valid: result.type === "ok",
        errorMessage: result.errorMessage,
        gasUsed: result.gasUsed
      });
      return result;
    }
    parent() {
      return this._parentContract;
    }
    callDepth() {
      return this._callDepth;
    }
    evaluationOptions() {
      return this._evaluationOptions;
    }
    lastReadStateStats() {
      return this._benchmarkStats;
    }
    stateHash(state) {
      const jsonState = wrapper_default(state);
      const hash = crypto2.createHash("sha256");
      hash.update(jsonState);
      return hash.digest("hex");
    }
  };

  // src/contract/PstContractImpl.ts
  var PstContractImpl = class extends HandlerBasedContract {
    async currentBalance(target) {
      const interactionResult = await this.viewState({ function: "balance", target });
      if (interactionResult.type !== "ok") {
        throw Error(interactionResult.errorMessage);
      }
      return interactionResult.result;
    }
    async currentState() {
      return (await super.readState()).state;
    }
    async transfer(transfer) {
      return await this.writeInteraction(__spreadValues({ function: "transfer" }, transfer));
    }
    async evolve(newSrcTxId) {
      return await this.writeInteraction({ function: "evolve", value: newSrcTxId });
    }
    async saveNewSource(newContractSource) {
      if (!this.wallet) {
        throw new Error("Wallet not connected. Use 'connect' method first.");
      }
      const { arweave } = this.smartweave;
      const tx = await arweave.createTransaction({ data: newContractSource }, this.wallet);
      tx.addTag(SmartWeaveTags.APP_NAME, "SmartWeaveContractSource");
      tx.addTag(SmartWeaveTags.APP_VERSION, "0.3.0");
      tx.addTag("Content-Type", "application/javascript");
      await arweave.transactions.sign(tx, this.wallet);
      await arweave.transactions.post(tx);
      return tx.id;
    }
  };

  // src/contract/InnerWritesEvaluator.ts
  var InnerWritesEvaluator = class {
    eval(callStack) {
      const result = [];
      callStack.interactions.forEach((interaction) => {
        this.evalForeignCalls(callStack.contractTxId, interaction, result);
      });
      return result;
    }
    evalForeignCalls(rootContractTxId, interaction, result) {
      interaction.interactionInput.foreignContractCalls.forEach((foreignContractCall) => {
        foreignContractCall.interactions.forEach((foreignInteraction) => {
          if (foreignInteraction.interactionInput.dryWrite && !result.includes(foreignContractCall.contractTxId) && rootContractTxId !== foreignContractCall.contractTxId) {
            result.push(foreignContractCall.contractTxId);
          }
          this.evalForeignCalls(rootContractTxId, foreignInteraction, result);
        });
      });
    }
  };

  // src/core/SmartWeave.ts
  var SmartWeave = class {
    constructor(arweave, definitionLoader, interactionsLoader, interactionsSorter, executorFactory, stateEvaluator) {
      this.arweave = arweave;
      this.definitionLoader = definitionLoader;
      this.interactionsLoader = interactionsLoader;
      this.interactionsSorter = interactionsSorter;
      this.executorFactory = executorFactory;
      this.stateEvaluator = stateEvaluator;
      this.createContract = new DefaultCreateContract(arweave);
    }
    static builder(arweave) {
      return new SmartWeaveBuilder3(arweave);
    }
    contract(contractTxId, callingContract, callingInteraction) {
      return new HandlerBasedContract(contractTxId, this, callingContract, callingInteraction);
    }
    pst(contractTxId) {
      return new PstContractImpl(contractTxId, this);
    }
    async flushCache() {
      await this.stateEvaluator.flushCache();
    }
  };

  // src/core/SmartWeaveBuilder.ts
  var SmartWeaveBuilder3 = class {
    constructor(_arweave) {
      this._arweave = _arweave;
    }
    setDefinitionLoader(value) {
      this._definitionLoader = value;
      return this;
    }
    setInteractionsLoader(value) {
      this._interactionsLoader = value;
      return this;
    }
    setCacheableInteractionsLoader(value, maxStoredInMemoryBlockHeights = 1) {
      this._interactionsLoader = new CacheableContractInteractionsLoader(value, new MemBlockHeightSwCache(maxStoredInMemoryBlockHeights));
      return this;
    }
    setInteractionsSorter(value) {
      this._interactionsSorter = value;
      return this;
    }
    setExecutorFactory(value) {
      this._executorFactory = value;
      return this;
    }
    setStateEvaluator(value) {
      this._stateEvaluator = value;
      return this;
    }
    overwriteSource(sourceCode) {
      if (this._executorFactory == null) {
        throw new Error("Set base ExecutorFactory first");
      }
      this._executorFactory = new DebuggableExecutorFactory(this._executorFactory, sourceCode);
      return this.build();
    }
    useRedStoneGateway(confirmationStatus = null, source = null, address = "https://gateway.redstone.finance") {
      this._interactionsLoader = new RedstoneGatewayInteractionsLoader(address, confirmationStatus, source);
      this._definitionLoader = new RedstoneGatewayContractDefinitionLoader(address, this._arweave, new MemCache());
      return this;
    }
    build() {
      return new SmartWeave(this._arweave, this._definitionLoader, this._interactionsLoader, this._interactionsSorter, this._executorFactory, this._stateEvaluator);
    }
  };

  // src/legacy/smartweave-global.ts
  var SmartWeaveGlobal5 = class {
    constructor(arweave, contract, gasLimit = Number.MAX_SAFE_INTEGER) {
      this.gasUsed = 0;
      this.gasLimit = gasLimit;
      this.unsafeClient = arweave;
      this.arweave = {
        ar: arweave.ar,
        utils: arweave.utils,
        wallets: arweave.wallets,
        crypto: arweave.crypto
      };
      this.contract = contract;
      this.transaction = new Transaction3(this);
      this.block = new Block(this);
      this.contracts = {
        readContractState: (contractId, height, returnValidity) => {
          throw new Error("Not implemented - should be set by HandlerApi implementor");
        },
        viewContractState: (contractId, input) => {
          throw new Error("Not implemented - should be set by HandlerApi implementor");
        },
        write: (contractId, input) => {
          throw new Error("Not implemented - should be set by HandlerApi implementor");
        },
        refreshState: () => {
          throw new Error("Not implemented - should be set by HandlerApi implementor");
        }
      };
      this.useGas = this.useGas.bind(this);
    }
    useGas(gas) {
      if (gas < 0) {
        throw new Error(`[RE:GNE] Gas number exception - gas < 0.`);
      }
      this.gasUsed += gas;
      if (this.gasUsed > this.gasLimit) {
        throw new Error(`[RE:OOG] Out of gas! Used: ${this.gasUsed}, limit: ${this.gasLimit}`);
      }
    }
  };
  var Transaction3 = class {
    constructor(global2) {
      this.global = global2;
    }
    get id() {
      if (!this.global._activeTx) {
        throw new Error("No current Tx");
      }
      return this.global._activeTx.id;
    }
    get owner() {
      if (!this.global._activeTx) {
        throw new Error("No current Tx");
      }
      return this.global._activeTx.owner.address;
    }
    get target() {
      if (!this.global._activeTx) {
        throw new Error("No current Tx");
      }
      return this.global._activeTx.recipient;
    }
    get tags() {
      if (!this.global._activeTx) {
        throw new Error("No current Tx");
      }
      return this.global._activeTx.tags;
    }
    get quantity() {
      if (!this.global._activeTx) {
        throw new Error("No current Tx");
      }
      return this.global._activeTx.quantity.winston;
    }
    get reward() {
      if (!this.global._activeTx) {
        throw new Error("No current Tx");
      }
      return this.global._activeTx.fee.winston;
    }
  };
  var Block = class {
    constructor(global2) {
      this.global = global2;
    }
    get height() {
      if (!this.global._activeTx) {
        throw new Error("No current Tx");
      }
      return this.global._activeTx.block.height;
    }
    get indep_hash() {
      if (!this.global._activeTx) {
        throw new Error("No current Tx");
      }
      return this.global._activeTx.block.id;
    }
    get timestamp() {
      if (!this.global._activeTx) {
        throw new Error("No current tx");
      }
      return this.global._activeTx.block.timestamp;
    }
  };

  // src/legacy/errors.ts
  var SmartWeaveErrorType;
  (function(SmartWeaveErrorType2) {
    SmartWeaveErrorType2["CONTRACT_NOT_FOUND"] = "CONTRACT_NOT_FOUND";
  })(SmartWeaveErrorType || (SmartWeaveErrorType = {}));
  var SmartWeaveError = class extends Error {
    constructor(type, optional = {}) {
      if (optional.message) {
        super(optional.message);
      } else {
        super();
      }
      this.type = type;
      this.otherInfo = optional;
    }
    getType() {
      return this.type;
    }
  };

  // src/legacy/utils.ts
  function getTag(tx, name) {
    const tags = tx.get("tags");
    for (const tag of tags) {
      try {
        if (tag.get("name", { decode: true, string: true }) === name) {
          return tag.get("value", { decode: true, string: true });
        }
      } catch (e) {
      }
    }
    return false;
  }
  function arrayToHex(arr) {
    let str = "";
    for (const a of arr) {
      str += ("0" + a.toString(16)).slice(-2);
    }
    return str;
  }

  // src/legacy/create-tx.ts
  async function createTx(arweave, wallet, contractId, input, tags, target = "", winstonQty = "0") {
    const options = {
      data: Math.random().toString().slice(-4)
    };
    if (target && target.length) {
      options.target = target.toString();
      if (winstonQty && +winstonQty > 0) {
        options.quantity = winstonQty.toString();
      }
    }
    const interactionTx = await arweave.createTransaction(options, wallet);
    if (!input) {
      throw new Error(`Input should be a truthy value: ${JSON.stringify(input)}`);
    }
    if (tags && tags.length) {
      for (const tag of tags) {
        interactionTx.addTag(tag.name.toString(), tag.value.toString());
      }
    }
    interactionTx.addTag(SmartWeaveTags.APP_NAME, "SmartWeaveAction");
    interactionTx.addTag(SmartWeaveTags.APP_VERSION, "0.3.0");
    interactionTx.addTag(SmartWeaveTags.SDK, "RedStone");
    interactionTx.addTag(SmartWeaveTags.CONTRACT_TX_ID, contractId);
    interactionTx.addTag(SmartWeaveTags.INPUT, JSON.stringify(input));
    await arweave.transactions.sign(interactionTx, wallet);
    return interactionTx;
  }
  function createDummyTx(tx, from, block) {
    const decodedTags = unpackTags(tx);
    return {
      id: tx.id,
      owner: {
        address: from,
        key: ""
      },
      recipient: tx.target,
      tags: decodedTags,
      fee: {
        winston: tx.reward,
        ar: ""
      },
      quantity: {
        winston: tx.quantity,
        ar: ""
      },
      block: {
        id: block.indep_hash,
        height: block.height,
        timestamp: block.timestamp,
        previous: null
      },
      dry: true,
      anchor: null,
      signature: null,
      data: null,
      parent: null,
      bundledIn: null
    };
  }
  function unpackTags(tx) {
    const tags = tx.get("tags");
    const result = [];
    for (const tag of tags) {
      try {
        const name = tag.get("name", { decode: true, string: true });
        const value = tag.get("value", { decode: true, string: true });
        result.push({ name, value });
      } catch (e) {
      }
    }
    return result;
  }
  return src_exports;
})();
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
